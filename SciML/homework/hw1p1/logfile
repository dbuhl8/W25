
chdir(/etc)
fchdir() to previous dir
sourcing "/etc/vimrc"
line 1: " All system-wide defaults are set in $VIMRUNTIME/archlinux.vim (usually just
line 2: " /usr/share/vim/vimfiles/archlinux.vim) and sourced by the call to :runtime
line 3: " you can find below.  If you wish to change any of those settings, you should
line 4: " do it in this file (/etc/vimrc), since archlinux.vim will be overwritten
line 5: " everytime an upgrade of the vim packages is performed.  It is recommended to
line 6: " make changes after sourcing archlinux.vim since it alters the value of the
line 7: " 'compatible' option.
line 8: 
line 9: " This line should not be removed as it ensures that various options are
line 10: " properly set to work with the Vim-related packages.
line 11: runtime! archlinux.vim
Searching for "archlinux.vim" in "/home/Dante/.vim,/usr/share/vim/vimfiles,/usr/share/vim/vim91,/usr/share/vim/vimfiles/after,/home/Dante/.vim/after"
Searching for "/home/Dante/.vim/archlinux.vim"
Searching for "/usr/share/vim/vimfiles/archlinux.vim"
chdir(/usr/share/vim/vimfiles)
fchdir() to previous dir
line 11: sourcing "/usr/share/vim/vimfiles/archlinux.vim"
line 1: " The Arch Linux global vimrc - setting only a few sane defaults
line 2: "
line 3: " DO NOT EDIT THIS FILE. IT'S OVERWRITTEN UPON UPGRADES.
line 4: "
line 5: " Use /etc/vimrc for system-wide and $HOME/.vimrc for personal configuration
line 6: " (for details see ':help initialization').
line 7: "
line 8: " Use :help '<option>' to see the documentation for the given option.
line 9: 
line 10: " Use Vim defaults instead of 100% vi compatibility
line 11: " Avoid side-effects when nocompatible has already been set.
line 12: if &compatible
line 13:   set nocompatible
line 14: endif
line 15: 
line 16: set backspace=indent,eol,start
line 17: set ruler
line 18: set suffixes+=.aux,.bbl,.blg,.brf,.cb,.dvi,.idx,.ilg,.ind,.inx,.jpg,.log,.out,.png,.toc
line 19: set suffixes-=.h
line 20: set suffixes-=.obj
line 21: 
line 22: " Move temporary files to a secure location to protect against CVE-2017-1000382
line 23: if exists('$XDG_CACHE_HOME')
line 24:   let &g:directory=$XDG_CACHE_HOME
line 25: else
line 26:   let &g:directory=$HOME . '/.cache'
line 27: endif
line 28: let &g:undodir=&g:directory . '/vim/undo//'
line 29: let &g:backupdir=&g:directory . '/vim/backup//'
line 30: let &g:directory.='/vim/swap//'
line 31: " Create directories if they doesn't exist
line 32: if ! isdirectory(expand(&g:directory))
line 33:   silent! call mkdir(expand(&g:directory), 'p', 0700)
line 34: endif
line 35: if ! isdirectory(expand(&g:backupdir))
line 36:   silent! call mkdir(expand(&g:backupdir), 'p', 0700)
line 37: endif
line 38: if ! isdirectory(expand(&g:undodir))
line 39:   silent! call mkdir(expand(&g:undodir), 'p', 0700)
line 40: endif
line 41: 
line 42: " Make shift-insert work like in Xterm
line 43: if has('gui_running')
line 44:   map <S-Insert> <MiddleMouse>
line 45:   map! <S-Insert> <MiddleMouse>
line 46: endif
finished sourcing /usr/share/vim/vimfiles/archlinux.vim
continuing in /etc/vimrc
Searching for "/usr/share/vim/vim91/archlinux.vim"
Searching for "/usr/share/vim/vimfiles/after/archlinux.vim"
Searching for "/home/Dante/.vim/after/archlinux.vim"
line 12: 
line 13: " If you prefer the old-style vim functionalty, add 'runtime! vimrc_example.vim'
line 14: " Or better yet, read /usr/share/vim/vim80/vimrc_example.vim or the vim manual
line 15: " and configure vim to your own liking!
line 16: 
line 17: " do not load defaults if ~/.vimrc is missing
line 18: "let skip_defaults_vim=1
finished sourcing /etc/vimrc
chdir(/home/Dante)
fchdir() to previous dir
sourcing "$HOME/.vimrc"
line 1: "File: vimrc
line 2: "Author: Dante Buhl
line 3: "Email: dbuhl@ucsc.edu
line 4: 
line 5: "This is my .vimrc file, it gives me some nice fortran tools and autocompletion
line 6: "Notice that some of my binds overwrite others. For example, pressing c in
line 7: "normal mode will usually comment out at the first non-white space character
line 8: "and C will uncomment (delete the first nonwhite space character)
line 9: 
line 10: 
line 11: "Plugins {{{
line 12: call plug#begin()
Searching for "autoload/plug.vim" in "/home/Dante/.vim,/usr/share/vim/vimfiles,/usr/share/vim/vim91,/usr/share/vim/vimfiles/after,/home/Dante/.vim/after"
Searching for "/home/Dante/.vim/autoload/plug.vim"
chdir(/home/Dante/.vim/autoload)
fchdir() to previous dir
line 12: sourcing "/home/Dante/.vim/autoload/plug.vim"
line 1: " vim-plug: Vim plugin manager
line 2: " ============================
line 3: "
line 4: " 1. Download plug.vim and put it in 'autoload' directory
line 5: "
line 6: "   # Vim
line 7: "   curl -fLo ~/.vim/autoload/plug.vim --create-dirs \
line 8: "     https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
line 9: "
line 10: "   # Neovim
line 11: "   sh -c 'curl -fLo "${XDG_DATA_HOME:-$HOME/.local/share}"/nvim/site/autoload/plug.vim --create-dirs \
line 12: "     https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim'
line 13: "
line 14: " 2. Add a vim-plug section to your ~/.vimrc (or ~/.config/nvim/init.vim for Neovim)
line 15: "
line 16: "   call plug#begin()
line 17: "
line 18: "   " List your plugins here
line 19: "   Plug 'tpope/vim-sensible'
line 20: "
line 21: "   call plug#end()
line 22: "
line 23: " 3. Reload the file or restart Vim, then you can,
line 24: "
line 25: "     :PlugInstall to install plugins
line 26: "     :PlugUpdate  to update plugins
line 27: "     :PlugDiff    to review the changes from the last update
line 28: "     :PlugClean   to remove plugins no longer in the list
line 29: "
line 30: " For more information, see https://github.com/junegunn/vim-plug
line 31: "
line 32: "
line 33: " Copyright (c) 2024 Junegunn Choi
line 34: "
line 35: " MIT License
line 36: "
line 37: " Permission is hereby granted, free of charge, to any person obtaining
line 38: " a copy of this software and associated documentation files (the
line 39: " "Software"), to deal in the Software without restriction, including
line 40: " without limitation the rights to use, copy, modify, merge, publish,
line 41: " distribute, sublicense, and/or sell copies of the Software, and to
line 42: " permit persons to whom the Software is furnished to do so, subject to
line 43: " the following conditions:
line 44: "
line 45: " The above copyright notice and this permission notice shall be
line 46: " included in all copies or substantial portions of the Software.
line 47: "
line 48: " THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
line 49: " EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
line 50: " MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
line 51: " NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
line 52: " LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
line 53: " OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
line 54: " WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
line 55: 
line 56: if exists('g:loaded_plug')
line 57:   finish
line 58: endif
line 59: let g:loaded_plug = 1
line 60: 
line 61: let s:cpo_save = &cpo
line 62: set cpo&vim
line 63: 
line 64: let s:plug_src = 'https://github.com/junegunn/vim-plug.git'
line 65: let s:plug_tab = get(s:, 'plug_tab', -1)
line 66: let s:plug_buf = get(s:, 'plug_buf', -1)
line 67: let s:mac_gui = has('gui_macvim') && has('gui_running')
line 68: let s:is_win = has('win32')
line 69: let s:nvim = has('nvim-0.2') || (has('nvim') && exists('*jobwait') && !s:is_win)
line 70: let s:vim8 = has('patch-8.0.0039') && exists('*job_start')
line 71: if s:is_win && &shellslash
line 72:   set noshellslash
line 73:   let s:me = resolve(expand('<sfile>:p'))
line 74:   set shellslash
line 75: else
line 76:   let s:me = resolve(expand('<sfile>:p'))
line 77: endif
line 78: let s:base_spec = { 'branch': '', 'frozen': 0 }
line 79: let s:TYPE = {   'string':  type(''),   'list':    type([]),   'dict':    type({}),   'funcref': type(function('call')) }
line 85: let s:loaded = get(s:, 'loaded', {})
line 86: let s:triggers = get(s:, 'triggers', {})
line 87: 
line 88: function! s:is_powershell(shell)
line 91: 
line 92: function! s:isabsolute(dir) abort
line 95: 
line 96: function! s:git_dir(dir) abort
line 110: 
line 111: function! s:git_origin_url(dir) abort
line 119: 
line 120: function! s:git_revision(dir) abort
line 147: 
line 148: function! s:git_local_branch(dir) abort
line 157: 
line 158: function! s:git_origin_branch(spec)
line 175: 
line 176: if s:is_win
line 177:   function! s:plug_call(fn, ...)
line 186: else
line 187:   function! s:plug_call(fn, ...)
line 190: endif
line 191: 
line 192: function! s:plug_getcwd()
line 195: 
line 196: function! s:plug_fnamemodify(fname, mods)
line 199: 
line 200: function! s:plug_expand(fmt)
line 203: 
line 204: function! s:plug_tempname()
line 207: 
line 208: function! plug#begin(...)
line 232: 
line 233: function! s:define_commands()
line 256: 
line 257: function! s:to_a(v)
line 260: 
line 261: function! s:to_s(v)
line 264: 
line 265: function! s:glob(from, pattern)
line 268: 
line 269: function! s:source(from, ...)
line 279: 
line 280: function! s:assoc(dict, key, val)
line 283: 
line 284: function! s:ask(message, ...)
line 293: 
line 294: function! s:ask_no_interrupt(...)
line 301: 
line 302: function! s:lazy(plug, opt)
line 309: 
line 310: function! plug#end()
line 405: 
line 406: function! s:loaded_names()
line 409: 
line 410: function! s:load_plugin(spec)
line 416: 
line 417: function! s:reload_plugins()
line 422: 
line 423: function! s:trim(str)
line 426: 
line 427: function! s:version_requirement(val, min)
line 436: 
line 437: function! s:git_version_requirement(...)
line 443: 
line 444: function! s:progress_opt(base)
line 448: 
line 449: function! s:rtp(spec)
line 452: 
line 453: if s:is_win
line 454:   function! s:path(path)
line 457: 
line 458:   function! s:dirpath(path)
line 461: 
line 462:   function! s:is_local_plug(repo)
line 465: 
line 466:   " Copied from fzf
line 467:   function! s:wrap_cmds(cmds)
line 481: 
line 482:   function! s:batchfile(cmd)
line 491: else
line 492:   function! s:path(path)
line 495: 
line 496:   function! s:dirpath(path)
line 499: 
line 500:   function! s:is_local_plug(repo)
line 503: endif
line 504: 
line 505: function! s:err(msg)
line 510: 
line 511: function! s:warn(cmd, msg)
line 516: 
line 517: function! s:esc(path)
line 520: 
line 521: function! s:escrtp(path)
line 524: 
line 525: function! s:remove_rtp()
line 535: 
line 536: function! s:reorg_rtp()
line 562: 
line 563: function! s:doautocmd(...)
line 568: 
line 569: function! s:dobufread(names)
line 582: 
line 583: function! plug#load(...)
line 606: 
line 607: function! s:remove_triggers(name)
line 620: 
line 621: function! s:lod(names, types, ...)
line 645: 
line 646: function! s:lod_ft(pat, names)
line 653: 
line 654: function! s:lod_cmd(cmd, bang, l1, l2, args, names)
line 659: 
line 660: function! s:lod_map(map, names, with_prefix, prefix)
line 685: 
line 686: function! plug#(repo, ...)
line 705: 
line 706: function! s:parse_options(arg)
line 743: 
line 744: function! s:infer_properties(name, repo)
line 761: 
line 762: function! s:install(force, names)
line 765: 
line 766: function! s:update(force, names)
line 769: 
line 770: function! plug#helptags()
line 782: 
line 783: function! s:syntax()
line 837: 
line 838: function! s:lpad(str, len)
line 841: 
line 842: function! s:lines(msg)
line 845: 
line 846: function! s:lastline(msg)
line 849: 
line 850: function! s:new_window()
line 853: 
line 854: function! s:plug_window_exists()
line 858: 
line 859: function! s:switch_in()
line 877: 
line 878: function! s:switch_out(...)
line 891: 
line 892: function! s:finish_bindings()
line 901: 
line 902: function! s:prepare(...)
line 944: 
line 945: function! s:close_pane()
line 955: 
line 956: function! s:assign_name()
line 967: 
line 968: function! s:chsh(swap)
line 982: 
line 983: function! s:bang(cmd, ...)
line 1004: 
line 1005: function! s:regress_bar()
line 1009: 
line 1010: function! s:is_updated(dir)
line 1013: 
line 1014: function! s:do(pull, force, todo)
line 1073: 
line 1074: function! s:hash_match(a, b)
line 1077: 
line 1078: function! s:checkout(spec)
line 1090: 
line 1091: function! s:finish(pull)
line 1114: 
line 1115: function! s:retry()
line 1123: 
line 1124: function! s:is_managed(name)
line 1127: 
line 1128: function! s:names(...)
line 1131: 
line 1132: function! s:check_ruby()
line 1142: 
line 1143: function! s:update_impl(pull, force, args) abort
line 1266: 
line 1267: function! s:log4(name, msg)
line 1271: 
line 1272: function! s:update_finish()
line 1332: 
line 1333: function! s:mark_aborted(name, message)
line 1337: 
line 1338: function! s:job_abort(cancel)
line 1365: 
line 1366: function! s:last_non_empty_line(lines)
line 1376: 
line 1377: function! s:bullet_for(job, ...)
line 1386: 
line 1387: function! s:job_out_cb(self, data) abort
line 1401: 
line 1402: function! s:job_exit_cb(self, data) abort
line 1408: 
line 1409: function! s:job_cb(fn, job, ch, data)
line 1415: 
line 1416: function! s:nvim_cb(job_id, data, event) dict abort
line 1421: 
line 1422: function! s:spawn(name, spec, queue, opts)
line 1473: 
line 1474: function! s:reap(name)
line 1496: 
line 1497: function! s:bar()
line 1506: 
line 1507: function! s:logpos(name)
line 1521: 
line 1522: function! s:log(bullet, name, lines)
line 1539: 
line 1540: function! s:update_vim()
line 1546: 
line 1547: function! s:checkout_command(spec)
line 1551: 
line 1552: function! s:merge_command(spec)
line 1556: 
line 1557: function! s:tick()
line 1629: 
line 1630: function! s:update_python()
line 2018: 
line 2019: function! s:update_ruby()
line 2244: 
line 2245: function! s:shellesc_cmd(arg, script)
line 2249: 
line 2250: function! s:shellesc_ps1(arg)
line 2253: 
line 2254: function! s:shellesc_sh(arg)
line 2257: 
line 2258: " Escape the shell argument based on the shell.
line 2259: " Vim and Neovim's shellescape() are insufficient.
line 2260: " 1. shellslash determines whether to use single/double quotes.
line 2261: "    Double-quote escaping is fragile for cmd.exe.
line 2262: " 2. It does not work for powershell.
line 2263: " 3. It does not work for *sh shells if the command is executed
line 2264: "    via cmd.exe (ie. cmd.exe /c sh -c command command_args)
line 2265: " 4. It does not support batchfile syntax.
line 2266: "
line 2267: " Accepts an optional dictionary with the following keys:
line 2268: " - shell: same as Vim/Neovim 'shell' option.
line 2269: "          If unset, fallback to 'cmd.exe' on Windows or 'sh'.
line 2270: " - script: If truthy and shell is cmd.exe, escape for batchfile syntax.
line 2271: function! plug#shellescape(arg, ...)
line 2285: 
line 2286: function! s:glob_dir(path)
line 2289: 
line 2290: function! s:progress_bar(line, bar, total)
line 2293: 
line 2294: function! s:compare_git_uri(a, b)
line 2305: 
line 2306: function! s:format_message(bullet, name, message)
line 2314: 
line 2315: function! s:with_cd(cmd, dir, ...)
line 2322: 
line 2323: function! s:system(cmd, ...)
line 2355: 
line 2356: function! s:system_chomp(...)
line 2360: 
line 2361: function! s:git_validate(spec, check_branch)
line 2424: 
line 2425: function! s:rm_rf(dir)
line 2432: 
line 2433: function! s:clean(force)
line 2503: 
line 2504: function! s:delete_op(type, ...)
line 2507: 
line 2508: function! s:delete(range, force)
line 2542: 
line 2543: function! s:upgrade()
line 2569: 
line 2570: function! s:upgrade_specs()
line 2575: 
line 2576: function! s:status()
line 2621: 
line 2622: function! s:extract_name(str, prefix, suffix)
line 2625: 
line 2626: function! s:status_load(lnum)
line 2636: 
line 2637: function! s:status_update() range
line 2645: 
line 2646: function! s:is_preview_window_open()
line 2653: 
line 2654: function! s:find_name(lnum)
line 2667: 
line 2668: function! s:preview_commit()
line 2717: 
line 2718: function! s:section(flags)
line 2721: 
line 2722: function! s:format_git_log(line)
line 2733: 
line 2734: function! s:append_ul(lnum, text)
line 2737: 
line 2738: function! s:diff()
line 2798: 
line 2799: function! s:revert()
line 2816: 
line 2817: function! s:snapshot(force, ...) abort
line 2848: 
line 2849: function! s:split_rtp()
line 2852: 
line 2853: let s:first_rtp = s:escrtp(get(s:split_rtp(), 0, ''))
calling <SNR>4_split_rtp()

line 1:   return split(&rtp, '\\\@<!,')
<SNR>4_split_rtp returning ['/home/Dante/.vim', '/usr/share/vim/v...files/after', '/home/Dante/.vim/after']

continuing in /home/Dante/.vim/autoload/plug.vim

calling <SNR>4_escrtp('/home/Dante/.vim')

line 1:   return escape(a:path, ' ,')
<SNR>4_escrtp returning '/home/Dante/.vim'

continuing in /home/Dante/.vim/autoload/plug.vim

line 2854: let s:last_rtp  = s:escrtp(get(s:split_rtp(), -1, ''))
calling <SNR>4_split_rtp()

line 1:   return split(&rtp, '\\\@<!,')
<SNR>4_split_rtp returning ['/home/Dante/.vim', '/usr/share/vim/v...files/after', '/home/Dante/.vim/after']

continuing in /home/Dante/.vim/autoload/plug.vim

calling <SNR>4_escrtp('/home/Dante/.vim/after')

line 1:   return escape(a:path, ' ,')
<SNR>4_escrtp returning '/home/Dante/.vim/after'

continuing in /home/Dante/.vim/autoload/plug.vim

line 2855: 
line 2856: if exists('g:plugs')
line 2857:   let g:plugs_order = get(g:, 'plugs_order', keys(g:plugs))
line 2858:   call s:upgrade_specs()
line 2859:   call s:define_commands()
line 2860: endif
line 2861: 
line 2862: let &cpo = s:cpo_save
line 2863: unlet s:cpo_save
finished sourcing /home/Dante/.vim/autoload/plug.vim
continuing in /home/Dante/.vimrc
calling plug#begin()

line 1:   if a:0 > 0
line 2:     let home = s:path(s:plug_fnamemodify(s:plug_expand(a:1), ':p'))
line 3:   elseif exists('g:plug_home')
line 4:     let home = s:path(g:plug_home)
line 5:   elseif has('nvim')
line 6:     let home = stdpath('data') . '/plugged'
line 7:   elseif !empty(&rtp)
line 8:     let home = s:path(split(&rtp, ',')[0]) . '/plugged'
calling <SNR>4_path('/home/Dante/.vim')

line 1:     return s:trim(a:path)
calling <SNR>4_trim('/home/Dante/.vim')

line 1:   return substitute(a:str, '[\/]\+$', '', '')
<SNR>4_trim returning '/home/Dante/.vim'

continuing in <SNR>4_path

<SNR>4_path returning '/home/Dante/.vim'

continuing in plug#begin

line 9:   else
line 10:     return s:err('Unable to determine plug home. Try calling plug#begin() with a path argument.')
line 11:   endif
line 12:   if s:plug_fnamemodify(home, ':t') ==# 'plugin' && s:plug_fnamemodify(home, ':h') ==# s:first_rtp
calling <SNR>4_plug_fnamemodify('/home/Dante/.vim/plugged', ':t')

line 1:   return s:plug_call('fnamemodify', a:fname, a:mods)
calling <SNR>4_plug_call('fnamemodify', '/home/Dante/.vim/plugged', ':t')

line 1:     return call(a:fn, a:000)
<SNR>4_plug_call returning 'plugged'

continuing in <SNR>4_plug_fnamemodify

<SNR>4_plug_fnamemodify returning 'plugged'

continuing in plug#begin

line 13:     return s:err('Invalid plug home. '.home.' is a standard Vim runtime path and is not allowed.')
line 14:   endif
line 15: 
line 16:   let g:plug_home = home
line 17:   let g:plugs = {}
line 18:   let g:plugs_order = []
line 19:   let s:triggers = {}
line 20: 
line 21:   call s:define_commands()
calling <SNR>4_define_commands()

line 1:   command! -nargs=+ -bar Plug call plug#(<args>)
line 2:   if !executable('git')
line 3:     return s:err('`git` executable not found. Most commands will not be available. To suppress this message, prepend `silent!` to `call plug#begin(...)`.')
line 4:   endif
line 5:   if has('win32') && &shellslash && (&shell =~# 'cmd\(\.exe\)\?$' || s:is_powershell(&shell))
line 8:     return s:err('vim-plug does not support shell, ' . &shell . ', when shellslash is set.')
line 9:   endif
line 10:   if !has('nvim') && (has('win32') || has('win32unix')) && !has('multi_byte')
line 13:     return s:err('Vim needs +multi_byte feature on Windows to run shell commands. Enable +iconv for best results.')
line 14:   endif
line 15:   command! -nargs=* -bar -bang -complete=customlist,s:names PlugInstall call s:install(<bang>0, [<f-args>])
line 16:   command! -nargs=* -bar -bang -complete=customlist,s:names PlugUpdate  call s:update(<bang>0, [<f-args>])
line 17:   command! -nargs=0 -bar -bang PlugClean call s:clean(<bang>0)
line 18:   command! -nargs=0 -bar PlugUpgrade if s:upgrade() | execute 'source' s:esc(s:me) | endif
line 19:   command! -nargs=0 -bar PlugStatus  call s:status()
line 20:   command! -nargs=0 -bar PlugDiff    call s:diff()
line 21:   command! -nargs=? -bar -bang -complete=file PlugSnapshot call s:snapshot(<bang>0, <f-args>)
<SNR>4_define_commands returning #0

continuing in plug#begin

line 22:   return 1
plug#begin returning #1

continuing in /home/Dante/.vimrc

line 13: 
line 14: "Colorscheme plugins
line 15: "Plug 'sainnhe/everforest'
line 16: "Plug 'andreasvc/vim-256noir'
line 17: "Plug fcpg/vim-fahrenheit'
line 18: "Plug 'catppuccin/vim', {'as': 'catppuccin'}
line 19: "Plug 'Rigellute/shades-of-purple.vim'
line 20: "If you can't tell onedark is my favorite
line 21: "I'm currenly using the onehalfdark, but I was using onedark for a long time
line 22: Plug 'joshdick/onedark.vim' 
line 22: call plug#('joshdick/onedark.vim')
calling plug#('joshdick/onedark.vim')

line 1:   if a:0 > 1
line 2:     return s:err('Invalid number of arguments (1..2)')
line 3:   endif
line 4: 
line 5:   try
line 6:     let repo = s:trim(a:repo)
calling <SNR>4_trim('joshdick/onedark.vim')

line 1:   return substitute(a:str, '[\/]\+$', '', '')
<SNR>4_trim returning 'joshdick/onedark.vim'

continuing in plug#

line 7:     let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec
line 8:     let name = get(opts, 'as', s:plug_fnamemodify(repo, ':t:s?\.git$??'))
calling <SNR>4_plug_fnamemodify('joshdick/onedark.vim', ':t:s?\.git$??')

line 1:   return s:plug_call('fnamemodify', a:fname, a:mods)
calling <SNR>4_plug_call('fnamemodify', 'joshdick/onedark.vim', ':t:s?\.git$??')

line 1:     return call(a:fn, a:000)
<SNR>4_plug_call returning 'onedark.vim'

continuing in <SNR>4_plug_fnamemodify

<SNR>4_plug_fnamemodify returning 'onedark.vim'

continuing in plug#

line 9:     let spec = extend(s:infer_properties(name, repo), opts)
calling <SNR>4_infer_properties('onedark.vim', 'joshdick/onedark.vim')

line 1:   let repo = a:repo
line 2:   if s:is_local_plug(repo)
calling <SNR>4_is_local_plug('joshdick/onedark.vim')

line 1:     return a:repo[0] =~ '[/$~]'
<SNR>4_is_local_plug returning #0

continuing in <SNR>4_infer_properties

line 3:     return { 'dir': s:dirpath(s:plug_expand(repo)) }
line 4:   else
line 5:     if repo =~ ':'
line 6:       let uri = repo
line 7:     else
line 8:       if repo !~ '/'
line 9:         throw printf('Invalid argument: %s (implicit `vim-scripts'' expansion is deprecated)', repo)
line 10:       endif
line 11:       let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')
line 12:       let uri = printf(fmt, repo)
line 13:     endif
line 14:     return { 'dir': s:dirpath(g:plug_home.'/'.a:name), 'uri': uri }
calling <SNR>4_dirpath('/home/Dante/.vim/plugged/onedark.vim')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')
<SNR>4_dirpath returning '/home/Dante/.vim/plugged/onedark.vim/'

continuing in <SNR>4_infer_properties

<SNR>4_infer_properties returning {'uri': 'https://git::@github.com/josh.../home/Dante/.vim/plugged/onedark.vim/'}

continuing in plug#

line 10:     if !has_key(g:plugs, name)
line 11:       call add(g:plugs_order, name)
line 12:     endif
line 13:     let g:plugs[name] = spec
line 14:     let s:loaded[name] = get(s:loaded, name, 0)
line 15:   catch
line 16:     return s:err(repo . ' ' . v:exception)
line 17:   endtry
plug# returning #0

continuing in /home/Dante/.vimrc

line 23: Plug 'sonph/onehalf', {'rtp': 'vim'}
line 23: call plug#('sonph/onehalf', {'rtp': 'vim'})
calling plug#('sonph/onehalf', {'rtp': 'vim'})

line 1:   if a:0 > 1
line 2:     return s:err('Invalid number of arguments (1..2)')
line 3:   endif
line 4: 
line 5:   try
line 6:     let repo = s:trim(a:repo)
calling <SNR>4_trim('sonph/onehalf')

line 1:   return substitute(a:str, '[\/]\+$', '', '')
<SNR>4_trim returning 'sonph/onehalf'

continuing in plug#

line 7:     let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec
calling <SNR>4_parse_options({'rtp': 'vim'})

line 1:   let opts = copy(s:base_spec)
line 2:   let type = type(a:arg)
line 3:   let opt_errfmt = 'Invalid argument for "%s" option of :Plug (expected: %s)'
line 4:   if type == s:TYPE.string
line 5:     if empty(a:arg)
line 6:       throw printf(opt_errfmt, 'tag', 'string')
line 7:     endif
line 8:     let opts.tag = a:arg
line 9:   elseif type == s:TYPE.dict
line 10:     for opt in ['branch', 'tag', 'commit', 'rtp', 'dir', 'as']
line 11:       if has_key(a:arg, opt) && (type(a:arg[opt]) != s:TYPE.string || empty(a:arg[opt]))
line 13:         throw printf(opt_errfmt, opt, 'string')
line 14:       endif
line 15:     endfor
line 10:     for opt in ['branch', 'tag', 'commit', 'rtp', 'dir', 'as']
line 11:       if has_key(a:arg, opt) && (type(a:arg[opt]) != s:TYPE.string || empty(a:arg[opt]))
line 13:         throw printf(opt_errfmt, opt, 'string')
line 14:       endif
line 15:     endfor
line 10:     for opt in ['branch', 'tag', 'commit', 'rtp', 'dir', 'as']
line 11:       if has_key(a:arg, opt) && (type(a:arg[opt]) != s:TYPE.string || empty(a:arg[opt]))
line 13:         throw printf(opt_errfmt, opt, 'string')
line 14:       endif
line 15:     endfor
line 10:     for opt in ['branch', 'tag', 'commit', 'rtp', 'dir', 'as']
line 11:       if has_key(a:arg, opt) && (type(a:arg[opt]) != s:TYPE.string || empty(a:arg[opt]))
line 13:         throw printf(opt_errfmt, opt, 'string')
line 14:       endif
line 15:     endfor
line 10:     for opt in ['branch', 'tag', 'commit', 'rtp', 'dir', 'as']
line 11:       if has_key(a:arg, opt) && (type(a:arg[opt]) != s:TYPE.string || empty(a:arg[opt]))
line 13:         throw printf(opt_errfmt, opt, 'string')
line 14:       endif
line 15:     endfor
line 10:     for opt in ['branch', 'tag', 'commit', 'rtp', 'dir', 'as']
line 11:       if has_key(a:arg, opt) && (type(a:arg[opt]) != s:TYPE.string || empty(a:arg[opt]))
line 13:         throw printf(opt_errfmt, opt, 'string')
line 14:       endif
line 15:     endfor
line 10:     for opt in ['branch', 'tag', 'commit', 'rtp', 'dir', 'as']
line 11:       if has_key(a:arg, opt) && (type(a:arg[opt]) != s:TYPE.string || empty(a:arg[opt]))
line 13:         throw printf(opt_errfmt, opt, 'string')
line 14:       endif
line 15:     endfor
line 16:     for opt in ['on', 'for']
line 17:       if has_key(a:arg, opt) && type(a:arg[opt]) != s:TYPE.list && (type(a:arg[opt]) != s:TYPE.string || empty(a:arg[opt]))
line 20:         throw printf(opt_errfmt, opt, 'string or list')
line 21:       endif
line 22:     endfor
line 16:     for opt in ['on', 'for']
line 17:       if has_key(a:arg, opt) && type(a:arg[opt]) != s:TYPE.list && (type(a:arg[opt]) != s:TYPE.string || empty(a:arg[opt]))
line 20:         throw printf(opt_errfmt, opt, 'string or list')
line 21:       endif
line 22:     endfor
line 16:     for opt in ['on', 'for']
line 17:       if has_key(a:arg, opt) && type(a:arg[opt]) != s:TYPE.list && (type(a:arg[opt]) != s:TYPE.string || empty(a:arg[opt]))
line 20:         throw printf(opt_errfmt, opt, 'string or list')
line 21:       endif
line 22:     endfor
line 23:     if has_key(a:arg, 'do') && type(a:arg.do) != s:TYPE.funcref && (type(a:arg.do) != s:TYPE.string || empty(a:arg.do))
line 26:         throw printf(opt_errfmt, 'do', 'string or funcref')
line 27:     endif
line 28:     call extend(opts, a:arg)
line 29:     if has_key(opts, 'dir')
line 30:       let opts.dir = s:dirpath(s:plug_expand(opts.dir))
line 31:     endif
line 32:   else
line 33:     throw 'Invalid argument type (expected: string or dictionary)'
line 34:   endif
line 35:   return opts
<SNR>4_parse_options returning {'frozen': 0, 'rtp': 'vim', 'branch': ''}

continuing in plug#

line 8:     let name = get(opts, 'as', s:plug_fnamemodify(repo, ':t:s?\.git$??'))
calling <SNR>4_plug_fnamemodify('sonph/onehalf', ':t:s?\.git$??')

line 1:   return s:plug_call('fnamemodify', a:fname, a:mods)
calling <SNR>4_plug_call('fnamemodify', 'sonph/onehalf', ':t:s?\.git$??')

line 1:     return call(a:fn, a:000)
<SNR>4_plug_call returning 'onehalf'

continuing in <SNR>4_plug_fnamemodify

<SNR>4_plug_fnamemodify returning 'onehalf'

continuing in plug#

line 9:     let spec = extend(s:infer_properties(name, repo), opts)
calling <SNR>4_infer_properties('onehalf', 'sonph/onehalf')

line 1:   let repo = a:repo
line 2:   if s:is_local_plug(repo)
calling <SNR>4_is_local_plug('sonph/onehalf')

line 1:     return a:repo[0] =~ '[/$~]'
<SNR>4_is_local_plug returning #0

continuing in <SNR>4_infer_properties

line 3:     return { 'dir': s:dirpath(s:plug_expand(repo)) }
line 4:   else
line 5:     if repo =~ ':'
line 6:       let uri = repo
line 7:     else
line 8:       if repo !~ '/'
line 9:         throw printf('Invalid argument: %s (implicit `vim-scripts'' expansion is deprecated)', repo)
line 10:       endif
line 11:       let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')
line 12:       let uri = printf(fmt, repo)
line 13:     endif
line 14:     return { 'dir': s:dirpath(g:plug_home.'/'.a:name), 'uri': uri }
calling <SNR>4_dirpath('/home/Dante/.vim/plugged/onehalf')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')
<SNR>4_dirpath returning '/home/Dante/.vim/plugged/onehalf/'

continuing in <SNR>4_infer_properties

<SNR>4_infer_properties returning {'uri': 'https://git::@github.com/sonp...': '/home/Dante/.vim/plugged/onehalf/'}

continuing in plug#

line 10:     if !has_key(g:plugs, name)
line 11:       call add(g:plugs_order, name)
line 12:     endif
line 13:     let g:plugs[name] = spec
line 14:     let s:loaded[name] = get(s:loaded, name, 0)
line 15:   catch
line 16:     return s:err(repo . ' ' . v:exception)
line 17:   endtry
plug# returning #0

continuing in /home/Dante/.vimrc

line 24: 
line 25: 
line 26: Plug 'morhetz/gruvbox'
line 26: call plug#('morhetz/gruvbox')
calling plug#('morhetz/gruvbox')

line 1:   if a:0 > 1
line 2:     return s:err('Invalid number of arguments (1..2)')
line 3:   endif
line 4: 
line 5:   try
line 6:     let repo = s:trim(a:repo)
calling <SNR>4_trim('morhetz/gruvbox')

line 1:   return substitute(a:str, '[\/]\+$', '', '')
<SNR>4_trim returning 'morhetz/gruvbox'

continuing in plug#

line 7:     let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec
line 8:     let name = get(opts, 'as', s:plug_fnamemodify(repo, ':t:s?\.git$??'))
calling <SNR>4_plug_fnamemodify('morhetz/gruvbox', ':t:s?\.git$??')

line 1:   return s:plug_call('fnamemodify', a:fname, a:mods)
calling <SNR>4_plug_call('fnamemodify', 'morhetz/gruvbox', ':t:s?\.git$??')

line 1:     return call(a:fn, a:000)
<SNR>4_plug_call returning 'gruvbox'

continuing in <SNR>4_plug_fnamemodify

<SNR>4_plug_fnamemodify returning 'gruvbox'

continuing in plug#

line 9:     let spec = extend(s:infer_properties(name, repo), opts)
calling <SNR>4_infer_properties('gruvbox', 'morhetz/gruvbox')

line 1:   let repo = a:repo
line 2:   if s:is_local_plug(repo)
calling <SNR>4_is_local_plug('morhetz/gruvbox')

line 1:     return a:repo[0] =~ '[/$~]'
<SNR>4_is_local_plug returning #0

continuing in <SNR>4_infer_properties

line 3:     return { 'dir': s:dirpath(s:plug_expand(repo)) }
line 4:   else
line 5:     if repo =~ ':'
line 6:       let uri = repo
line 7:     else
line 8:       if repo !~ '/'
line 9:         throw printf('Invalid argument: %s (implicit `vim-scripts'' expansion is deprecated)', repo)
line 10:       endif
line 11:       let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')
line 12:       let uri = printf(fmt, repo)
line 13:     endif
line 14:     return { 'dir': s:dirpath(g:plug_home.'/'.a:name), 'uri': uri }
calling <SNR>4_dirpath('/home/Dante/.vim/plugged/gruvbox')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')
<SNR>4_dirpath returning '/home/Dante/.vim/plugged/gruvbox/'

continuing in <SNR>4_infer_properties

<SNR>4_infer_properties returning {'uri': 'https://git::@github.com/morh...': '/home/Dante/.vim/plugged/gruvbox/'}

continuing in plug#

line 10:     if !has_key(g:plugs, name)
line 11:       call add(g:plugs_order, name)
line 12:     endif
line 13:     let g:plugs[name] = spec
line 14:     let s:loaded[name] = get(s:loaded, name, 0)
line 15:   catch
line 16:     return s:err(repo . ' ' . v:exception)
line 17:   endtry
plug# returning #0

continuing in /home/Dante/.vimrc

line 27: 
line 28: 
line 29: "Oh yeah
line 30: "This can be further customized by coc.nvim
line 31: Plug 'itchyny/lightline.vim'
line 31: call plug#('itchyny/lightline.vim')
calling plug#('itchyny/lightline.vim')

line 1:   if a:0 > 1
line 2:     return s:err('Invalid number of arguments (1..2)')
line 3:   endif
line 4: 
line 5:   try
line 6:     let repo = s:trim(a:repo)
calling <SNR>4_trim('itchyny/lightline.vim')

line 1:   return substitute(a:str, '[\/]\+$', '', '')
<SNR>4_trim returning 'itchyny/lightline.vim'

continuing in plug#

line 7:     let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec
line 8:     let name = get(opts, 'as', s:plug_fnamemodify(repo, ':t:s?\.git$??'))
calling <SNR>4_plug_fnamemodify('itchyny/lightline.vim', ':t:s?\.git$??')

line 1:   return s:plug_call('fnamemodify', a:fname, a:mods)
calling <SNR>4_plug_call('fnamemodify', 'itchyny/lightline.vim', ':t:s?\.git$??')

line 1:     return call(a:fn, a:000)
<SNR>4_plug_call returning 'lightline.vim'

continuing in <SNR>4_plug_fnamemodify

<SNR>4_plug_fnamemodify returning 'lightline.vim'

continuing in plug#

line 9:     let spec = extend(s:infer_properties(name, repo), opts)
calling <SNR>4_infer_properties('lightline.vim', 'itchyny/lightline.vim')

line 1:   let repo = a:repo
line 2:   if s:is_local_plug(repo)
calling <SNR>4_is_local_plug('itchyny/lightline.vim')

line 1:     return a:repo[0] =~ '[/$~]'
<SNR>4_is_local_plug returning #0

continuing in <SNR>4_infer_properties

line 3:     return { 'dir': s:dirpath(s:plug_expand(repo)) }
line 4:   else
line 5:     if repo =~ ':'
line 6:       let uri = repo
line 7:     else
line 8:       if repo !~ '/'
line 9:         throw printf('Invalid argument: %s (implicit `vim-scripts'' expansion is deprecated)', repo)
line 10:       endif
line 11:       let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')
line 12:       let uri = printf(fmt, repo)
line 13:     endif
line 14:     return { 'dir': s:dirpath(g:plug_home.'/'.a:name), 'uri': uri }
calling <SNR>4_dirpath('/home/Dante/.vim/plugged/lightline.vim')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')
<SNR>4_dirpath returning '/home/Dante/.vim/plugged/lightline.vim/'

continuing in <SNR>4_infer_properties

<SNR>4_infer_properties returning {'uri': 'https://git::@github.com/itch...ome/Dante/.vim/plugged/lightline.vim/'}

continuing in plug#

line 10:     if !has_key(g:plugs, name)
line 11:       call add(g:plugs_order, name)
line 12:     endif
line 13:     let g:plugs[name] = spec
line 14:     let s:loaded[name] = get(s:loaded, name, 0)
line 15:   catch
line 16:     return s:err(repo . ' ' . v:exception)
line 17:   endtry
plug# returning #0

continuing in /home/Dante/.vimrc

line 32: 
line 33: "I'm sure it does something nice
line 34: Plug 'christoomey/vim-tmux-navigator'
line 34: call plug#('christoomey/vim-tmux-navigator')
calling plug#('christoomey/vim-tmux-navigator')

line 1:   if a:0 > 1
line 2:     return s:err('Invalid number of arguments (1..2)')
line 3:   endif
line 4: 
line 5:   try
line 6:     let repo = s:trim(a:repo)
calling <SNR>4_trim('christoomey/vim-tmux-navigator')

line 1:   return substitute(a:str, '[\/]\+$', '', '')
<SNR>4_trim returning 'christoomey/vim-tmux-navigator'

continuing in plug#

line 7:     let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec
line 8:     let name = get(opts, 'as', s:plug_fnamemodify(repo, ':t:s?\.git$??'))
calling <SNR>4_plug_fnamemodify('christoomey/vim-tmux-navigator', ':t:s?\.git$??')

line 1:   return s:plug_call('fnamemodify', a:fname, a:mods)
calling <SNR>4_plug_call('fnamemodify', 'christoomey/vim-tmux-navigator', ':t:s?\.git$??')

line 1:     return call(a:fn, a:000)
<SNR>4_plug_call returning 'vim-tmux-navigator'

continuing in <SNR>4_plug_fnamemodify

<SNR>4_plug_fnamemodify returning 'vim-tmux-navigator'

continuing in plug#

line 9:     let spec = extend(s:infer_properties(name, repo), opts)
calling <SNR>4_infer_properties('vim-tmux-navigator', 'christoomey/vim-tmux-navigator')

line 1:   let repo = a:repo
line 2:   if s:is_local_plug(repo)
calling <SNR>4_is_local_plug('christoomey/vim-tmux-navigator')

line 1:     return a:repo[0] =~ '[/$~]'
<SNR>4_is_local_plug returning #0

continuing in <SNR>4_infer_properties

line 3:     return { 'dir': s:dirpath(s:plug_expand(repo)) }
line 4:   else
line 5:     if repo =~ ':'
line 6:       let uri = repo
line 7:     else
line 8:       if repo !~ '/'
line 9:         throw printf('Invalid argument: %s (implicit `vim-scripts'' expansion is deprecated)', repo)
line 10:       endif
line 11:       let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')
line 12:       let uri = printf(fmt, repo)
line 13:     endif
line 14:     return { 'dir': s:dirpath(g:plug_home.'/'.a:name), 'uri': uri }
calling <SNR>4_dirpath('/home/Dante/.vim/plugged/vim-tmux-navigator')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')
<SNR>4_dirpath returning '/home/Dante/.vim/plugged/vim-tmux-navigator/'

continuing in <SNR>4_infer_properties

<SNR>4_infer_properties returning {'uri': 'https://git::@github.com/chri...ante/.vim/plugged/vim-tmux-navigator/'}

continuing in plug#

line 10:     if !has_key(g:plugs, name)
line 11:       call add(g:plugs_order, name)
line 12:     endif
line 13:     let g:plugs[name] = spec
line 14:     let s:loaded[name] = get(s:loaded, name, 0)
line 15:   catch
line 16:     return s:err(repo . ' ' . v:exception)
line 17:   endtry
plug# returning #0

continuing in /home/Dante/.vimrc

line 35: 
line 36: "Very useful
line 37: Plug 'lervag/vimtex'
line 37: call plug#('lervag/vimtex')
calling plug#('lervag/vimtex')

line 1:   if a:0 > 1
line 2:     return s:err('Invalid number of arguments (1..2)')
line 3:   endif
line 4: 
line 5:   try
line 6:     let repo = s:trim(a:repo)
calling <SNR>4_trim('lervag/vimtex')

line 1:   return substitute(a:str, '[\/]\+$', '', '')
<SNR>4_trim returning 'lervag/vimtex'

continuing in plug#

line 7:     let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec
line 8:     let name = get(opts, 'as', s:plug_fnamemodify(repo, ':t:s?\.git$??'))
calling <SNR>4_plug_fnamemodify('lervag/vimtex', ':t:s?\.git$??')

line 1:   return s:plug_call('fnamemodify', a:fname, a:mods)
calling <SNR>4_plug_call('fnamemodify', 'lervag/vimtex', ':t:s?\.git$??')

line 1:     return call(a:fn, a:000)
<SNR>4_plug_call returning 'vimtex'

continuing in <SNR>4_plug_fnamemodify

<SNR>4_plug_fnamemodify returning 'vimtex'

continuing in plug#

line 9:     let spec = extend(s:infer_properties(name, repo), opts)
calling <SNR>4_infer_properties('vimtex', 'lervag/vimtex')

line 1:   let repo = a:repo
line 2:   if s:is_local_plug(repo)
calling <SNR>4_is_local_plug('lervag/vimtex')

line 1:     return a:repo[0] =~ '[/$~]'
<SNR>4_is_local_plug returning #0

continuing in <SNR>4_infer_properties

line 3:     return { 'dir': s:dirpath(s:plug_expand(repo)) }
line 4:   else
line 5:     if repo =~ ':'
line 6:       let uri = repo
line 7:     else
line 8:       if repo !~ '/'
line 9:         throw printf('Invalid argument: %s (implicit `vim-scripts'' expansion is deprecated)', repo)
line 10:       endif
line 11:       let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')
line 12:       let uri = printf(fmt, repo)
line 13:     endif
line 14:     return { 'dir': s:dirpath(g:plug_home.'/'.a:name), 'uri': uri }
calling <SNR>4_dirpath('/home/Dante/.vim/plugged/vimtex')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')
<SNR>4_dirpath returning '/home/Dante/.vim/plugged/vimtex/'

continuing in <SNR>4_infer_properties

<SNR>4_infer_properties returning {'uri': 'https://git::@github.com/lerv...r': '/home/Dante/.vim/plugged/vimtex/'}

continuing in plug#

line 10:     if !has_key(g:plugs, name)
line 11:       call add(g:plugs_order, name)
line 12:     endif
line 13:     let g:plugs[name] = spec
line 14:     let s:loaded[name] = get(s:loaded, name, 0)
line 15:   catch
line 16:     return s:err(repo . ' ' . v:exception)
line 17:   endtry
plug# returning #0

continuing in /home/Dante/.vimrc

line 38: 
line 39: "Eh I barely use this, fzf is much better
line 40: Plug 'preservim/nerdtree'
line 40: call plug#('preservim/nerdtree')
calling plug#('preservim/nerdtree')

line 1:   if a:0 > 1
line 2:     return s:err('Invalid number of arguments (1..2)')
line 3:   endif
line 4: 
line 5:   try
line 6:     let repo = s:trim(a:repo)
calling <SNR>4_trim('preservim/nerdtree')

line 1:   return substitute(a:str, '[\/]\+$', '', '')
<SNR>4_trim returning 'preservim/nerdtree'

continuing in plug#

line 7:     let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec
line 8:     let name = get(opts, 'as', s:plug_fnamemodify(repo, ':t:s?\.git$??'))
calling <SNR>4_plug_fnamemodify('preservim/nerdtree', ':t:s?\.git$??')

line 1:   return s:plug_call('fnamemodify', a:fname, a:mods)
calling <SNR>4_plug_call('fnamemodify', 'preservim/nerdtree', ':t:s?\.git$??')

line 1:     return call(a:fn, a:000)
<SNR>4_plug_call returning 'nerdtree'

continuing in <SNR>4_plug_fnamemodify

<SNR>4_plug_fnamemodify returning 'nerdtree'

continuing in plug#

line 9:     let spec = extend(s:infer_properties(name, repo), opts)
calling <SNR>4_infer_properties('nerdtree', 'preservim/nerdtree')

line 1:   let repo = a:repo
line 2:   if s:is_local_plug(repo)
calling <SNR>4_is_local_plug('preservim/nerdtree')

line 1:     return a:repo[0] =~ '[/$~]'
<SNR>4_is_local_plug returning #0

continuing in <SNR>4_infer_properties

line 3:     return { 'dir': s:dirpath(s:plug_expand(repo)) }
line 4:   else
line 5:     if repo =~ ':'
line 6:       let uri = repo
line 7:     else
line 8:       if repo !~ '/'
line 9:         throw printf('Invalid argument: %s (implicit `vim-scripts'' expansion is deprecated)', repo)
line 10:       endif
line 11:       let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')
line 12:       let uri = printf(fmt, repo)
line 13:     endif
line 14:     return { 'dir': s:dirpath(g:plug_home.'/'.a:name), 'uri': uri }
calling <SNR>4_dirpath('/home/Dante/.vim/plugged/nerdtree')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')
<SNR>4_dirpath returning '/home/Dante/.vim/plugged/nerdtree/'

continuing in <SNR>4_infer_properties

<SNR>4_infer_properties returning {'uri': 'https://git::@github.com/pres...: '/home/Dante/.vim/plugged/nerdtree/'}

continuing in plug#

line 10:     if !has_key(g:plugs, name)
line 11:       call add(g:plugs_order, name)
line 12:     endif
line 13:     let g:plugs[name] = spec
line 14:     let s:loaded[name] = get(s:loaded, name, 0)
line 15:   catch
line 16:     return s:err(repo . ' ' . v:exception)
line 17:   endtry
plug# returning #0

continuing in /home/Dante/.vimrc

line 41: 
line 42: "I have configurated this repo a lot! So much so that I made my own custom
line 43: "command laying in the fzf.vim/plugin/fzf.vim file
line 44: "The command goes in line 57, after the function :Files is defined, this
line 45: "function calls ripgrep in order to supply the fzf find
line 46: "\'command!      -bang -nargs=* SFiles                           call fzf#run(fzf#wrap({"source": "rg ~ --files --hidden -g \"!*.o\" -g \"!*.mod\" -g \"!*.pdf\" ".fzf#shellescape(<q-args>), "options": "--multi -i --preview \"bat --color=always --style=numbers --line-range=:500 {}\""}), fzf#vim#with_preview(), <bang>0)',
line 47: "This function is used by one of my main vim binds, <leader>f, calls a fuzzy
line 48: "find and will open a new buffer based off of the result
line 49: "If you delete these two lines, I stop breathing
line 50: Plug 'junegunn/fzf', { 'do': { -> fzf#install() } }
line 50: call plug#('junegunn/fzf', { 'do': { -> fzf#install() } })
calling plug#('junegunn/fzf', {'do': function('<lambda>1')})

line 1:   if a:0 > 1
line 2:     return s:err('Invalid number of arguments (1..2)')
line 3:   endif
line 4: 
line 5:   try
line 6:     let repo = s:trim(a:repo)
calling <SNR>4_trim('junegunn/fzf')

line 1:   return substitute(a:str, '[\/]\+$', '', '')
<SNR>4_trim returning 'junegunn/fzf'

continuing in plug#

line 7:     let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec
calling <SNR>4_parse_options({'do': function('<lambda>1')})

line 1:   let opts = copy(s:base_spec)
line 2:   let type = type(a:arg)
line 3:   let opt_errfmt = 'Invalid argument for "%s" option of :Plug (expected: %s)'
line 4:   if type == s:TYPE.string
line 5:     if empty(a:arg)
line 6:       throw printf(opt_errfmt, 'tag', 'string')
line 7:     endif
line 8:     let opts.tag = a:arg
line 9:   elseif type == s:TYPE.dict
line 10:     for opt in ['branch', 'tag', 'commit', 'rtp', 'dir', 'as']
line 11:       if has_key(a:arg, opt) && (type(a:arg[opt]) != s:TYPE.string || empty(a:arg[opt]))
line 13:         throw printf(opt_errfmt, opt, 'string')
line 14:       endif
line 15:     endfor
line 10:     for opt in ['branch', 'tag', 'commit', 'rtp', 'dir', 'as']
line 11:       if has_key(a:arg, opt) && (type(a:arg[opt]) != s:TYPE.string || empty(a:arg[opt]))
line 13:         throw printf(opt_errfmt, opt, 'string')
line 14:       endif
line 15:     endfor
line 10:     for opt in ['branch', 'tag', 'commit', 'rtp', 'dir', 'as']
line 11:       if has_key(a:arg, opt) && (type(a:arg[opt]) != s:TYPE.string || empty(a:arg[opt]))
line 13:         throw printf(opt_errfmt, opt, 'string')
line 14:       endif
line 15:     endfor
line 10:     for opt in ['branch', 'tag', 'commit', 'rtp', 'dir', 'as']
line 11:       if has_key(a:arg, opt) && (type(a:arg[opt]) != s:TYPE.string || empty(a:arg[opt]))
line 13:         throw printf(opt_errfmt, opt, 'string')
line 14:       endif
line 15:     endfor
line 10:     for opt in ['branch', 'tag', 'commit', 'rtp', 'dir', 'as']
line 11:       if has_key(a:arg, opt) && (type(a:arg[opt]) != s:TYPE.string || empty(a:arg[opt]))
line 13:         throw printf(opt_errfmt, opt, 'string')
line 14:       endif
line 15:     endfor
line 10:     for opt in ['branch', 'tag', 'commit', 'rtp', 'dir', 'as']
line 11:       if has_key(a:arg, opt) && (type(a:arg[opt]) != s:TYPE.string || empty(a:arg[opt]))
line 13:         throw printf(opt_errfmt, opt, 'string')
line 14:       endif
line 15:     endfor
line 10:     for opt in ['branch', 'tag', 'commit', 'rtp', 'dir', 'as']
line 11:       if has_key(a:arg, opt) && (type(a:arg[opt]) != s:TYPE.string || empty(a:arg[opt]))
line 13:         throw printf(opt_errfmt, opt, 'string')
line 14:       endif
line 15:     endfor
line 16:     for opt in ['on', 'for']
line 17:       if has_key(a:arg, opt) && type(a:arg[opt]) != s:TYPE.list && (type(a:arg[opt]) != s:TYPE.string || empty(a:arg[opt]))
line 20:         throw printf(opt_errfmt, opt, 'string or list')
line 21:       endif
line 22:     endfor
line 16:     for opt in ['on', 'for']
line 17:       if has_key(a:arg, opt) && type(a:arg[opt]) != s:TYPE.list && (type(a:arg[opt]) != s:TYPE.string || empty(a:arg[opt]))
line 20:         throw printf(opt_errfmt, opt, 'string or list')
line 21:       endif
line 22:     endfor
line 16:     for opt in ['on', 'for']
line 17:       if has_key(a:arg, opt) && type(a:arg[opt]) != s:TYPE.list && (type(a:arg[opt]) != s:TYPE.string || empty(a:arg[opt]))
line 20:         throw printf(opt_errfmt, opt, 'string or list')
line 21:       endif
line 22:     endfor
line 23:     if has_key(a:arg, 'do') && type(a:arg.do) != s:TYPE.funcref && (type(a:arg.do) != s:TYPE.string || empty(a:arg.do))
line 26:         throw printf(opt_errfmt, 'do', 'string or funcref')
line 27:     endif
line 28:     call extend(opts, a:arg)
line 29:     if has_key(opts, 'dir')
line 30:       let opts.dir = s:dirpath(s:plug_expand(opts.dir))
line 31:     endif
line 32:   else
line 33:     throw 'Invalid argument type (expected: string or dictionary)'
line 34:   endif
line 35:   return opts
<SNR>4_parse_options returning {'do': function('<lambda>1'), 'frozen': 0, 'branch': ''}

continuing in plug#

line 8:     let name = get(opts, 'as', s:plug_fnamemodify(repo, ':t:s?\.git$??'))
calling <SNR>4_plug_fnamemodify('junegunn/fzf', ':t:s?\.git$??')

line 1:   return s:plug_call('fnamemodify', a:fname, a:mods)
calling <SNR>4_plug_call('fnamemodify', 'junegunn/fzf', ':t:s?\.git$??')

line 1:     return call(a:fn, a:000)
<SNR>4_plug_call returning 'fzf'

continuing in <SNR>4_plug_fnamemodify

<SNR>4_plug_fnamemodify returning 'fzf'

continuing in plug#

line 9:     let spec = extend(s:infer_properties(name, repo), opts)
calling <SNR>4_infer_properties('fzf', 'junegunn/fzf')

line 1:   let repo = a:repo
line 2:   if s:is_local_plug(repo)
calling <SNR>4_is_local_plug('junegunn/fzf')

line 1:     return a:repo[0] =~ '[/$~]'
<SNR>4_is_local_plug returning #0

continuing in <SNR>4_infer_properties

line 3:     return { 'dir': s:dirpath(s:plug_expand(repo)) }
line 4:   else
line 5:     if repo =~ ':'
line 6:       let uri = repo
line 7:     else
line 8:       if repo !~ '/'
line 9:         throw printf('Invalid argument: %s (implicit `vim-scripts'' expansion is deprecated)', repo)
line 10:       endif
line 11:       let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')
line 12:       let uri = printf(fmt, repo)
line 13:     endif
line 14:     return { 'dir': s:dirpath(g:plug_home.'/'.a:name), 'uri': uri }
calling <SNR>4_dirpath('/home/Dante/.vim/plugged/fzf')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')
<SNR>4_dirpath returning '/home/Dante/.vim/plugged/fzf/'

continuing in <SNR>4_infer_properties

<SNR>4_infer_properties returning {'uri': 'https://git::@github.com/june...'dir': '/home/Dante/.vim/plugged/fzf/'}

continuing in plug#

line 10:     if !has_key(g:plugs, name)
line 11:       call add(g:plugs_order, name)
line 12:     endif
line 13:     let g:plugs[name] = spec
line 14:     let s:loaded[name] = get(s:loaded, name, 0)
line 15:   catch
line 16:     return s:err(repo . ' ' . v:exception)
line 17:   endtry
plug# returning #0

continuing in /home/Dante/.vimrc

line 51: Plug 'junegunn/fzf.vim'
line 51: call plug#('junegunn/fzf.vim')
calling plug#('junegunn/fzf.vim')

line 1:   if a:0 > 1
line 2:     return s:err('Invalid number of arguments (1..2)')
line 3:   endif
line 4: 
line 5:   try
line 6:     let repo = s:trim(a:repo)
calling <SNR>4_trim('junegunn/fzf.vim')

line 1:   return substitute(a:str, '[\/]\+$', '', '')
<SNR>4_trim returning 'junegunn/fzf.vim'

continuing in plug#

line 7:     let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec
line 8:     let name = get(opts, 'as', s:plug_fnamemodify(repo, ':t:s?\.git$??'))
calling <SNR>4_plug_fnamemodify('junegunn/fzf.vim', ':t:s?\.git$??')

line 1:   return s:plug_call('fnamemodify', a:fname, a:mods)
calling <SNR>4_plug_call('fnamemodify', 'junegunn/fzf.vim', ':t:s?\.git$??')

line 1:     return call(a:fn, a:000)
<SNR>4_plug_call returning 'fzf.vim'

continuing in <SNR>4_plug_fnamemodify

<SNR>4_plug_fnamemodify returning 'fzf.vim'

continuing in plug#

line 9:     let spec = extend(s:infer_properties(name, repo), opts)
calling <SNR>4_infer_properties('fzf.vim', 'junegunn/fzf.vim')

line 1:   let repo = a:repo
line 2:   if s:is_local_plug(repo)
calling <SNR>4_is_local_plug('junegunn/fzf.vim')

line 1:     return a:repo[0] =~ '[/$~]'
<SNR>4_is_local_plug returning #0

continuing in <SNR>4_infer_properties

line 3:     return { 'dir': s:dirpath(s:plug_expand(repo)) }
line 4:   else
line 5:     if repo =~ ':'
line 6:       let uri = repo
line 7:     else
line 8:       if repo !~ '/'
line 9:         throw printf('Invalid argument: %s (implicit `vim-scripts'' expansion is deprecated)', repo)
line 10:       endif
line 11:       let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')
line 12:       let uri = printf(fmt, repo)
line 13:     endif
line 14:     return { 'dir': s:dirpath(g:plug_home.'/'.a:name), 'uri': uri }
calling <SNR>4_dirpath('/home/Dante/.vim/plugged/fzf.vim')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')
<SNR>4_dirpath returning '/home/Dante/.vim/plugged/fzf.vim/'

continuing in <SNR>4_infer_properties

<SNR>4_infer_properties returning {'uri': 'https://git::@github.com/june...': '/home/Dante/.vim/plugged/fzf.vim/'}

continuing in plug#

line 10:     if !has_key(g:plugs, name)
line 11:       call add(g:plugs_order, name)
line 12:     endif
line 13:     let g:plugs[name] = spec
line 14:     let s:loaded[name] = get(s:loaded, name, 0)
line 15:   catch
line 16:     return s:err(repo . ' ' . v:exception)
line 17:   endtry
plug# returning #0

continuing in /home/Dante/.vimrc

line 52: 
line 53: "Clipboard with Wayland/Hyprland
line 54: Plug 'jasonccox/vim-wayland-clipboard'
line 54: call plug#('jasonccox/vim-wayland-clipboard')
calling plug#('jasonccox/vim-wayland-clipboard')

line 1:   if a:0 > 1
line 2:     return s:err('Invalid number of arguments (1..2)')
line 3:   endif
line 4: 
line 5:   try
line 6:     let repo = s:trim(a:repo)
calling <SNR>4_trim('jasonccox/vim-wayland-clipboard')

line 1:   return substitute(a:str, '[\/]\+$', '', '')
<SNR>4_trim returning 'jasonccox/vim-wayland-clipboard'

continuing in plug#

line 7:     let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec
line 8:     let name = get(opts, 'as', s:plug_fnamemodify(repo, ':t:s?\.git$??'))
calling <SNR>4_plug_fnamemodify('jasonccox/vim-wayland-clipboard', ':t:s?\.git$??')

line 1:   return s:plug_call('fnamemodify', a:fname, a:mods)
calling <SNR>4_plug_call('fnamemodify', 'jasonccox/vim-wayland-clipboard', ':t:s?\.git$??')

line 1:     return call(a:fn, a:000)
<SNR>4_plug_call returning 'vim-wayland-clipboard'

continuing in <SNR>4_plug_fnamemodify

<SNR>4_plug_fnamemodify returning 'vim-wayland-clipboard'

continuing in plug#

line 9:     let spec = extend(s:infer_properties(name, repo), opts)
calling <SNR>4_infer_properties('vim-wayland-clipboard', 'jasonccox/vim-wayland-clipboard')

line 1:   let repo = a:repo
line 2:   if s:is_local_plug(repo)
calling <SNR>4_is_local_plug('jasonccox/vim-wayland-clipboard')

line 1:     return a:repo[0] =~ '[/$~]'
<SNR>4_is_local_plug returning #0

continuing in <SNR>4_infer_properties

line 3:     return { 'dir': s:dirpath(s:plug_expand(repo)) }
line 4:   else
line 5:     if repo =~ ':'
line 6:       let uri = repo
line 7:     else
line 8:       if repo !~ '/'
line 9:         throw printf('Invalid argument: %s (implicit `vim-scripts'' expansion is deprecated)', repo)
line 10:       endif
line 11:       let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')
line 12:       let uri = printf(fmt, repo)
line 13:     endif
line 14:     return { 'dir': s:dirpath(g:plug_home.'/'.a:name), 'uri': uri }
calling <SNR>4_dirpath('/home/Dante/.vim/plugged/vim-wayland-clipboard')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')
<SNR>4_dirpath returning '/home/Dante/.vim/plugged/vim-wayland-clipboard/'

continuing in <SNR>4_infer_properties

<SNR>4_infer_properties returning {'uri': 'https://git::@github.com/jaso...e/.vim/plugged/vim-wayland-clipboard/'}

continuing in plug#

line 10:     if !has_key(g:plugs, name)
line 11:       call add(g:plugs_order, name)
line 12:     endif
line 13:     let g:plugs[name] = spec
line 14:     let s:loaded[name] = get(s:loaded, name, 0)
line 15:   catch
line 16:     return s:err(repo . ' ' . v:exception)
line 17:   endtry
plug# returning #0

continuing in /home/Dante/.vimrc

line 55: 
line 56: "I haven't gotten any of them working :/
line 57: "LSP Plugins
line 58: "Be sure to update the CocConfig file for fortls and semanticHighlighting
line 59: Plug 'neoclide/coc.nvim', {'branch': 'release'}
line 59: call plug#('neoclide/coc.nvim', {'branch': 'release'})
calling plug#('neoclide/coc.nvim', {'branch': 'release'})

line 1:   if a:0 > 1
line 2:     return s:err('Invalid number of arguments (1..2)')
line 3:   endif
line 4: 
line 5:   try
line 6:     let repo = s:trim(a:repo)
calling <SNR>4_trim('neoclide/coc.nvim')

line 1:   return substitute(a:str, '[\/]\+$', '', '')
<SNR>4_trim returning 'neoclide/coc.nvim'

continuing in plug#

line 7:     let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec
calling <SNR>4_parse_options({'branch': 'release'})

line 1:   let opts = copy(s:base_spec)
line 2:   let type = type(a:arg)
line 3:   let opt_errfmt = 'Invalid argument for "%s" option of :Plug (expected: %s)'
line 4:   if type == s:TYPE.string
line 5:     if empty(a:arg)
line 6:       throw printf(opt_errfmt, 'tag', 'string')
line 7:     endif
line 8:     let opts.tag = a:arg
line 9:   elseif type == s:TYPE.dict
line 10:     for opt in ['branch', 'tag', 'commit', 'rtp', 'dir', 'as']
line 11:       if has_key(a:arg, opt) && (type(a:arg[opt]) != s:TYPE.string || empty(a:arg[opt]))
line 13:         throw printf(opt_errfmt, opt, 'string')
line 14:       endif
line 15:     endfor
line 10:     for opt in ['branch', 'tag', 'commit', 'rtp', 'dir', 'as']
line 11:       if has_key(a:arg, opt) && (type(a:arg[opt]) != s:TYPE.string || empty(a:arg[opt]))
line 13:         throw printf(opt_errfmt, opt, 'string')
line 14:       endif
line 15:     endfor
line 10:     for opt in ['branch', 'tag', 'commit', 'rtp', 'dir', 'as']
line 11:       if has_key(a:arg, opt) && (type(a:arg[opt]) != s:TYPE.string || empty(a:arg[opt]))
line 13:         throw printf(opt_errfmt, opt, 'string')
line 14:       endif
line 15:     endfor
line 10:     for opt in ['branch', 'tag', 'commit', 'rtp', 'dir', 'as']
line 11:       if has_key(a:arg, opt) && (type(a:arg[opt]) != s:TYPE.string || empty(a:arg[opt]))
line 13:         throw printf(opt_errfmt, opt, 'string')
line 14:       endif
line 15:     endfor
line 10:     for opt in ['branch', 'tag', 'commit', 'rtp', 'dir', 'as']
line 11:       if has_key(a:arg, opt) && (type(a:arg[opt]) != s:TYPE.string || empty(a:arg[opt]))
line 13:         throw printf(opt_errfmt, opt, 'string')
line 14:       endif
line 15:     endfor
line 10:     for opt in ['branch', 'tag', 'commit', 'rtp', 'dir', 'as']
line 11:       if has_key(a:arg, opt) && (type(a:arg[opt]) != s:TYPE.string || empty(a:arg[opt]))
line 13:         throw printf(opt_errfmt, opt, 'string')
line 14:       endif
line 15:     endfor
line 10:     for opt in ['branch', 'tag', 'commit', 'rtp', 'dir', 'as']
line 11:       if has_key(a:arg, opt) && (type(a:arg[opt]) != s:TYPE.string || empty(a:arg[opt]))
line 13:         throw printf(opt_errfmt, opt, 'string')
line 14:       endif
line 15:     endfor
line 16:     for opt in ['on', 'for']
line 17:       if has_key(a:arg, opt) && type(a:arg[opt]) != s:TYPE.list && (type(a:arg[opt]) != s:TYPE.string || empty(a:arg[opt]))
line 20:         throw printf(opt_errfmt, opt, 'string or list')
line 21:       endif
line 22:     endfor
line 16:     for opt in ['on', 'for']
line 17:       if has_key(a:arg, opt) && type(a:arg[opt]) != s:TYPE.list && (type(a:arg[opt]) != s:TYPE.string || empty(a:arg[opt]))
line 20:         throw printf(opt_errfmt, opt, 'string or list')
line 21:       endif
line 22:     endfor
line 16:     for opt in ['on', 'for']
line 17:       if has_key(a:arg, opt) && type(a:arg[opt]) != s:TYPE.list && (type(a:arg[opt]) != s:TYPE.string || empty(a:arg[opt]))
line 20:         throw printf(opt_errfmt, opt, 'string or list')
line 21:       endif
line 22:     endfor
line 23:     if has_key(a:arg, 'do') && type(a:arg.do) != s:TYPE.funcref && (type(a:arg.do) != s:TYPE.string || empty(a:arg.do))
line 26:         throw printf(opt_errfmt, 'do', 'string or funcref')
line 27:     endif
line 28:     call extend(opts, a:arg)
line 29:     if has_key(opts, 'dir')
line 30:       let opts.dir = s:dirpath(s:plug_expand(opts.dir))
line 31:     endif
line 32:   else
line 33:     throw 'Invalid argument type (expected: string or dictionary)'
line 34:   endif
line 35:   return opts
<SNR>4_parse_options returning {'frozen': 0, 'branch': 'release'}

continuing in plug#

line 8:     let name = get(opts, 'as', s:plug_fnamemodify(repo, ':t:s?\.git$??'))
calling <SNR>4_plug_fnamemodify('neoclide/coc.nvim', ':t:s?\.git$??')

line 1:   return s:plug_call('fnamemodify', a:fname, a:mods)
calling <SNR>4_plug_call('fnamemodify', 'neoclide/coc.nvim', ':t:s?\.git$??')

line 1:     return call(a:fn, a:000)
<SNR>4_plug_call returning 'coc.nvim'

continuing in <SNR>4_plug_fnamemodify

<SNR>4_plug_fnamemodify returning 'coc.nvim'

continuing in plug#

line 9:     let spec = extend(s:infer_properties(name, repo), opts)
calling <SNR>4_infer_properties('coc.nvim', 'neoclide/coc.nvim')

line 1:   let repo = a:repo
line 2:   if s:is_local_plug(repo)
calling <SNR>4_is_local_plug('neoclide/coc.nvim')

line 1:     return a:repo[0] =~ '[/$~]'
<SNR>4_is_local_plug returning #0

continuing in <SNR>4_infer_properties

line 3:     return { 'dir': s:dirpath(s:plug_expand(repo)) }
line 4:   else
line 5:     if repo =~ ':'
line 6:       let uri = repo
line 7:     else
line 8:       if repo !~ '/'
line 9:         throw printf('Invalid argument: %s (implicit `vim-scripts'' expansion is deprecated)', repo)
line 10:       endif
line 11:       let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')
line 12:       let uri = printf(fmt, repo)
line 13:     endif
line 14:     return { 'dir': s:dirpath(g:plug_home.'/'.a:name), 'uri': uri }
calling <SNR>4_dirpath('/home/Dante/.vim/plugged/coc.nvim')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')
<SNR>4_dirpath returning '/home/Dante/.vim/plugged/coc.nvim/'

continuing in <SNR>4_infer_properties

<SNR>4_infer_properties returning {'uri': 'https://git::@github.com/neoc...: '/home/Dante/.vim/plugged/coc.nvim/'}

continuing in plug#

line 10:     if !has_key(g:plugs, name)
line 11:       call add(g:plugs_order, name)
line 12:     endif
line 13:     let g:plugs[name] = spec
line 14:     let s:loaded[name] = get(s:loaded, name, 0)
line 15:   catch
line 16:     return s:err(repo . ' ' . v:exception)
line 17:   endtry
plug# returning #0

continuing in /home/Dante/.vimrc

line 60: 
line 61: Plug 'tpope/vim-obsession'
line 61: call plug#('tpope/vim-obsession')
calling plug#('tpope/vim-obsession')

line 1:   if a:0 > 1
line 2:     return s:err('Invalid number of arguments (1..2)')
line 3:   endif
line 4: 
line 5:   try
line 6:     let repo = s:trim(a:repo)
calling <SNR>4_trim('tpope/vim-obsession')

line 1:   return substitute(a:str, '[\/]\+$', '', '')
<SNR>4_trim returning 'tpope/vim-obsession'

continuing in plug#

line 7:     let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec
line 8:     let name = get(opts, 'as', s:plug_fnamemodify(repo, ':t:s?\.git$??'))
calling <SNR>4_plug_fnamemodify('tpope/vim-obsession', ':t:s?\.git$??')

line 1:   return s:plug_call('fnamemodify', a:fname, a:mods)
calling <SNR>4_plug_call('fnamemodify', 'tpope/vim-obsession', ':t:s?\.git$??')

line 1:     return call(a:fn, a:000)
<SNR>4_plug_call returning 'vim-obsession'

continuing in <SNR>4_plug_fnamemodify

<SNR>4_plug_fnamemodify returning 'vim-obsession'

continuing in plug#

line 9:     let spec = extend(s:infer_properties(name, repo), opts)
calling <SNR>4_infer_properties('vim-obsession', 'tpope/vim-obsession')

line 1:   let repo = a:repo
line 2:   if s:is_local_plug(repo)
calling <SNR>4_is_local_plug('tpope/vim-obsession')

line 1:     return a:repo[0] =~ '[/$~]'
<SNR>4_is_local_plug returning #0

continuing in <SNR>4_infer_properties

line 3:     return { 'dir': s:dirpath(s:plug_expand(repo)) }
line 4:   else
line 5:     if repo =~ ':'
line 6:       let uri = repo
line 7:     else
line 8:       if repo !~ '/'
line 9:         throw printf('Invalid argument: %s (implicit `vim-scripts'' expansion is deprecated)', repo)
line 10:       endif
line 11:       let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')
line 12:       let uri = printf(fmt, repo)
line 13:     endif
line 14:     return { 'dir': s:dirpath(g:plug_home.'/'.a:name), 'uri': uri }
calling <SNR>4_dirpath('/home/Dante/.vim/plugged/vim-obsession')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')
<SNR>4_dirpath returning '/home/Dante/.vim/plugged/vim-obsession/'

continuing in <SNR>4_infer_properties

<SNR>4_infer_properties returning {'uri': 'https://git::@github.com/tpop...ome/Dante/.vim/plugged/vim-obsession/'}

continuing in plug#

line 10:     if !has_key(g:plugs, name)
line 11:       call add(g:plugs_order, name)
line 12:     endif
line 13:     let g:plugs[name] = spec
line 14:     let s:loaded[name] = get(s:loaded, name, 0)
line 15:   catch
line 16:     return s:err(repo . ' ' . v:exception)
line 17:   endtry
plug# returning #0

continuing in /home/Dante/.vimrc

line 62: 
line 63: call plug#end()
calling plug#end()

line 1:   if !exists('g:plugs')
line 2:     return s:err('plug#end() called without calling plug#begin() first')
line 3:   endif
line 4: 
line 5:   if exists('#PlugLOD')
line 6:     augroup PlugLOD
line 7:       autocmd!
line 8:     augroup END
line 9:     augroup! PlugLOD
line 10:   endif
line 11:   let lod = { 'ft': {}, 'map': {}, 'cmd': {} }
line 12: 
line 13:   if get(g:, 'did_load_filetypes', 0)
line 14:     filetype off
line 15:   endif
line 16:   for name in g:plugs_order
line 17:     if !has_key(g:plugs, name)
line 18:       continue
line 19:     endif
line 20:     let plug = g:plugs[name]
line 21:     if get(s:loaded, name, 0) || !s:lazy(plug, 'on') && !s:lazy(plug, 'for')
calling <SNR>4_lazy({'uri': 'https://git::@github.com/josh...edark.vim/', 'frozen': 0, 'branch': ''}, 'on')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))
<SNR>4_lazy returning #0

continuing in plug#end

calling <SNR>4_lazy({'uri': 'https://git::@github.com/josh...edark.vim/', 'frozen': 0, 'branch': ''}, 'for')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))
<SNR>4_lazy returning #0

continuing in plug#end

line 22:       let s:loaded[name] = 1
line 23:       continue
line 16:   for name in g:plugs_order
line 17:     if !has_key(g:plugs, name)
line 18:       continue
line 19:     endif
line 20:     let plug = g:plugs[name]
line 21:     if get(s:loaded, name, 0) || !s:lazy(plug, 'on') && !s:lazy(plug, 'for')
calling <SNR>4_lazy({'uri': 'https://git::@github.com/sonp...frozen': 0, 'rtp': 'vim', 'branch': ''}, 'on')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))
<SNR>4_lazy returning #0

continuing in plug#end

calling <SNR>4_lazy({'uri': 'https://git::@github.com/sonp...frozen': 0, 'rtp': 'vim', 'branch': ''}, 'for')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))
<SNR>4_lazy returning #0

continuing in plug#end

line 22:       let s:loaded[name] = 1
line 23:       continue
line 16:   for name in g:plugs_order
line 17:     if !has_key(g:plugs, name)
line 18:       continue
line 19:     endif
line 20:     let plug = g:plugs[name]
line 21:     if get(s:loaded, name, 0) || !s:lazy(plug, 'on') && !s:lazy(plug, 'for')
calling <SNR>4_lazy({'uri': 'https://git::@github.com/morh...d/gruvbox/', 'frozen': 0, 'branch': ''}, 'on')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))
<SNR>4_lazy returning #0

continuing in plug#end

calling <SNR>4_lazy({'uri': 'https://git::@github.com/morh...d/gruvbox/', 'frozen': 0, 'branch': ''}, 'for')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))
<SNR>4_lazy returning #0

continuing in plug#end

line 22:       let s:loaded[name] = 1
line 23:       continue
line 16:   for name in g:plugs_order
line 17:     if !has_key(g:plugs, name)
line 18:       continue
line 19:     endif
line 20:     let plug = g:plugs[name]
line 21:     if get(s:loaded, name, 0) || !s:lazy(plug, 'on') && !s:lazy(plug, 'for')
calling <SNR>4_lazy({'uri': 'https://git::@github.com/itch...tline.vim/', 'frozen': 0, 'branch': ''}, 'on')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))
<SNR>4_lazy returning #0

continuing in plug#end

calling <SNR>4_lazy({'uri': 'https://git::@github.com/itch...tline.vim/', 'frozen': 0, 'branch': ''}, 'for')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))
<SNR>4_lazy returning #0

continuing in plug#end

line 22:       let s:loaded[name] = 1
line 23:       continue
line 16:   for name in g:plugs_order
line 17:     if !has_key(g:plugs, name)
line 18:       continue
line 19:     endif
line 20:     let plug = g:plugs[name]
line 21:     if get(s:loaded, name, 0) || !s:lazy(plug, 'on') && !s:lazy(plug, 'for')
calling <SNR>4_lazy({'uri': 'https://git::@github.com/chri...navigator/', 'frozen': 0, 'branch': ''}, 'on')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))
<SNR>4_lazy returning #0

continuing in plug#end

calling <SNR>4_lazy({'uri': 'https://git::@github.com/chri...navigator/', 'frozen': 0, 'branch': ''}, 'for')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))
<SNR>4_lazy returning #0

continuing in plug#end

line 22:       let s:loaded[name] = 1
line 23:       continue
line 16:   for name in g:plugs_order
line 17:     if !has_key(g:plugs, name)
line 18:       continue
line 19:     endif
line 20:     let plug = g:plugs[name]
line 21:     if get(s:loaded, name, 0) || !s:lazy(plug, 'on') && !s:lazy(plug, 'for')
calling <SNR>4_lazy({'uri': 'https://git::@github.com/lerv...ed/vimtex/', 'frozen': 0, 'branch': ''}, 'on')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))
<SNR>4_lazy returning #0

continuing in plug#end

calling <SNR>4_lazy({'uri': 'https://git::@github.com/lerv...ed/vimtex/', 'frozen': 0, 'branch': ''}, 'for')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))
<SNR>4_lazy returning #0

continuing in plug#end

line 22:       let s:loaded[name] = 1
line 23:       continue
line 16:   for name in g:plugs_order
line 17:     if !has_key(g:plugs, name)
line 18:       continue
line 19:     endif
line 20:     let plug = g:plugs[name]
line 21:     if get(s:loaded, name, 0) || !s:lazy(plug, 'on') && !s:lazy(plug, 'for')
calling <SNR>4_lazy({'uri': 'https://git::@github.com/pres.../nerdtree/', 'frozen': 0, 'branch': ''}, 'on')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))
<SNR>4_lazy returning #0

continuing in plug#end

calling <SNR>4_lazy({'uri': 'https://git::@github.com/pres.../nerdtree/', 'frozen': 0, 'branch': ''}, 'for')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))
<SNR>4_lazy returning #0

continuing in plug#end

line 22:       let s:loaded[name] = 1
line 23:       continue
line 16:   for name in g:plugs_order
line 17:     if !has_key(g:plugs, name)
line 18:       continue
line 19:     endif
line 20:     let plug = g:plugs[name]
line 21:     if get(s:loaded, name, 0) || !s:lazy(plug, 'on') && !s:lazy(plug, 'for')
calling <SNR>4_lazy({'uri': 'https://git::@github.com/june...anch': '', 'do': function('<lambda>1')}, 'on')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))
<SNR>4_lazy returning #0

continuing in plug#end

calling <SNR>4_lazy({'uri': 'https://git::@github.com/june...anch': '', 'do': function('<lambda>1')}, 'for')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))
<SNR>4_lazy returning #0

continuing in plug#end

line 22:       let s:loaded[name] = 1
line 23:       continue
line 16:   for name in g:plugs_order
line 17:     if !has_key(g:plugs, name)
line 18:       continue
line 19:     endif
line 20:     let plug = g:plugs[name]
line 21:     if get(s:loaded, name, 0) || !s:lazy(plug, 'on') && !s:lazy(plug, 'for')
calling <SNR>4_lazy({'uri': 'https://git::@github.com/june...d/fzf.vim/', 'frozen': 0, 'branch': ''}, 'on')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))
<SNR>4_lazy returning #0

continuing in plug#end

calling <SNR>4_lazy({'uri': 'https://git::@github.com/june...d/fzf.vim/', 'frozen': 0, 'branch': ''}, 'for')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))
<SNR>4_lazy returning #0

continuing in plug#end

line 22:       let s:loaded[name] = 1
line 23:       continue
line 16:   for name in g:plugs_order
line 17:     if !has_key(g:plugs, name)
line 18:       continue
line 19:     endif
line 20:     let plug = g:plugs[name]
line 21:     if get(s:loaded, name, 0) || !s:lazy(plug, 'on') && !s:lazy(plug, 'for')
calling <SNR>4_lazy({'uri': 'https://git::@github.com/jaso...clipboard/', 'frozen': 0, 'branch': ''}, 'on')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))
<SNR>4_lazy returning #0

continuing in plug#end

calling <SNR>4_lazy({'uri': 'https://git::@github.com/jaso...clipboard/', 'frozen': 0, 'branch': ''}, 'for')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))
<SNR>4_lazy returning #0

continuing in plug#end

line 22:       let s:loaded[name] = 1
line 23:       continue
line 16:   for name in g:plugs_order
line 17:     if !has_key(g:plugs, name)
line 18:       continue
line 19:     endif
line 20:     let plug = g:plugs[name]
line 21:     if get(s:loaded, name, 0) || !s:lazy(plug, 'on') && !s:lazy(plug, 'for')
calling <SNR>4_lazy({'uri': 'https://git::@github.com/neoc...im/', 'frozen': 0, 'branch': 'release'}, 'on')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))
<SNR>4_lazy returning #0

continuing in plug#end

calling <SNR>4_lazy({'uri': 'https://git::@github.com/neoc...im/', 'frozen': 0, 'branch': 'release'}, 'for')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))
<SNR>4_lazy returning #0

continuing in plug#end

line 22:       let s:loaded[name] = 1
line 23:       continue
line 16:   for name in g:plugs_order
line 17:     if !has_key(g:plugs, name)
line 18:       continue
line 19:     endif
line 20:     let plug = g:plugs[name]
line 21:     if get(s:loaded, name, 0) || !s:lazy(plug, 'on') && !s:lazy(plug, 'for')
calling <SNR>4_lazy({'uri': 'https://git::@github.com/tpop...obsession/', 'frozen': 0, 'branch': ''}, 'on')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))
<SNR>4_lazy returning #0

continuing in plug#end

calling <SNR>4_lazy({'uri': 'https://git::@github.com/tpop...obsession/', 'frozen': 0, 'branch': ''}, 'for')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))
<SNR>4_lazy returning #0

continuing in plug#end

line 22:       let s:loaded[name] = 1
line 23:       continue
line 16:   for name in g:plugs_order
line 17:     if !has_key(g:plugs, name)
line 18:       continue
line 19:     endif
line 20:     let plug = g:plugs[name]
line 21:     if get(s:loaded, name, 0) || !s:lazy(plug, 'on') && !s:lazy(plug, 'for')
line 22:       let s:loaded[name] = 1
line 23:       continue
line 24:     endif
line 25: 
line 26:     if has_key(plug, 'on')
line 27:       let s:triggers[name] = { 'map': [], 'cmd': [] }
line 28:       for cmd in s:to_a(plug.on)
line 29:         if cmd =~? '^<Plug>.\+'
line 30:           if empty(mapcheck(cmd)) && empty(mapcheck(cmd, 'i'))
line 31:             call s:assoc(lod.map, cmd, name)
line 32:           endif
line 33:           call add(s:triggers[name].map, cmd)
line 34:         elseif cmd =~# '^[A-Z]'
line 35:           let cmd = substitute(cmd, '!*$', '', '')
line 36:           if exists(':'.cmd) != 2
line 37:             call s:assoc(lod.cmd, cmd, name)
line 38:           endif
line 39:           call add(s:triggers[name].cmd, cmd)
line 40:         else
line 41:           call s:err('Invalid `on` option: '.cmd. '. Should start with an uppercase letter or `<Plug>`.')
line 43:         endif
line 44:       endfor
line 45:     endif
line 46: 
line 47:     if has_key(plug, 'for')
line 48:       let types = s:to_a(plug.for)
line 49:       if !empty(types)
line 50:         augroup filetypedetect
line 51:         call s:source(s:rtp(plug), 'ftdetect/**/*.vim', 'after/ftdetect/**/*.vim')
line 52:         if has('nvim-0.5.0')
line 53:           call s:source(s:rtp(plug), 'ftdetect/**/*.lua', 'after/ftdetect/**/*.lua')
line 54:         endif
line 55:         augroup END
line 56:       endif
line 57:       for type in types
line 58:         call s:assoc(lod.ft, type, name)
line 59:       endfor
line 60:     endif
line 61:   endfor
line 62: 
line 63:   for [cmd, names] in items(lod.cmd)
line 64:     execute printf( 'command! -nargs=* -range -bang -complete=file %s call s:lod_cmd(%s, "<bang>", <line1>, <line2>, <q-args>, %s)', cmd, string(cmd), string(names))
line 67:   endfor
line 68: 
line 69:   for [map, names] in items(lod.map)
line 70:     for [mode, map_prefix, key_prefix] in [['i', '<C-\><C-O>', ''], ['n', '', ''], ['v', '', 'gv'], ['o', '', '']]
line 72:       execute printf( '%snoremap <silent> %s %s:<C-U>call <SID>lod_map(%s, %s, %s, "%s")<CR>', mode, map, map_prefix, string(map), string(names), mode != 'i', key_prefix)
line 75:     endfor
line 76:   endfor
line 77: 
line 78:   for [ft, names] in items(lod.ft)
line 79:     augroup PlugLOD
line 80:       execute printf('autocmd FileType %s call <SID>lod_ft(%s, %s)', ft, string(ft), string(names))
line 82:     augroup END
line 83:   endfor
line 84: 
line 85:   call s:reorg_rtp()
calling <SNR>4_reorg_rtp()

line 1:   if !empty(s:first_rtp)
line 2:     execute 'set rtp-='.s:first_rtp
line 2: set rtp-=/home/Dante/.vim
line 3:     execute 'set rtp-='.s:last_rtp
line 3: set rtp-=/home/Dante/.vim/after
line 4:   endif
line 5: 
line 6:   " &rtp is modified from outside
line 7:   if exists('s:prtp') && s:prtp !=# &rtp
line 8:     call s:remove_rtp()
line 9:     unlet! s:middle
line 10:   endif
line 11: 
line 12:   let s:middle = get(s:, 'middle', &rtp)
line 13:   let rtps     = map(s:loaded_names(), 's:rtp(g:plugs[v:val])')
calling <SNR>4_loaded_names()

line 1:   return filter(copy(g:plugs_order), 'get(s:loaded, v:val, 0)')
<SNR>4_loaded_names returning ['onedark.vim', 'onehalf', 'gruvbox', ...lipboard', 'coc.nvim', 'vim-obsession']

continuing in <SNR>4_reorg_rtp

calling <SNR>4_rtp({'uri': 'https://git::@github.com/josh...edark.vim/', 'frozen': 0, 'branch': ''})

line 1:   return s:path(a:spec.dir . get(a:spec, 'rtp', ''))
calling <SNR>4_path('/home/Dante/.vim/plugged/onedark.vim/')

line 1:     return s:trim(a:path)
calling <SNR>4_trim('/home/Dante/.vim/plugged/onedark.vim/')

line 1:   return substitute(a:str, '[\/]\+$', '', '')
<SNR>4_trim returning '/home/Dante/.vim/plugged/onedark.vim'

continuing in <SNR>4_path

<SNR>4_path returning '/home/Dante/.vim/plugged/onedark.vim'

continuing in <SNR>4_rtp

<SNR>4_rtp returning '/home/Dante/.vim/plugged/onedark.vim'

continuing in <SNR>4_reorg_rtp

calling <SNR>4_rtp({'uri': 'https://git::@github.com/sonp...frozen': 0, 'rtp': 'vim', 'branch': ''})

line 1:   return s:path(a:spec.dir . get(a:spec, 'rtp', ''))
calling <SNR>4_path('/home/Dante/.vim/plugged/onehalf/vim')

line 1:     return s:trim(a:path)
calling <SNR>4_trim('/home/Dante/.vim/plugged/onehalf/vim')

line 1:   return substitute(a:str, '[\/]\+$', '', '')
<SNR>4_trim returning '/home/Dante/.vim/plugged/onehalf/vim'

continuing in <SNR>4_path

<SNR>4_path returning '/home/Dante/.vim/plugged/onehalf/vim'

continuing in <SNR>4_rtp

<SNR>4_rtp returning '/home/Dante/.vim/plugged/onehalf/vim'

continuing in <SNR>4_reorg_rtp

calling <SNR>4_rtp({'uri': 'https://git::@github.com/morh...d/gruvbox/', 'frozen': 0, 'branch': ''})

line 1:   return s:path(a:spec.dir . get(a:spec, 'rtp', ''))
calling <SNR>4_path('/home/Dante/.vim/plugged/gruvbox/')

line 1:     return s:trim(a:path)
calling <SNR>4_trim('/home/Dante/.vim/plugged/gruvbox/')

line 1:   return substitute(a:str, '[\/]\+$', '', '')
<SNR>4_trim returning '/home/Dante/.vim/plugged/gruvbox'

continuing in <SNR>4_path

<SNR>4_path returning '/home/Dante/.vim/plugged/gruvbox'

continuing in <SNR>4_rtp

<SNR>4_rtp returning '/home/Dante/.vim/plugged/gruvbox'

continuing in <SNR>4_reorg_rtp

calling <SNR>4_rtp({'uri': 'https://git::@github.com/itch...tline.vim/', 'frozen': 0, 'branch': ''})

line 1:   return s:path(a:spec.dir . get(a:spec, 'rtp', ''))
calling <SNR>4_path('/home/Dante/.vim/plugged/lightline.vim/')

line 1:     return s:trim(a:path)
calling <SNR>4_trim('/home/Dante/.vim/plugged/lightline.vim/')

line 1:   return substitute(a:str, '[\/]\+$', '', '')
<SNR>4_trim returning '/home/Dante/.vim/plugged/lightline.vim'

continuing in <SNR>4_path

<SNR>4_path returning '/home/Dante/.vim/plugged/lightline.vim'

continuing in <SNR>4_rtp

<SNR>4_rtp returning '/home/Dante/.vim/plugged/lightline.vim'

continuing in <SNR>4_reorg_rtp

calling <SNR>4_rtp({'uri': 'https://git::@github.com/chri...navigator/', 'frozen': 0, 'branch': ''})

line 1:   return s:path(a:spec.dir . get(a:spec, 'rtp', ''))
calling <SNR>4_path('/home/Dante/.vim/plugged/vim-tmux-navigator/')

line 1:     return s:trim(a:path)
calling <SNR>4_trim('/home/Dante/.vim/plugged/vim-tmux-navigator/')

line 1:   return substitute(a:str, '[\/]\+$', '', '')
<SNR>4_trim returning '/home/Dante/.vim/plugged/vim-tmux-navigator'

continuing in <SNR>4_path

<SNR>4_path returning '/home/Dante/.vim/plugged/vim-tmux-navigator'

continuing in <SNR>4_rtp

<SNR>4_rtp returning '/home/Dante/.vim/plugged/vim-tmux-navigator'

continuing in <SNR>4_reorg_rtp

calling <SNR>4_rtp({'uri': 'https://git::@github.com/lerv...ed/vimtex/', 'frozen': 0, 'branch': ''})

line 1:   return s:path(a:spec.dir . get(a:spec, 'rtp', ''))
calling <SNR>4_path('/home/Dante/.vim/plugged/vimtex/')

line 1:     return s:trim(a:path)
calling <SNR>4_trim('/home/Dante/.vim/plugged/vimtex/')

line 1:   return substitute(a:str, '[\/]\+$', '', '')
<SNR>4_trim returning '/home/Dante/.vim/plugged/vimtex'

continuing in <SNR>4_path

<SNR>4_path returning '/home/Dante/.vim/plugged/vimtex'

continuing in <SNR>4_rtp

<SNR>4_rtp returning '/home/Dante/.vim/plugged/vimtex'

continuing in <SNR>4_reorg_rtp

calling <SNR>4_rtp({'uri': 'https://git::@github.com/pres.../nerdtree/', 'frozen': 0, 'branch': ''})

line 1:   return s:path(a:spec.dir . get(a:spec, 'rtp', ''))
calling <SNR>4_path('/home/Dante/.vim/plugged/nerdtree/')

line 1:     return s:trim(a:path)
calling <SNR>4_trim('/home/Dante/.vim/plugged/nerdtree/')

line 1:   return substitute(a:str, '[\/]\+$', '', '')
<SNR>4_trim returning '/home/Dante/.vim/plugged/nerdtree'

continuing in <SNR>4_path

<SNR>4_path returning '/home/Dante/.vim/plugged/nerdtree'

continuing in <SNR>4_rtp

<SNR>4_rtp returning '/home/Dante/.vim/plugged/nerdtree'

continuing in <SNR>4_reorg_rtp

calling <SNR>4_rtp({'uri': 'https://git::@github.com/june...anch': '', 'do': function('<lambda>1')})

line 1:   return s:path(a:spec.dir . get(a:spec, 'rtp', ''))
calling <SNR>4_path('/home/Dante/.vim/plugged/fzf/')

line 1:     return s:trim(a:path)
calling <SNR>4_trim('/home/Dante/.vim/plugged/fzf/')

line 1:   return substitute(a:str, '[\/]\+$', '', '')
<SNR>4_trim returning '/home/Dante/.vim/plugged/fzf'

continuing in <SNR>4_path

<SNR>4_path returning '/home/Dante/.vim/plugged/fzf'

continuing in <SNR>4_rtp

<SNR>4_rtp returning '/home/Dante/.vim/plugged/fzf'

continuing in <SNR>4_reorg_rtp

calling <SNR>4_rtp({'uri': 'https://git::@github.com/june...d/fzf.vim/', 'frozen': 0, 'branch': ''})

line 1:   return s:path(a:spec.dir . get(a:spec, 'rtp', ''))
calling <SNR>4_path('/home/Dante/.vim/plugged/fzf.vim/')

line 1:     return s:trim(a:path)
calling <SNR>4_trim('/home/Dante/.vim/plugged/fzf.vim/')

line 1:   return substitute(a:str, '[\/]\+$', '', '')
<SNR>4_trim returning '/home/Dante/.vim/plugged/fzf.vim'

continuing in <SNR>4_path

<SNR>4_path returning '/home/Dante/.vim/plugged/fzf.vim'

continuing in <SNR>4_rtp

<SNR>4_rtp returning '/home/Dante/.vim/plugged/fzf.vim'

continuing in <SNR>4_reorg_rtp

calling <SNR>4_rtp({'uri': 'https://git::@github.com/jaso...clipboard/', 'frozen': 0, 'branch': ''})

line 1:   return s:path(a:spec.dir . get(a:spec, 'rtp', ''))
calling <SNR>4_path('/home/Dante/.vim/plugged/vim-wayland-clipboard/')

line 1:     return s:trim(a:path)
calling <SNR>4_trim('/home/Dante/.vim/plugged/vim-wayland-clipboard/')

line 1:   return substitute(a:str, '[\/]\+$', '', '')
<SNR>4_trim returning '/home/Dante/.vim/plugged/vim-wayland-clipboard'

continuing in <SNR>4_path

<SNR>4_path returning '/home/Dante/.vim/plugged/vim-wayland-clipboard'

continuing in <SNR>4_rtp

<SNR>4_rtp returning '/home/Dante/.vim/plugged/vim-wayland-clipboard'

continuing in <SNR>4_reorg_rtp

calling <SNR>4_rtp({'uri': 'https://git::@github.com/neoc...im/', 'frozen': 0, 'branch': 'release'})

line 1:   return s:path(a:spec.dir . get(a:spec, 'rtp', ''))
calling <SNR>4_path('/home/Dante/.vim/plugged/coc.nvim/')

line 1:     return s:trim(a:path)
calling <SNR>4_trim('/home/Dante/.vim/plugged/coc.nvim/')

line 1:   return substitute(a:str, '[\/]\+$', '', '')
<SNR>4_trim returning '/home/Dante/.vim/plugged/coc.nvim'

continuing in <SNR>4_path

<SNR>4_path returning '/home/Dante/.vim/plugged/coc.nvim'

continuing in <SNR>4_rtp

<SNR>4_rtp returning '/home/Dante/.vim/plugged/coc.nvim'

continuing in <SNR>4_reorg_rtp

calling <SNR>4_rtp({'uri': 'https://git::@github.com/tpop...obsession/', 'frozen': 0, 'branch': ''})

line 1:   return s:path(a:spec.dir . get(a:spec, 'rtp', ''))
calling <SNR>4_path('/home/Dante/.vim/plugged/vim-obsession/')

line 1:     return s:trim(a:path)
calling <SNR>4_trim('/home/Dante/.vim/plugged/vim-obsession/')

line 1:   return substitute(a:str, '[\/]\+$', '', '')
<SNR>4_trim returning '/home/Dante/.vim/plugged/vim-obsession'

continuing in <SNR>4_path

<SNR>4_path returning '/home/Dante/.vim/plugged/vim-obsession'

continuing in <SNR>4_rtp

<SNR>4_rtp returning '/home/Dante/.vim/plugged/vim-obsession'

continuing in <SNR>4_reorg_rtp

line 14:   let afters   = filter(map(copy(rtps), 'globpath(v:val, "after")'), '!empty(v:val)')
line 15:   let rtp      = join(map(rtps, 'escape(v:val, ",")'), ',') . ','.s:middle.',' . join(map(afters, 'escape(v:val, ",")'), ',')
line 18:   let &rtp     = substitute(substitute(rtp, ',,*', ',', 'g'), '^,\|,$', '', 'g')
line 19:   let s:prtp   = &rtp
line 20: 
line 21:   if !empty(s:first_rtp)
line 22:     execute 'set rtp^='.s:first_rtp
line 22: set rtp^=/home/Dante/.vim
line 23:     execute 'set rtp+='.s:last_rtp
line 23: set rtp+=/home/Dante/.vim/after
line 24:   endif
<SNR>4_reorg_rtp returning #0

continuing in plug#end

line 86:   filetype plugin indent on
Searching for "filetype.vim" in "/home/Dante/.vim,/home/Dante/.vim/plugged/onedark.vim,/home/Dante/.vim/plugged/onehalf/vim,/home/Dante/.vim/plugged/gruvbox,/home/Dante/.vim/plugged/lightline.vim,/home/Dante/.vim/plugged/vim-tmux-navigator,/home/Dante/.vim/plugged/vimtex,/home/Dante/.vim/plugged/nerdtree,/home/Dante/.vim/plugged/fzf,/home/Dante/.vim/plugged/fzf.vim,/home/Dante/.vim/plugged/vim-wayland-clipboard,/home/Dante/.vim/plugged/coc.nvim,/home/Dante/.vim/plugged/vim-obsession,/usr/share/vim/vimfiles,/usr/share/vim/vim91,/usr/share/vim/vimfiles/after,/home/Dante/.vim/plugged/vimtex/after,/home/Dante/.vim/after"
Searching for "/home/Dante/.vim/filetype.vim"
Searching for "/home/Dante/.vim/plugged/onedark.vim/filetype.vim"
Searching for "/home/Dante/.vim/plugged/onehalf/vim/filetype.vim"
Searching for "/home/Dante/.vim/plugged/gruvbox/filetype.vim"
Searching for "/home/Dante/.vim/plugged/lightline.vim/filetype.vim"
Searching for "/home/Dante/.vim/plugged/vim-tmux-navigator/filetype.vim"
Searching for "/home/Dante/.vim/plugged/vimtex/filetype.vim"
Searching for "/home/Dante/.vim/plugged/nerdtree/filetype.vim"
Searching for "/home/Dante/.vim/plugged/fzf/filetype.vim"
Searching for "/home/Dante/.vim/plugged/fzf.vim/filetype.vim"
Searching for "/home/Dante/.vim/plugged/vim-wayland-clipboard/filetype.vim"
Searching for "/home/Dante/.vim/plugged/coc.nvim/filetype.vim"
Searching for "/home/Dante/.vim/plugged/vim-obsession/filetype.vim"
Searching for "/usr/share/vim/vimfiles/filetype.vim"
Searching for "/usr/share/vim/vim91/filetype.vim"
chdir(/usr/share/vim/vim91)
fchdir() to previous dir
line 86: sourcing "/usr/share/vim/vim91/filetype.vim"
line 1: " Vim support file to detect file types
line 2: "
line 3: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 4: " Last Change:^I2025 Jan 20
line 5: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 6: 
line 7: " Listen very carefully, I will say this only once
line 8: if exists("did_load_filetypes")
line 9:   finish
line 10: endif
line 11: let did_load_filetypes = 1
line 12: 
line 13: " Line continuation is used here, remove 'C' from 'cpoptions'
line 14: let s:cpo_save = &cpo
line 15: set cpo&vim
line 16: 
line 17: augroup filetypedetect
line 18: 
line 19: " Ignored extensions
line 20: if exists("*fnameescape")
line 21: au BufNewFile,BufRead ?\+.orig,?\+.bak,?\+.old,?\+.new,?\+.dpkg-dist,?\+.dpkg-old,?\+.dpkg-new,?\+.dpkg-bak,?\+.rpmsave,?\+.rpmnew,?\+.pacsave,?\+.pacnew exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r"))
line 23: au BufNewFile,BufRead *~ let s:name = expand("<afile>") | let s:short = substitute(s:name, '\~\+$', '', '') | if s:name != s:short && s:short != "" |   exe "doau filetypedetect BufRead " . fnameescape(s:short) | endif | unlet! s:name s:short
line 30: au BufNewFile,BufRead ?\+.in if expand("<afile>:t") != "configure.in" |   exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r")) | endif
line 34: elseif &verbose > 0
line 35:   echomsg "Warning: some filetypes will not be recognized because this version of Vim does not have fnameescape()"
line 36: endif
line 37: 
line 38: " Pattern used to match file names which should not be inspected.
line 39: " Currently finds compressed files.
line 40: if !exists("g:ft_ignore_pat")
line 41:   let g:ft_ignore_pat = '\.\(Z\|gz\|bz2\|zip\|tgz\)$'
line 42: endif
line 43: 
line 44: " Function used for patterns that end in a star: don't set the filetype if the
line 45: " file name matches ft_ignore_pat.
line 46: " When using this, the entry should probably be further down below with the
line 47: " other StarSetf() calls.
line 48: func s:StarSetf(ft)
line 53: 
line 54: " Vim help file
line 55: au BufNewFile,BufRead $VIMRUNTIME/doc/*.txt^Isetf help
line 56: 
line 57: " Abaqus or Trasys
line 58: au BufNewFile,BufRead *.inp^I^I^Icall dist#ft#Check_inp()
line 59: 
line 60: " 8th (Firth-derivative)
line 61: au BufNewFile,BufRead *.8th^I^I^Isetf 8th
line 62: 
line 63: " A-A-P recipe
line 64: au BufNewFile,BufRead *.aap^I^I^Isetf aap
line 65: 
line 66: " A2ps printing utility
line 67: au BufNewFile,BufRead */etc/a2ps.cfg,*/etc/a2ps/*.cfg,a2psrc,.a2psrc setf a2ps
line 68: 
line 69: " ABAB/4
line 70: au BufNewFile,BufRead *.abap^I^I^Isetf abap
line 71: 
line 72: " ABC music notation
line 73: au BufNewFile,BufRead *.abc^I^I^Isetf abc
line 74: 
line 75: " ABEL
line 76: au BufNewFile,BufRead *.abl^I^I^Isetf abel
line 77: 
line 78: " AceDB
line 79: au BufNewFile,BufRead *.wrm^I^I^Isetf acedb
line 80: 
line 81: " Ada (83, 9X, 95)
line 82: au BufNewFile,BufRead *.adb,*.ads,*.ada^I^Isetf ada
line 83: if has("vms")
line 84:   au BufNewFile,BufRead *.gpr,*.ada_m,*.adc^Isetf ada
line 85: else
line 86:   au BufNewFile,BufRead *.gpr^I^I^Isetf ada
line 87: endif
line 88: 
line 89: " AHDL
line 90: au BufNewFile,BufRead *.tdf^I^I^Isetf ahdl
line 91: 
line 92: " AIDL
line 93: au BufNewFile,BufRead *.aidl^I^I^Isetf aidl
line 94: 
line 95: " AMPL
line 96: au BufNewFile,BufRead *.run^I^I^Isetf ampl
line 97: 
line 98: " Ant
line 99: au BufNewFile,BufRead build.xml^I^I^Isetf ant
line 100: 
line 101: " ANTLR / PCCTS
line 102: "au BufNewFile,BufRead *.g^I^I^Isetf antlr
line 103: au BufNewFile,BufRead *.g^I^I^Isetf pccts
line 104: 
line 105: " ANTLR 4
line 106: au BufNewFile,BufRead *.g4^I^I^Isetf antlr4
line 107: 
line 108: " Arduino
line 109: au BufNewFile,BufRead *.ino,*.pde^I^Isetf arduino
line 110: 
line 111: " Ash of busybox
line 112: au BufNewFile,BufRead .ash_history^I^Isetf sh
line 113: 
line 114: " Asymptote
line 115: au BufNewFile,BufRead *.asy^I^Isetf asy
line 116: 
line 117: " Apache config file
line 118: au BufNewFile,BufRead .htaccess,*/etc/httpd/*.conf^I^Isetf apache
line 119: au BufNewFile,BufRead */etc/apache2/sites-*/*.com^I^Isetf apache
line 120: 
line 121: " XA65 MOS6510 cross assembler
line 122: au BufNewFile,BufRead *.a65^I^I^Isetf a65
line 123: 
line 124: " Applescript
line 125: au BufNewFile,BufRead *.scpt^I^I^Isetf applescript
line 126: 
line 127: " Automake (must be before the *.am pattern)
line 128: au BufNewFile,BufRead [mM]akefile.am,GNUmakefile.am^Isetf automake
line 129: 
line 130: " Applix ELF
line 131: au BufNewFile,BufRead *.am^I^I^Isetf elf
line 132: 
line 133: " ALSA configuration
line 134: au BufNewFile,BufRead .asoundrc,*/usr/share/alsa/alsa.conf,*/etc/asound.conf setf alsaconf
line 135: 
line 136: " Arc Macro Language
line 137: au BufNewFile,BufRead *.aml^I^I^Isetf aml
line 138: 
line 139: " APT config file
line 140: au BufNewFile,BufRead apt.conf^I^I       setf aptconf
line 141: au BufNewFile,BufRead */.aptitude/config       setf aptconf
line 142: " more generic pattern far down
line 143: 
line 144: " Arch Inventory file
line 145: au BufNewFile,BufRead .arch-inventory,=tagging-method^Isetf arch
line 146: 
line 147: " ART*Enterprise (formerly ART-IM)
line 148: au BufNewFile,BufRead *.art^I^I^Isetf art
line 149: 
line 150: " AsciiDoc
line 151: au BufNewFile,BufRead *.asciidoc,*.adoc^I^Isetf asciidoc
line 152: 
line 153: " ASN.1
line 154: au BufNewFile,BufRead *.asn,*.asn1^I^Isetf asn
line 155: 
line 156: " Active Server Pages (with Visual Basic Script)
line 157: au BufNewFile,BufRead *.asa if exists("g:filetype_asa") |   exe "setf " . g:filetype_asa | else |   setf aspvbs | endif
line 163: 
line 164: " Active Server Pages (with Perl or Visual Basic Script)
line 165: au BufNewFile,BufRead *.asp if exists("g:filetype_asp") |   exe "setf " . g:filetype_asp | elseif getline(1) . getline(2) . getline(3) =~? "perlscript" |   setf aspperl | else |   setf aspvbs | endif
line 173: 
line 174: " Grub (must be before pattern *.lst)
line 175: au BufNewFile,BufRead */boot/grub/menu.lst,*/boot/grub/grub.conf,*/etc/grub.conf setf grub
line 176: 
line 177: " Maxima, see:
line 178: " https://maxima.sourceforge.io/docs/manual/maxima_71.html#file_005ftype_005fmaxima
line 179: " Must be before the pattern *.mac.
line 180: " *.dem omitted - also used by gnuplot demos
line 181: " *.mc omitted - used by dist#ft#McSetf()
line 182: au BufNewFile,BufRead *.demo,*.dm{1,2,3,t},*.wxm,maxima-init.mac setf maxima
line 183: 
line 184: " Assembly (all kinds)
line 185: " *.lst is not pure assembly, it has two extra columns (address, byte codes)
line 186: " *.[sS], *.[aA] usually Assembly - GNU
line 187: au BufNewFile,BufRead *.asm,*.[sS],*.[aA],*.mac,*.lst^Icall dist#ft#FTasm()
line 188: 
line 189: " Assembly - Netwide
line 190: au BufNewFile,BufRead *.nasm^I^I^Isetf nasm
line 191: 
line 192: " Assembly - Microsoft
line 193: au BufNewFile,BufRead *.masm^I^I^Isetf masm
line 194: 
line 195: " Assembly - Macro (VAX)
line 196: au BufNewFile,BufRead *.mar^I^I^Isetf vmasm
line 197: 
line 198: " Astro
line 199: au BufNewFile,BufRead *.astro^I^I^Isetf astro
line 200: 
line 201: " Atlas
line 202: au BufNewFile,BufRead *.atl,*.as^I^Isetf atlas
line 203: 
line 204: " Atom is based on XML
line 205: au BufNewFile,BufRead *.atom^I^I^Isetf xml
line 206: 
line 207: " Authzed
line 208: au BufNewFile,BufRead *.zed^I^I^Isetf authzed
line 209: 
line 210: " Autoit v3
line 211: au BufNewFile,BufRead *.au3^I^I^Isetf autoit
line 212: 
line 213: " Autohotkey
line 214: au BufNewFile,BufRead *.ahk^I^I^Isetf autohotkey
line 215: 
line 216: " Autotest .at files are actually m4
line 217: au BufNewFile,BufRead *.at^I^I^Isetf m4
line 218: 
line 219: " Avenue
line 220: au BufNewFile,BufRead *.ave^I^I^Isetf ave
line 221: 
line 222: " Awk
line 223: au BufNewFile,BufRead *.awk,*.gawk^I^Isetf awk
line 224: 
line 225: " B
line 226: au BufNewFile,BufRead *.mch,*.ref,*.imp^I^Isetf b
line 227: 
line 228: " BASIC or Visual Basic
line 229: au BufNewFile,BufRead *.bas^I^I^Icall dist#ft#FTbas()
line 230: au BufNewFile,BufRead *.bi,*.bm^I^I^Icall dist#ft#FTbas()
line 231: 
line 232: " Bass
line 233: au BufNewFile,BufRead *.bass^I^I^Isetf bass
line 234: 
line 235: " IBasic file (similar to QBasic)
line 236: au BufNewFile,BufRead *.iba,*.ibi^I^Isetf ibasic
line 237: 
line 238: " FreeBasic file (similar to QBasic)
line 239: au BufNewFile,BufRead *.fb^I^I^Isetf freebasic
line 240: 
line 241: " Batch file for MSDOS. See dist#ft#FTsys for *.sys
line 242: au BufNewFile,BufRead *.bat^I^I^Isetf dosbatch
line 243: " *.cmd is close to a Batch file, but on OS/2 Rexx files and TI linker command files also use *.cmd.
line 244: " lnk: `/* comment */`, `// comment`, and `--linker-option=value`
line 245: " rexx: `/* comment */`, `-- comment`
line 246: au BufNewFile,BufRead *.cmd  if join(getline(1, 20), "\n") =~ 'MEMORY\|SECTIONS\|\%(^\|\n\)--\S\|\%(^\|\n\)//'|   setf lnk| elseif getline(1) =~ '^/\*'|   setf rexx| else|   setf dosbatch| endif
line 254: " ABB RAPID or Batch file for MSDOS.
line 255: au BufNewFile,BufRead *.sys^I^I^Icall dist#ft#FTsys()
line 256: if has("fname_case")
line 257:   au BufNewFile,BufRead *.Sys,*.SYS^I^Icall dist#ft#FTsys()
line 258: endif
line 259: au BufNewFile,BufRead *.sysx^I^I^Isetf rapid
line 260: if has("fname_case")
line 261:   au BufNewFile,BufRead *.sysX,*.Sysx,*.SysX,*.SYSX,*.SYSx^Isetf rapid
line 262: endif
line 263: 
line 264: " Batch file for 4DOS
line 265: au BufNewFile,BufRead *.btm^I^I^Icall dist#ft#FTbtm()
line 266: 
line 267: " BC calculator
line 268: au BufNewFile,BufRead *.bc^I^I^Isetf bc
line 269: 
line 270: " BDF font
line 271: au BufNewFile,BufRead *.bdf^I^I^Isetf bdf
line 272: 
line 273: " Beancount
line 274: au BufNewFile,BufRead *.beancount^I^Isetf beancount
line 275: 
line 276: " BibTeX bibliography database file
line 277: au BufNewFile,BufRead *.bib^I^I^Isetf bib
line 278: 
line 279: " BibTeX Bibliography Style
line 280: au BufNewFile,BufRead *.bst^I^I^Isetf bst
line 281: 
line 282: " Bicep
line 283: au BufNewFile,BufRead *.bicep,*.bicepparam^I^I^Isetf bicep
line 284: 
line 285: " BIND configuration
line 286: " sudoedit uses namedXXXX.conf
line 287: au BufNewFile,BufRead named*.conf,rndc*.conf,rndc*.key^Isetf named
line 288: 
line 289: " BIND zone
line 290: au BufNewFile,BufRead named.root^I^Isetf bindzone
line 291: au BufNewFile,BufRead *.zone^I^I^Isetf bindzone
line 292: au BufNewFile,BufRead *.db^I^I^Icall dist#ft#BindzoneCheck('')
line 293: 
line 294: " Blade
line 295: au BufNewFile,BufRead *.blade.php^I^Isetf blade
line 296: 
line 297: " Blank
line 298: au BufNewFile,BufRead *.bl^I^I^Isetf blank
line 299: 
line 300: " Bitbake
line 301: au BufNewFile,BufRead *.bb,*.bbappend,*.bbclass,*/build/conf/*.conf,*/meta{-*,}/conf/*.conf,*/project-spec/configs/*.conf^Isetf bitbake
line 302: 
line 303: " Blkid cache file
line 304: au BufNewFile,BufRead */etc/blkid.tab,*/etc/blkid.tab.old   setf xml
line 305: 
line 306: " BSDL
line 307: au BufNewFile,BufRead *.bsd,*.bsdl^I^I^Isetf bsdl
line 308: 
line 309: " Bazel (https://bazel.build) and Buck2 (https://buck2.build/)
line 310: autocmd BufRead,BufNewFile *.bzl,*.bazel,WORKSPACE,WORKSPACE.bzlmod^Isetf bzl
line 311: if has("fname_case")
line 312:   " There is another check for BUILD and BUCK further below.
line 313:   autocmd BufRead,BufNewFile *.BUILD,BUILD,BUCK^I^Isetf bzl
line 314: endif
line 315: 
line 316: " Busted (Lua unit testing framework - configuration files)
line 317: au BufNewFile,BufRead .busted^I^I^Isetf lua
line 318: 
line 319: " Bun history
line 320: au BufNewFile,BufRead .bun_repl_history^I^Isetf javascript
line 321: 
line 322: " Bundle config
line 323: au BufNewFile,BufRead */.bundle/config^I^I^Isetf yaml
line 324: 
line 325: " C or lpc
line 326: au BufNewFile,BufRead *.c^I^I^Icall dist#ft#FTlpc()
line 327: au BufNewFile,BufRead *.lpc,*.ulpc^I^Isetf lpc
line 328: 
line 329: " C3
line 330: au BufNewFile,BufRead *.c3,*.c3i,*.c3t^I^Isetf c3
line 331: 
line 332: " Cairo
line 333: au BufNewFile,BufRead *.cairo^I^I^Isetf cairo
line 334: 
line 335: " Calendar
line 336: au BufNewFile,BufRead calendar^I^I^Isetf calendar
line 337: 
line 338: " Cap'n Proto
line 339: au BufNewFile,BufRead *.capnp^I^I^Isetf capnp
line 340: 
line 341: " Cgdb config file
line 342: au BufNewFile,BufRead cgdbrc^I^I^Isetf cgdbrc
line 343: 
line 344: " C#
line 345: au BufNewFile,BufRead *.cs,*.csx,*.cake^I^Isetf cs
line 346: 
line 347: " CSDL
line 348: au BufNewFile,BufRead *.csdl^I^I^Isetf csdl
line 349: 
line 350: " Ctags
line 351: au BufNewFile,BufRead *.ctags^I^I^Isetf conf
line 352: 
line 353: " Cabal
line 354: au BufNewFile,BufRead *.cabal^I^I^Isetf cabal
line 355: 
line 356: " Cdrdao TOC or LaTeX \tableofcontents files
line 357: au BufNewFile,BufRead *.toc if getline(1) =~# '\\contentsline' |setf tex|else|setf cdrtoc|endif
line 359: 
line 360: " Cdrdao config
line 361: au BufNewFile,BufRead */etc/cdrdao.conf,*/etc/defaults/cdrdao,*/etc/default/cdrdao,.cdrdao^Isetf cdrdaoconf
line 362: 
line 363: " Cedar
line 364: au BufNewFile,BufRead *.cedar^I^I^Isetf cedar
line 365: 
line 366: " Cfengine
line 367: au BufNewFile,BufRead cfengine.conf^I^Isetf cfengine
line 368: 
line 369: " ChaiScript
line 370: au BufRead,BufNewFile *.chai^I^I^Isetf chaiscript
line 371: 
line 372: " Chatito
line 373: au BufNewFile,BufRead *.chatito^I^I^Isetf chatito
line 374: 
line 375: " Chktex
line 376: au BufRead,BufNewFile .chktexrc^I^I^Isetf conf
line 377: 
line 378: " Chuck
line 379: au BufNewFile,BufRead *.ck^I^I^Isetf chuck
line 380: 
line 381: " Comshare Dimension Definition Language
line 382: au BufNewFile,BufRead *.cdl^I^I^Isetf cdl
line 383: 
line 384: " Conary Recipe
line 385: au BufNewFile,BufRead *.recipe^I^I^Isetf conaryrecipe
line 386: 
line 387: " Corn config file
line 388: au BufNewFile,BufRead *.corn^I^I^Isetf corn
line 389: 
line 390: " ChainPack Object Notation (CPON)
line 391: au BufNewFile,BufRead *.cpon^I^I^Isetf cpon
line 392: 
line 393: " Controllable Regex Mutilator
line 394: au BufNewFile,BufRead *.crm^I^I^Isetf crm
line 395: 
line 396: " Cyn++
line 397: au BufNewFile,BufRead *.cyn^I^I^Isetf cynpp
line 398: 
line 399: " Cynlib
line 400: " .cc and .cpp files can be C++ or Cynlib.
line 401: au BufNewFile,BufRead *.cc if exists("cynlib_syntax_for_cc")|setf cynlib|else|setf cpp|endif
line 403: au BufNewFile,BufRead *.cpp if exists("cynlib_syntax_for_cpp")|setf cynlib|else|setf cpp|endif
line 405: 
line 406: " Cypher query language
line 407: au BufNewFile,BufRead *.cypher^I^I^Isetf cypher
line 408: 
line 409: " C++
line 410: au BufNewFile,BufRead *.cxx,*.c++,*.hh,*.hxx,*.hpp,*.ipp,*.moc,*.tcc,*.inl setf cpp
line 411: if has("fname_case")
line 412: ^Iau BufNewFile,BufRead *.C,*.H if !&fileignorecase | setf cpp | endif
line 413: endif
line 414: 
line 415: " C++ 20 modules (clang)
line 416: " https://clang.llvm.org/docs/StandardCPlusPlusModules.html#file-name-requirement
line 417: au BufNewFile,BufRead *.cppm,*.ccm,*.cxxm,*.c++m setf cpp
line 418: 
line 419: " .h files can be C, Ch C++, ObjC or ObjC++.
line 420: " Set c_syntax_for_h if you want C, ch_syntax_for_h if you want Ch. ObjC is
line 421: " detected automatically.
line 422: au BufNewFile,BufRead *.h^I^I^Icall dist#ft#FTheader()
line 423: 
line 424: " Ch (CHscript)
line 425: au BufNewFile,BufRead *.chf^I^I^Isetf ch
line 426: 
line 427: " TLH files are C++ headers generated by Visual C++'s #import from typelibs
line 428: au BufNewFile,BufRead *.tlh^I^I^Isetf cpp
line 429: 
line 430: " Cascading Style Sheets
line 431: au BufNewFile,BufRead *.css^I^I^Isetf css
line 432: 
line 433: " Century Term Command Scripts (*.cmd too)
line 434: au BufNewFile,BufRead *.con^I^I^Isetf cterm
line 435: 
line 436: " Changelog
line 437: au BufNewFile,BufRead changelog.Debian,changelog.dch,NEWS.Debian,NEWS.dch,*/debian/changelog^Isetf debchangelog
line 439: 
line 440: au BufNewFile,BufRead [cC]hange[lL]og  if getline(1) =~ '; urgency='|   setf debchangelog| else|   setf changelog| endif
line 446: 
line 447: au BufNewFile,BufRead NEWS  if getline(1) =~ '; urgency='|   setf debchangelog| endif
line 451: 
line 452: " CHILL
line 453: au BufNewFile,BufRead *..ch^I^I^Isetf chill
line 454: 
line 455: " Changes for WEB and CWEB or CHILL
line 456: au BufNewFile,BufRead *.ch^I^I^Icall dist#ft#FTchange()
line 457: 
line 458: " ChordPro
line 459: au BufNewFile,BufRead *.chopro,*.crd,*.cho,*.crdpro,*.chordpro^Isetf chordpro
line 460: 
line 461: " Clangd
line 462: au BufNewFile,BufRead .clangd^I^I^Isetf yaml
line 463: 
line 464: " Clang-format
line 465: au BufNewFile,BufRead .clang-format^I^Isetf yaml
line 466: 
line 467: " Clang-tidy
line 468: au BufNewFile,BufRead .clang-tidy^I^Isetf yaml
line 469: 
line 470: " Conda configuration file
line 471: au BufNewFile,BufRead .condarc,condarc^I^Isetf yaml
line 472: 
line 473: " Matplotlib
line 474: au BufNewFile,BufRead *.mplstyle,matplotlibrc^Isetf yaml
line 475: 
line 476: " Clean
line 477: au BufNewFile,BufRead *.dcl,*.icl^I^Isetf clean
line 478: 
line 479: " Clever
line 480: au BufNewFile,BufRead *.eni^I^I^Isetf cl
line 481: 
line 482: " Clever or dtd
line 483: au BufNewFile,BufRead *.ent^I^I^Icall dist#ft#FTent()
line 484: 
line 485: " Cling
line 486: au BufNewFile,BufRead .cling_history^I^Isetf cpp
line 487: 
line 488: " Clipper, FoxPro, ABB RAPID or eviews
line 489: au BufNewFile,BufRead *.prg^I^I^Icall dist#ft#FTprg()
line 490: if has("fname_case")
line 491:   au BufNewFile,BufRead *.Prg,*.PRG^I^I^Icall dist#ft#FTprg()
line 492: endif
line 493: 
line 494: " Clojure
line 495: au BufNewFile,BufRead *.clj,*.cljs,*.cljx,*.cljc^I^Isetf clojure
line 496: 
line 497: " Cmake
line 498: au BufNewFile,BufRead CMakeLists.txt,*.cmake,*.cmake.in^I^Isetf cmake
line 499: 
line 500: " CmakeCache
line 501: autocmd BufRead,BufNewFile CMakeCache.txt^I^I^Isetf cmakecache
line 502: 
line 503: " Cmusrc
line 504: au BufNewFile,BufRead */.cmus/{autosave,rc,command-history,*.theme} setf cmusrc
line 505: au BufNewFile,BufRead */cmus/{rc,*.theme}^I^I^Isetf cmusrc
line 506: 
line 507: " Cobol
line 508: au BufNewFile,BufRead *.cbl,*.cob^Isetf cobol
line 509: "   cobol or zope form controller python script? (heuristic)
line 510: au BufNewFile,BufRead *.cpy if getline(1) =~ '^##' |   setf python | else |   setf cobol | endif
line 516: 
line 517: " Coco/R
line 518: au BufNewFile,BufRead *.atg^I^I^Isetf coco
line 519: 
line 520: " Cold Fusion
line 521: au BufNewFile,BufRead *.cfm,*.cfi,*.cfc^I^Isetf cf
line 522: 
line 523: " Configure scripts
line 524: au BufNewFile,BufRead configure.in,configure.ac setf config
line 525: 
line 526: " Cooklang
line 527: au BufNewFile,BufRead *.cook^I^I^Isetf cook
line 528: 
line 529: " Clinical Quality Language (CQL)
line 530: " .cql is also mentioned as the 'XDCC Catcher queue list' file extension.
line 531: " If support for XDCC Catcher is needed in the future, the contents of the file
line 532: " needs to be inspected.
line 533: au BufNewFile,BufRead *.cql^I^I^Isetf cqlang
line 534: 
line 535: " Crystal
line 536: au BufNewFile,BufRead *.cr^I^I^Isetf crystal
line 537: 
line 538: " CSV Files
line 539: au BufNewFile,BufRead *.csv^I^I^Isetf csv
line 540: 
line 541: " CUDA Compute Unified Device Architecture
line 542: au BufNewFile,BufRead *.cu,*.cuh^I^Isetf cuda
line 543: 
line 544: " Cue
line 545: au BufNewFile,BufRead *.cue^I^I^Isetf cue
line 546: 
line 547: " Debian devscripts
line 548: au BufNewFile,BufRead devscripts.conf,.devscripts^Isetf sh
line 549: 
line 550: " Dockerfile; Podman uses the same syntax with name Containerfile
line 551: " Also see Dockerfile.* below.
line 552: au BufNewFile,BufRead Containerfile,Dockerfile,dockerfile,*.[dD]ockerfile^Isetf dockerfile
line 553: 
line 554: " WildPackets EtherPeek Decoder
line 555: au BufNewFile,BufRead *.dcd^I^I^Isetf dcd
line 556: 
line 557: " Enlightenment configuration files
line 558: au BufNewFile,BufRead *enlightenment/*.cfg^Isetf c
line 559: 
line 560: " Eterm
line 561: au BufNewFile,BufRead *Eterm/*.cfg^I^Isetf eterm
line 562: 
line 563: " Elixir or Euphoria
line 564: au BufNewFile,BufRead *.ex call dist#ft#ExCheck()
line 565: 
line 566: " Elixir
line 567: au BufRead,BufNewFile mix.lock,*.exs setf elixir
line 568: au BufRead,BufNewFile *.eex,*.leex setf eelixir
line 569: 
line 570: " Elvish
line 571: au BufRead,BufNewFile *.elv setf elvish
line 572: 
line 573: " Euphoria 3 or 4
line 574: au BufNewFile,BufRead *.eu,*.ew,*.exu,*.exw  call dist#ft#EuphoriaCheck()
line 575: if has("fname_case")
line 576:    au BufNewFile,BufRead *.EU,*.EW,*.EX,*.EXU,*.EXW  call dist#ft#EuphoriaCheck()
line 577: endif
line 578: 
line 579: " Execline (s6) scripts
line 580: au BufNewFile,BufRead *s6*/\(up\|down\|run\|finish\)    setf execline
line 581: au BufNewFile,BufRead s6-*                              setf execline
line 582: 
line 583: " Fontconfig config files
line 584: au BufNewFile,BufRead fonts.conf^I^I^Isetf xml
line 585: 
line 586: " Faust
line 587: au BufNewFile,BufRead *.lib^I^I^I^Isetf faust
line 588: au BufNewFile,BufRead *.dsp^I^I^I^Icall dist#ft#FTdsp()
line 589: 
line 590: " Libreoffice config files
line 591: au BufNewFile,BufRead *.xcu,*.xlb,*.xlc,*.xba^I^Isetf xml
line 592: au BufNewFile,BufRead psprint.conf,sofficerc^I^Isetf dosini
line 593: 
line 594: " Libtool files
line 595: au BufNewFile,BufRead *.lo,*.la,*.lai^I^Isetf sh
line 596: 
line 597: " Lynx config files
line 598: au BufNewFile,BufRead lynx.cfg^I^I^Isetf lynx
line 599: 
line 600: " LyRiCs
line 601: au BufNewFile,BufRead *.lrc^I^I^Isetf lyrics
line 602: 
line 603: " MLIR
line 604: au BufNewFile,BufRead *.mlir^I^I^Isetf mlir
line 605: 
line 606: " Modula-3 configuration language (must be before *.cfg and *makefile)
line 607: au BufNewFile,BufRead *.quake,cm3.cfg^I^Isetf m3quake
line 608: au BufNewFile,BufRead m3makefile,m3overrides^Isetf m3build
line 609: 
line 610: " XDG mimeapps.list
line 611: au BufNewFile,BufRead mimeapps.list^Isetf dosini
line 612: 
line 613: " Many tools written in Python use dosini as their config
line 614: " like setuptools, pudb, coverage, pypi, gitlint, oelint-adv, pylint, bpython, mypy
line 615: " (must be before *.cfg)
line 616: au BufNewFile,BufRead pip.conf,setup.cfg,pudb.cfg,.coveragerc,.pypirc,.gitlint,.oelint.cfg^Isetf dosini
line 617: au BufNewFile,BufRead {.,}pylintrc,*/bpython/config,*/mypy/config^I^I^Isetf dosini
line 618: 
line 619: " Many tools written in Python use toml as their config, like black
line 620: au BufNewFile,BufRead .black^Isetf toml
line 621: au BufNewFile,BufRead black  if getline(1) =~ 'tool.back'|   setf toml| endif
line 625: 
line 626: " LXQt's programs use dosini as their config
line 627: au BufNewFile,BufRead */{lxqt,screengrab}/*.conf^Isetf dosini
line 628: 
line 629: " Quake
line 630: au BufNewFile,BufRead *baseq[2-3]/*.cfg,*id1/*.cfg^Isetf quake
line 631: au BufNewFile,BufRead *quake[1-3]/*.cfg^I^I^Isetf quake
line 632: 
line 633: " Quake C
line 634: au BufNewFile,BufRead *.qc^I^I^Isetf c
line 635: 
line 636: " LaTeX packages use LaTeX as their configuration, such as:
line 637: " ~/.texlive/texmf-config/tex/latex/hyperref/hyperref.cfg
line 638: " ~/.texlive/texmf-config/tex/latex/docstrip/docstrip.cfg
line 639: au BufNewFile,BufRead */tex/latex/**.cfg^I^Isetf tex
line 640: 
line 641: " Wakatime config
line 642: au BufNewFile,BufRead .wakatime.cfg^I^Isetf dosini
line 643: 
line 644: " Configure files
line 645: au BufNewFile,BufRead *.cfg^I^I^Icall dist#ft#FTcfg()
line 646: if has("fname_case")
line 647:   au BufNewFile,BufRead *.Cfg,*.CFG^I^I^Icall dist#ft#FTcfg()
line 648: endif
line 649: 
line 650: " Cucumber
line 651: au BufNewFile,BufRead *.feature^I^I^Isetf cucumber
line 652: 
line 653: " Communicating Sequential Processes
line 654: au BufNewFile,BufRead *.csp,*.fdr^I^Isetf csp
line 655: 
line 656: " CUPL logic description and simulation
line 657: au BufNewFile,BufRead *.pld^I^I^Isetf cupl
line 658: au BufNewFile,BufRead *.si^I^I^Isetf cuplsim
line 659: 
line 660: " Dafny
line 661: au BufNewFile,BufRead *.dfy^I^I^Isetf dafny
line 662: 
line 663: " Dart
line 664: au BufRead,BufNewfile *.dart,*.drt^I^Isetf dart
line 665: 
line 666: " Debian Control
line 667: au BufNewFile,BufRead */{debian,DEBIAN}/control^I^Isetf debcontrol
line 668: au BufNewFile,BufRead control  if getline(1) =~ '^Source:\|^Package:'|   setf debcontrol| endif
line 672: 
line 673: " Debian Copyright
line 674: au BufNewFile,BufRead */debian/copyright^Isetf debcopyright
line 675: au BufNewFile,BufRead copyright  if getline(1) =~ '^Format:'|   setf debcopyright| endif
line 679: 
line 680: " Debian Sources.list
line 681: au BufNewFile,BufRead */etc/apt/sources.list^I^Isetf debsources
line 682: au BufNewFile,BufRead */etc/apt/sources.list.d/*.list^Isetf debsources
line 683: au BufNewFile,BufRead */etc/apt/sources.list.d/*.sources^Isetf deb822sources
line 684: 
line 685: " Deno history
line 686: au BufNewFile,BufRead deno_history.txt^I^Isetf javascript
line 687: 
line 688: " Deny hosts
line 689: au BufNewFile,BufRead denyhosts.conf^I^Isetf denyhosts
line 690: 
line 691: " Dhall
line 692: au BufNewFile,BufRead *.dhall^I^I^Isetf dhall
line 693: 
line 694: " dnsmasq(8) configuration files
line 695: au BufNewFile,BufRead */etc/dnsmasq.conf^Isetf dnsmasq
line 696: 
line 697: " ROCKLinux package description
line 698: au BufNewFile,BufRead *.desc^I^I^Isetf desc
line 699: 
line 700: " the D language or dtrace
line 701: au BufNewFile,BufRead */dtrace/*.d^I^Isetf dtrace
line 702: au BufNewFile,BufRead *.d^I^I^Icall dist#ft#DtraceCheck()
line 703: 
line 704: " Desktop files
line 705: au BufNewFile,BufRead *.desktop,*.directory^Isetf desktop
line 706: 
line 707: " Dict config
line 708: au BufNewFile,BufRead dict.conf,.dictrc^I^Isetf dictconf
line 709: 
line 710: " Dictd config
line 711: au BufNewFile,BufRead dictd*.conf^I^Isetf dictdconf
line 712: 
line 713: " DEP3 formatted patch files
line 714: au BufNewFile,BufRead */debian/patches/*^Icall dist#ft#Dep3patch()
line 715: 
line 716: " Diff files
line 717: au BufNewFile,BufRead *.diff,*.rej^I^Isetf diff
line 718: au BufNewFile,BufRead *.patch if getline(1) =~# '^From [0-9a-f]\{40,\} Mon Sep 17 00:00:00 2001$' |   setf gitsendemail | else |   setf diff | endif
line 724: 
line 725: " Dircolors
line 726: au BufNewFile,BufRead .dir_colors,.dircolors,*/etc/DIR_COLORS^Isetf dircolors
line 727: 
line 728: " Diva (with Skill) or InstallShield
line 729: au BufNewFile,BufRead *.rul if getline(1).getline(2).getline(3).getline(4).getline(5).getline(6) =~? 'InstallShield' |   setf ishd | else |   setf diva | endif
line 735: 
line 736: " DCL (Digital Command Language - vms) or DNS zone file
line 737: au BufNewFile,BufRead *.com^I^I^Icall dist#ft#BindzoneCheck('dcl')
line 738: 
line 739: " DOT
line 740: au BufNewFile,BufRead *.dot,*.gv^I^Isetf dot
line 741: 
line 742: " Dune
line 743: au BufNewFile,BufRead jbuild,dune,dune-project,dune-workspace,dune-file setf dune
line 744: 
line 745: " Dylan - lid files
line 746: au BufNewFile,BufRead *.lid^I^I^Isetf dylanlid
line 747: 
line 748: " Dylan - intr files (melange)
line 749: au BufNewFile,BufRead *.intr^I^I^Isetf dylanintr
line 750: 
line 751: " Dylan
line 752: au BufNewFile,BufRead *.dylan^I^I^Isetf dylan
line 753: 
line 754: " Microsoft Module Definition or Modula-2
line 755: au BufNewFile,BufRead *.def^I^I^Icall dist#ft#FTdef()
line 756: 
line 757: if has("fname_case")
line 758:   au BufNewFile,BufRead *.DEF^I^I^Isetf modula2
line 759: endif
line 760: 
line 761: " Dracula
line 762: au BufNewFile,BufRead *.drac,*.drc,*.lvs,*.lpe^Isetf dracula
line 763: 
line 764: " Datascript
line 765: au BufNewFile,BufRead *.ds^I^I^Isetf datascript
line 766: 
line 767: " dsl: DSSSL or Structurizr
line 768: au BufNewFile,BufRead *.dsl if getline(1) =~ '^\s*<\!' |   setf dsl | else |   setf structurizr | endif
line 774: 
line 775: " DTD (Document Type Definition for XML)
line 776: au BufNewFile,BufRead *.dtd^I^I^Isetf dtd
line 777: 
line 778: " Devicetree (.its for U-Boot Flattened Image Trees, .keymap for ZMK keymap, and
line 779: " .overlay for Zephyr overlay)
line 780: au BufNewFile,BufRead *.dts,*.dtsi,*.dtso^Isetf dts
line 781: au BufNewFile,BufRead *.its^I^I^Isetf dts
line 782: au BufNewFile,BufRead *.keymap^I^I^Isetf dts
line 783: au BufNewFile,BufRead *.overlay^I^I^Isetf dts
line 784: 
line 785: " Earthfile
line 786: au BufNewFile,BufRead Earthfile^I^I^Isetf earthfile
line 787: 
line 788: " EDIF (*.edf,*.edif,*.edn,*.edo) or edn
line 789: au BufNewFile,BufRead *.ed\(f\|if\|o\)^I^Isetf edif
line 790: au BufNewFile,BufRead *.edn if getline(1) =~ '^\s*(\s*edif\>' |   setf edif | else |   setf clojure | endif
line 796: 
line 797: " EditorConfig
line 798: au BufNewFile,BufRead .editorconfig^I^Isetf editorconfig
line 799: 
line 800: " Embedix Component Description
line 801: au BufNewFile,BufRead *.ecd^I^I^Isetf ecd
line 802: 
line 803: " Eiffel or Specman or Euphoria
line 804: au BufNewFile,BufRead *.e,*.E^I^I^Icall dist#ft#FTe()
line 805: 
line 806: " Elinks configuration
line 807: au BufNewFile,BufRead elinks.conf^I^Isetf elinks
line 808: 
line 809: " ERicsson LANGuage; Yaws is erlang too
line 810: au BufNewFile,BufRead *.erl,*.hrl,*.yaws^Isetf erlang
line 811: 
line 812: " Elm
line 813: au BufNewFile,BufRead *.elm^I^I^Isetf elm
line 814: 
line 815: " Elm Filter Rules file
line 816: au BufNewFile,BufRead filter-rules^I^Isetf elmfilt
line 817: 
line 818: " Elsa - https://github.com/ucsd-progsys/elsa
line 819: au BufNewFile,BufRead *.lc^I^I^Isetf elsa
line 820: 
line 821: " EdgeDB Schema Definition Language
line 822: au BufNewFile,BufRead *.esdl^I^I^Isetf esdl
line 823: 
line 824: " ESMTP rc file
line 825: au BufNewFile,BufRead *esmtprc^I^I^Isetf esmtprc
line 826: 
line 827: " ESQL-C
line 828: au BufNewFile,BufRead *.ec,*.EC^I^I^Isetf esqlc
line 829: 
line 830: " Esterel
line 831: au BufNewFile,BufRead *.strl^I^I^Isetf esterel
line 832: 
line 833: " Essbase script
line 834: au BufNewFile,BufRead *.csc^I^I^Isetf csc
line 835: 
line 836: " Exim
line 837: au BufNewFile,BufRead exim.conf^I^I^Isetf exim
line 838: 
line 839: " Expect
line 840: au BufNewFile,BufRead *.exp^I^I^Isetf expect
line 841: 
line 842: " Exports
line 843: au BufNewFile,BufRead exports^I^I^Isetf exports
line 844: 
line 845: " Falcon
line 846: au BufNewFile,BufRead *.fal^I^I^Isetf falcon
line 847: 
line 848: " Fantom
line 849: au BufNewFile,BufRead *.fan,*.fwt^I^Isetf fan
line 850: 
line 851: " Factor
line 852: au BufNewFile,BufRead *.factor^I^I^Isetf factor
line 853: 
line 854: " Fennel
line 855: autocmd BufRead,BufNewFile *.fnl,{,.}fennelrc^Isetf fennel
line 856: 
line 857: " Fetchmail RC file
line 858: au BufNewFile,BufRead .fetchmailrc^I^Isetf fetchmail
line 859: 
line 860: " FIRRTL - Flexible Internal Representation for RTL
line 861: au BufNewFile,BufRead *.fir^I^I^Isetf firrtl
line 862: 
line 863: " Fish shell
line 864: au BufNewFile,BufRead *.fish^I^I^Isetf fish
line 865: 
line 866: " Flatpak config
line 867: au BufNewFile,BufRead */flatpak/repo/config^Isetf dosini
line 868: 
line 869: " Focus Executable
line 870: au BufNewFile,BufRead *.fex,*.focexec^I^Isetf focexec
line 871: 
line 872: " Focus Master file (but not for auto.master)
line 873: au BufNewFile,BufRead auto.master^I^Isetf conf
line 874: au BufNewFile,BufRead *.mas,*.master^I^Isetf master
line 875: 
line 876: " Forth
line 877: au BufNewFile,BufRead *.ft,*.fth,*.4th^I^Isetf forth
line 878: 
line 879: " Reva Forth
line 880: au BufNewFile,BufRead *.frt^I^I^Isetf reva
line 881: 
line 882: " Fortran
line 883: if has("fname_case")
line 884:   au BufNewFile,BufRead *.F,*.FOR,*.FPP,*.FTN,*.F77,*.F90,*.F95,*.F03,*.F08^Isetf fortran
line 885: endif
line 886: au BufNewFile,BufRead *.for,*.fortran,*.fpp,*.ftn,*.f77,*.f90,*.f95,*.f03,*.f08^Isetf fortran
line 887: 
line 888: " Fortran or Forth
line 889: au BufNewFile,BufRead *.f^I^I^Icall dist#ft#FTf()
line 890: 
line 891: " Framescript
line 892: au BufNewFile,BufRead *.fsl^I^I^Isetf framescript
line 893: 
line 894: " FStab
line 895: au BufNewFile,BufRead fstab,mtab^I^Isetf fstab
line 896: 
line 897: " Func
line 898: au BufNewFile,BufRead *.fc^I^I^Isetf func
line 899: 
line 900: " Fusion
line 901: au BufRead,BufNewFile *.fusion^I^I^Isetf fusion
line 902: 
line 903: " F# or Forth
line 904: au BufNewFile,BufRead *.fs^I^I^Icall dist#ft#FTfs()
line 905: 
line 906: " FHIR Shorthand (FSH)
line 907: au BufNewFile,BufRead *.fsh^I^I^Isetf fsh
line 908: 
line 909: " F#
line 910: au BufNewFile,BufRead *.fsi,*.fsx^I^Isetf fsharp
line 911: 
line 912: " GDB command files
line 913: au BufNewFile,BufRead .gdbinit,gdbinit,.gdbearlyinit,gdbearlyinit,*.gdb^I^Isetf gdb
line 914: 
line 915: " GDMO
line 916: au BufNewFile,BufRead *.mo,*.gdmo^I^Isetf gdmo
line 917: 
line 918: " GDscript
line 919: au BufNewFile,BufRead *.gd^I^I^Isetf gdscript
line 920: 
line 921: " Godot resource
line 922: au BufRead,BufNewFile *.tscn,*.tres^I^Isetf gdresource
line 923: 
line 924: " Godot shader
line 925: au BufRead,BufNewFile *.gdshader,*.shader^Isetf gdshader
line 926: 
line 927: " Gedcom
line 928: au BufNewFile,BufRead *.ged,lltxxxxx.txt^Isetf gedcom
line 929: 
line 930: " Gemtext
line 931: au BufNewFile,BufRead *.gmi,*.gemini^I^Isetf gemtext
line 932: 
line 933: " Gift (Moodle)
line 934: autocmd BufRead,BufNewFile *.gift^I^Isetf gift
line 935: 
line 936: " Git
line 937: au BufNewFile,BufRead COMMIT_EDITMSG,MERGE_MSG,TAG_EDITMSG^Isetf gitcommit
line 938: au BufNewFile,BufRead NOTES_EDITMSG,EDIT_DESCRIPTION^I^Isetf gitcommit
line 939: au BufNewFile,BufRead *.git/config,.gitconfig,*/etc/gitconfig^Isetf gitconfig
line 940: au BufNewFile,BufRead */.config/git/config^I^I^Isetf gitconfig
line 941: au BufNewFile,BufRead *.git/config.worktree^I^I^Isetf gitconfig
line 942: au BufNewFile,BufRead *.git/worktrees/*/config.worktree^I^Isetf gitconfig
line 943: au BufNewFile,BufRead .gitmodules,*.git/modules/*/config^Isetf gitconfig
line 944: if exists('$XDG_CONFIG_HOME')
line 945:   au BufNewFile,BufRead $XDG_CONFIG_HOME/git/config^I^Isetf gitconfig
line 946:   au BufNewFile,BufRead $XDG_CONFIG_HOME/git/attributes^I^Isetf gitattributes
line 947:   au BufNewFile,BufRead $XDG_CONFIG_HOME/git/ignore^I^Isetf gitignore
line 948: endif
line 949: au BufNewFile,BufRead .gitattributes,*.git/info/attributes^Isetf gitattributes
line 950: au BufNewFile,BufRead */.config/git/attributes^I^I^Isetf gitattributes
line 951: au BufNewFile,BufRead */etc/gitattributes^I^I^Isetf gitattributes
line 952: au BufNewFile,BufRead .gitignore,*.git/info/exclude^I^Isetf gitignore
line 953: au BufNewFile,BufRead */.config/git/ignore,*.prettierignore^Isetf gitignore
line 954: au BufNewFile,BufRead */.config/fd/ignore,.fdignore,.ignore^Isetf gitignore
line 955: au BufNewFile,BufRead .rgignore,.dockerignore^I^I^Isetf gitignore
line 956: au BufNewFile,BufRead .npmignore,.vscodeignore^I^I^Isetf gitignore
line 957: au BufNewFile,BufRead git-rebase-todo^I^I^I^Isetf gitrebase
line 958: au BufRead,BufNewFile .gitsendemail.msg.??????^I^I^Isetf gitsendemail
line 959: au BufNewFile,BufRead *.git/* if getline(1) =~# '^\x\{40,\}\>\|^ref: ' |   setf git | endif
line 963: 
line 964: " Gkrellmrc
line 965: au BufNewFile,BufRead gkrellmrc,gkrellmrc_?^Isetf gkrellmrc
line 966: 
line 967: " Gleam
line 968: au BufNewFile,BufRead *.gleam^I^I^Isetf gleam
line 969: 
line 970: " GLSL
line 971: " Extensions supported by Khronos reference compiler (with one exception, ".glsl")
line 972: " https://github.com/KhronosGroup/glslang
line 973: au BufNewFile,BufRead *.vert,*.tesc,*.tese,*.glsl,*.geom,*.frag,*.comp,*.rgen,*.rmiss,*.rchit,*.rahit,*.rint,*.rcall^Isetf glsl
line 974: 
line 975: " GN (generate ninja) files
line 976: au BufNewFile,BufRead *.gn,*.gni^I^Isetf gn
line 977: 
line 978: " GP scripts (2.0 and onward)
line 979: au BufNewFile,BufRead *.gp,.gprc^I^Isetf gp
line 980: 
line 981: " GPG
line 982: au BufNewFile,BufRead */.gnupg/options^I^Isetf gpg
line 983: au BufNewFile,BufRead */.gnupg/gpg.conf^I^Isetf gpg
line 984: au BufNewFile,BufRead */usr/*/gnupg/options.skel setf gpg
line 985: if !empty($GNUPGHOME)
line 986:   au BufNewFile,BufRead $GNUPGHOME/options^Isetf gpg
line 987:   au BufNewFile,BufRead $GNUPGHOME/gpg.conf^Isetf gpg
line 988: endif
line 989: 
line 990: " gnash(1) configuration files
line 991: au BufNewFile,BufRead gnashrc,.gnashrc,gnashpluginrc,.gnashpluginrc setf gnash
line 992: 
line 993: " Gitolite
line 994: au BufNewFile,BufRead gitolite.conf^I^Isetf gitolite
line 995: au BufNewFile,BufRead {,.}gitolite.rc,example.gitolite.rc^Isetf perl
line 996: 
line 997: " Glimmer-flavored TypeScript and JavaScript
line 998: au BufNewFile,BufRead *.gts^I^I^Isetf typescript.glimmer
line 999: au BufNewFile,BufRead *.gjs^I^I^Isetf javascript.glimmer
line 1000: 
line 1001: " Gnuplot scripts
line 1002: au BufNewFile,BufRead *.gpi,*.gnuplot,.gnuplot_history^Isetf gnuplot
line 1003: 
line 1004: " Go (Google)
line 1005: au BufNewFile,BufRead *.go^I^I^Isetf go
line 1006: au BufNewFile,BufRead Gopkg.lock^I^Isetf toml
line 1007: au BufRead,BufNewFile go.work^I^I^Isetf gowork
line 1008: 
line 1009: " GoAccess configuration
line 1010: au BufNewFile,BufRead goaccess.conf^I^Isetf goaccess
line 1011: 
line 1012: " GrADS scripts
line 1013: au BufNewFile,BufRead *.gs^I^I^Isetf grads
line 1014: 
line 1015: " GraphQL
line 1016: au BufNewFile,BufRead *.graphql,*.graphqls,*.gql^I^I^Isetf graphql
line 1017: 
line 1018: " Gretl
line 1019: au BufNewFile,BufRead *.gretl^I^I^Isetf gretl
line 1020: 
line 1021: " Groovy
line 1022: au BufNewFile,BufRead *.gradle,*.groovy,Jenkinsfile^I^Isetf groovy
line 1023: 
line 1024: " GNU Server Pages
line 1025: au BufNewFile,BufRead *.gsp^I^I^Isetf gsp
line 1026: 
line 1027: " Group file
line 1028: au BufNewFile,BufRead */etc/group,*/etc/group-,*/etc/group.edit,*/etc/gshadow,*/etc/gshadow-,*/etc/gshadow.edit,*/var/backups/group.bak,*/var/backups/gshadow.bak  setf group
line 1029: 
line 1030: " GTK RC
line 1031: au BufNewFile,BufRead .gtkrc,gtkrc^I^Isetf gtkrc
line 1032: 
line 1033: " GYP
line 1034: au BufNewFile,BufRead *.gyp,*.gypi^I^Isetf gyp
line 1035: 
line 1036: " Hack
line 1037: au BufRead,BufNewFile *.hack,*.hackpartial^I^I^Isetf hack
line 1038: 
line 1039: " Haml
line 1040: au BufNewFile,BufRead *.haml^I^I^Isetf haml
line 1041: 
line 1042: " Hamster Classic | Playground files
line 1043: au BufNewFile,BufRead *.hsm^I^I^Isetf hamster
line 1044: 
line 1045: " Handlebars
line 1046: au BufNewFile,BufRead *.hbs^I^I^Isetf handlebars
line 1047: 
line 1048: " Hare
line 1049: au BufNewFile,BufRead *.ha^I^I^Isetf hare
line 1050: au BufNewFile,BufRead README^I^I^Icall dist#ft#FTharedoc()
line 1051: 
line 1052: " Haskell
line 1053: au BufNewFile,BufRead *.hs,*.hsc,*.hs-boot,*.hsig setf haskell
line 1054: au BufNewFile,BufRead *.lhs^I^I^Isetf lhaskell
line 1055: au BufNewFile,BufRead *.chs^I^I^Isetf chaskell
line 1056: au BufNewFile,BufRead cabal.project^I^Isetf cabalproject
line 1057: au BufNewFile,BufRead */{.,}cabal/config^Isetf cabalconfig
line 1058: au BufNewFile,BufRead cabal.config^I^Isetf cabalconfig
line 1059: au BufNewFile,BufRead *.persistentmodels^Isetf haskellpersistent
line 1060: 
line 1061: " Haste
line 1062: au BufNewFile,BufRead *.ht^I^I^Isetf haste
line 1063: au BufNewFile,BufRead *.htpp^I^I^Isetf hastepreproc
line 1064: 
line 1065: " HCL
line 1066: au BufRead,BufNewFile *.hcl^I^I^Isetf hcl
line 1067: 
line 1068: " Go checksum file (must be before *.sum Hercules)
line 1069: au BufNewFile,BufRead go.sum,go.work.sum^Isetf gosum
line 1070: 
line 1071: " Hercules
line 1072: au BufNewFile,BufRead *.vc,*.ev,*.sum,*.errsum^Isetf hercules
line 1073: 
line 1074: " HEEx
line 1075: au BufRead,BufNewFile *.heex^I^I^Isetf heex
line 1076: 
line 1077: " HEX (Intel)
line 1078: au BufNewFile,BufRead *.hex,*.ihex,*.int,*.ihe,*.ihx,*.mcs,*.h32,*.h80,*.h86,*.a43,*.a90^Isetf hex
line 1079: 
line 1080: " Hjson
line 1081: au BufNewFile,BufRead *.hjson^I^I^Isetf hjson
line 1082: 
line 1083: " HLS Playlist (or another form of playlist)
line 1084: au BufNewFile,BufRead *.m3u,*.m3u8^I^Isetf hlsplaylist
line 1085: 
line 1086: " Hollywood
line 1087: au BufRead,BufNewFile *.hws^I^I^Isetf hollywood
line 1088: 
line 1089: " Hoon
line 1090: au BufRead,BufNewFile *.hoon^I^I^Isetf hoon
line 1091: 
line 1092: " TI Code Composer Studio General Extension Language
line 1093: au BufNewFile,BufRead *.gel^I^I^Isetf gel
line 1094: 
line 1095: " Tilde (must be before HTML)
line 1096: au BufNewFile,BufRead *.t.html^I^I^Isetf tilde
line 1097: 
line 1098: " Translate shell
line 1099: au BufNewFile,BufRead init.trans,*/etc/translate-shell,.trans^Isetf clojure
line 1100: 
line 1101: " HTML (.stm for server side, .shtml is server-side or superhtml)
line 1102: au BufNewFile,BufRead *.html,*.htm,*.shtml,*.stm  call dist#ft#FThtml()
line 1103: au BufNewFile,BufRead *.cshtml^I^I^Isetf html
line 1104: 
line 1105: " HTTP request files
line 1106: au BufNewFile,BufRead *.http^I^I^Isetf http
line 1107: 
line 1108: " HTML with Ruby - eRuby
line 1109: au BufNewFile,BufRead *.erb,*.rhtml^I^Isetf eruby
line 1110: 
line 1111: " HTML with M4
line 1112: au BufNewFile,BufRead *.html.m4^I^I^Isetf htmlm4
line 1113: 
line 1114: " Some template.  Used to be HTML Cheetah.
line 1115: au BufNewFile,BufRead *.tmpl^I^I^Isetf template
line 1116: 
line 1117: " Host config
line 1118: au BufNewFile,BufRead */etc/host.conf^I^Isetf hostconf
line 1119: 
line 1120: " Hosts access
line 1121: au BufNewFile,BufRead */etc/hosts.allow,*/etc/hosts.deny  setf hostsaccess
line 1122: 
line 1123: " Hurl
line 1124: au BufRead,BufNewFile *.hurl^I^I^Isetf hurl
line 1125: 
line 1126: " Hy
line 1127: au BufRead,BufNewFile *.hy,.hy-history^I^Isetf hy
line 1128: 
line 1129: " Hyper Builder
line 1130: au BufNewFile,BufRead *.hb^I^I^Isetf hb
line 1131: 
line 1132: " Hyprland Configuration language
line 1133: au BufNewFile,BufRead */hypr/*.conf,hypr\(land\|paper\|idle\|lock\).conf setf hyprlang
line 1134: 
line 1135: " Httest
line 1136: au BufNewFile,BufRead *.htt,*.htb^I^Isetf httest
line 1137: 
line 1138: " i3
line 1139: au BufNewFile,BufRead */i3/config^I^Isetf i3config
line 1140: au BufNewFile,BufRead */.i3/config^I^Isetf i3config
line 1141: 
line 1142: " sway
line 1143: au BufNewFile,BufRead */sway/config^I^Isetf swayconfig
line 1144: au BufNewFile,BufRead */.sway/config^I^Isetf swayconfig
line 1145: 
line 1146: " Icon
line 1147: au BufNewFile,BufRead *.icn^I^I^Isetf icon
line 1148: 
line 1149: " IDL (Interface Description Language)
line 1150: au BufNewFile,BufRead *.idl^I^I^Icall dist#ft#FTidl()
line 1151: 
line 1152: " Microsoft IDL (Interface Description Language)  Also *.idl
line 1153: " MOF = WMI (Windows Management Instrumentation) Managed Object Format
line 1154: au BufNewFile,BufRead *.odl,*.mof^I^Isetf msidl
line 1155: 
line 1156: " Icewm menu
line 1157: au BufNewFile,BufRead */.icewm/menu^I^Isetf icemenu
line 1158: 
line 1159: " Indent profile (must come before IDL *.pro!)
line 1160: au BufNewFile,BufRead .indent.pro^I^Isetf indent
line 1161: au BufNewFile,BufRead indent.pro^I^Icall dist#ft#ProtoCheck('indent')
line 1162: 
line 1163: " IDL (Interactive Data Language), Prolog, Cproto or zsh module C
line 1164: au BufNewFile,BufRead *.pro^I^I^Icall dist#ft#ProtoCheck('idlang')
line 1165: 
line 1166: " Idris2
line 1167: au BufNewFile,BufRead *.idr^I^I^Isetf idris2
line 1168: au BufNewFile,BufRead *.lidr^I^I^Isetf lidris2
line 1169: 
line 1170: " Indent RC
line 1171: au BufNewFile,BufRead indentrc^I^I^Isetf indent
line 1172: 
line 1173: " Inform
line 1174: au BufNewFile,BufRead *.inf,*.INF^I^Isetf inform
line 1175: 
line 1176: " Initng
line 1177: au BufNewFile,BufRead */etc/initng/*/*.i,*.ii^Isetf initng
line 1178: 
line 1179: " Innovation Data Processing
line 1180: au BufRead,BufNewFile upstream.dat\c,upstream.*.dat\c,*.upstream.dat\c^Isetf upstreamdat
line 1181: au BufRead,BufNewFile fdrupstream.log,upstream.log\c,upstream.*.log\c,*.upstream.log\c,UPSTREAM-*.log\c^Isetf upstreamlog
line 1182: au BufRead,BufNewFile upstreaminstall.log\c,upstreaminstall.*.log\c,*.upstreaminstall.log\c setf upstreaminstalllog
line 1183: au BufRead,BufNewFile usserver.log\c,usserver.*.log\c,*.usserver.log\c^Isetf usserverlog
line 1184: au BufRead,BufNewFile usw2kagt.log\c,usw2kagt.*.log\c,*.usw2kagt.log\c^Isetf usw2kagtlog
line 1185: 
line 1186: " Ipfilter
line 1187: au BufNewFile,BufRead ipf.conf,ipf6.conf,ipf.rules^Isetf ipfilter
line 1188: 
line 1189: " Ipkg for Idris 2 language
line 1190: au BufNewFile,BufRead *.ipkg^I^I^Isetf ipkg
line 1191: 
line 1192: " Informix 4GL (source - canonical, include file, I4GL+M4 preproc.)
line 1193: au BufNewFile,BufRead *.4gl,*.4gh,*.m4gl^Isetf fgl
line 1194: 
line 1195: " .INI file for MSDOS
line 1196: au BufNewFile,BufRead *.ini,*.INI^I^Isetf dosini
line 1197: 
line 1198: " SysV Inittab
line 1199: au BufNewFile,BufRead inittab^I^I^Isetf inittab
line 1200: 
line 1201: " Inko
line 1202: au BufNewFile,BufRead *.inko^I^I^Isetf inko
line 1203: 
line 1204: " Inno Setup
line 1205: au BufNewFile,BufRead *.iss^I^I^Isetf iss
line 1206: 
line 1207: " J
line 1208: au BufNewFile,BufRead *.ijs^I^I^Isetf j
line 1209: 
line 1210: " JAL
line 1211: au BufNewFile,BufRead *.jal,*.JAL^I^Isetf jal
line 1212: 
line 1213: " Jam
line 1214: au BufNewFile,BufRead *.jpl,*.jpr^I^Isetf jam
line 1215: 
line 1216: " Janet
line 1217: au BufNewFile,BufRead *.janet^I^I^Isetf janet
line 1218: 
line 1219: " Java
line 1220: au BufNewFile,BufRead *.java,*.jav,*.jsh^Isetf java
line 1221: 
line 1222: " JavaCC
line 1223: au BufNewFile,BufRead *.jj,*.jjt^I^Isetf javacc
line 1224: 
line 1225: " JavaScript, ECMAScript, ES module script, CommonJS script
line 1226: au BufNewFile,BufRead *.js,*.jsm,*.javascript,*.es,*.mjs,*.cjs   setf javascript
line 1227: au BufNewFile,BufRead .node_repl_history^Isetf javascript
line 1228: 
line 1229: " JavaScript with React
line 1230: au BufNewFile,BufRead *.jsx^I^I^Isetf javascriptreact
line 1231: 
line 1232: " Java Server Pages
line 1233: au BufNewFile,BufRead *.jsp^I^I^Isetf jsp
line 1234: 
line 1235: " Java Properties resource file (note: doesn't catch font.properties.pl)
line 1236: au BufNewFile,BufRead *.properties,*.properties_??,*.properties_??_??^Isetf jproperties
line 1237: " Eclipse preference files use Java Properties syntax
line 1238: au BufNewFile,BufRead org.eclipse.*.prefs^Isetf jproperties
line 1239: 
line 1240: " Jess
line 1241: au BufNewFile,BufRead *.clp^I^I^Isetf jess
line 1242: 
line 1243: " Jgraph
line 1244: au BufNewFile,BufRead *.jgr^I^I^Isetf jgraph
line 1245: 
line 1246: " Jinja
line 1247: au BufNewFile,BufRead *.jinja^I^I^Isetf jinja
line 1248: 
line 1249: " Jujutsu
line 1250: au BufNewFile,BufRead *.jjdescription^I^Isetf jjdescription
line 1251: 
line 1252: " Jovial
line 1253: au BufNewFile,BufRead *.jov,*.j73,*.jovial^Isetf jovial
line 1254: 
line 1255: " Jq
line 1256: au BufNewFile,BufRead *.jq^I^I^Isetf jq
line 1257: 
line 1258: " JSON5
line 1259: au BufNewFile,BufRead *.json5^I^I^Isetf json5
line 1260: 
line 1261: " JSON Patch (RFC 6902)
line 1262: au BufNewFile,BufRead *.json-patch^I^Isetf json
line 1263: 
line 1264: " Geojson is also json
line 1265: au BufNewFile,BufRead *.geojson^I^I^Isetf json
line 1266: 
line 1267: " Jupyter Notebook and jupyterlab config is also json
line 1268: au BufNewFile,BufRead *.ipynb,*.jupyterlab-settings^Isetf json
line 1269: 
line 1270: " Sublime config
line 1271: au BufNewFile,BufRead *.sublime-project,*.sublime-settings,*.sublime-workspace^Isetf json
line 1272: 
line 1273: " Other files that look like json
line 1274: au BufNewFile,BufRead .prettierrc,.firebaserc,.stylelintrc,.lintstagedrc,flake.lock,deno.lock,.swcrc^Isetf json
line 1275: 
line 1276: " JSONC (JSON with comments)
line 1277: au BufNewFile,BufRead *.jsonc,.babelrc,.eslintrc,.jsfmtrc,bun.lock^Isetf jsonc
line 1278: au BufNewFile,BufRead .jshintrc,.jscsrc,.vsconfig,.hintrc,.swrc,[jt]sconfig*.json^Isetf jsonc
line 1279: " Visual Studio Code settings
line 1280: au BufRead,BufNewFile ~/*/{Code,VSCodium}/User/*.json setf jsonc
line 1281: 
line 1282: " JSON
line 1283: au BufNewFile,BufRead *.json,*.jsonp,*.webmanifest^Isetf json
line 1284: 
line 1285: " JSON Lines
line 1286: au BufNewFile,BufRead *.jsonl^I^I^Isetf jsonl
line 1287: 
line 1288: " Jsonnet
line 1289: au BufNewFile,BufRead *.jsonnet,*.libsonnet^Isetf jsonnet
line 1290: 
line 1291: " Julia
line 1292: au BufNewFile,BufRead *.jl^I^I^Isetf julia
line 1293: 
line 1294: " Just
line 1295: au BufNewFile,BufRead \c{,*.}justfile,\c*.just setf just
line 1296: 
line 1297: " KAREL
line 1298: au BufNewFile,BufRead *.kl setf karel
line 1299: if has("fname_case")
line 1300:    au BufNewFile,BufRead *.KL setf karel
line 1301: endif
line 1302: 
line 1303: " KDL
line 1304: au BufNewFile,BufRead *.kdl^I^I^Isetf kdl
line 1305: 
line 1306: " Kixtart
line 1307: au BufNewFile,BufRead *.kix^I^I^Isetf kix
line 1308: 
line 1309: " Kuka Robot Language
line 1310: au BufNewFile,BufRead *.src^I^I^Icall dist#ft#FTsrc()
line 1311: au BufNewFile,BufRead *.dat^I^I^Icall dist#ft#FTdat()
line 1312: au BufNewFile,BufRead *.sub^I^I^Isetf krl
line 1313: if has("fname_case")
line 1314:    au BufNewFile,BufRead *.Src,*.SRC^I^Icall dist#ft#FTsrc()
line 1315:    au BufNewFile,BufRead *.Dat,*.DAT^I^Icall dist#ft#FTdat()
line 1316:    au BufNewFile,BufRead *.Sub,*.SUB^I^Isetf krl
line 1317: endif
line 1318: 
line 1319: " Kimwitu[++]
line 1320: au BufNewFile,BufRead *.k^I^I^Isetf kwt
line 1321: 
line 1322: " Kivy
line 1323: au BufNewFile,BufRead *.kv^I^I^Isetf kivy
line 1324: 
line 1325: " Kotlin
line 1326: au BufNewFile,BufRead *.kt,*.ktm,*.kts^I^Isetf kotlin
line 1327: 
line 1328: " KDE script
line 1329: au BufNewFile,BufRead *.ks^I^I^Isetf kscript
line 1330: 
line 1331: " Kconfig
line 1332: au BufNewFile,BufRead Kconfig,Kconfig.debug,Config.in^Isetf kconfig
line 1333: 
line 1334: " Lace (ISE)
line 1335: au BufNewFile,BufRead *.ace,*.ACE^I^Isetf lace
line 1336: 
line 1337: " Lalrpop
line 1338: au BufNewFile,Bufread *.lalrpop^I^I^Isetf lalrpop
line 1339: 
line 1340: " Larch Shared Language
line 1341: au BufNewFile,BufRead .lsl^I^I^Icall dist#ft#FTlsl()
line 1342: 
line 1343: " Latexmkrc
line 1344: au BufNewFile,BufRead .latexmkrc,latexmkrc^Isetf perl
line 1345: 
line 1346: " Latte
line 1347: au BufNewFile,BufRead *.latte,*.lte^I^Isetf latte
line 1348: 
line 1349: " Limits
line 1350: au BufNewFile,BufRead */etc/limits,*/etc/*limits.conf,*/etc/*limits.d/*.conf^Isetf limits
line 1351: 
line 1352: " LambdaProlog or SML (see dist#ft#FTmod for *.mod)
line 1353: au BufNewFile,BufRead *.sig^I^I^Icall dist#ft#FTsig()
line 1354: 
line 1355: " LDAP configuration
line 1356: au BufNewFile,BufRead ldaprc,.ldaprc,ldap.conf^Isetf ldapconf
line 1357: 
line 1358: " LDAP LDIF
line 1359: au BufNewFile,BufRead *.ldif^I^I^Isetf ldif
line 1360: 
line 1361: " Luadoc, Ldoc (must be before *.ld)
line 1362: au BufNewFile,BufRead config.ld^I^I^Isetf lua
line 1363: 
line 1364: " Ld loader
line 1365: au BufNewFile,BufRead *.ld,*/ldscripts/*^Isetf ld
line 1366: 
line 1367: " Lean
line 1368: au BufNewFile,BufRead *.lean^I^I^Isetf lean
line 1369: 
line 1370: " Ledger
line 1371: au BufRead,BufNewFile *.ldg,*.ledger,*.journal^I^I^Isetf ledger
line 1372: 
line 1373: " lf configuration (lfrc)
line 1374: au BufNewFile,BufRead lfrc^I^I^Isetf lf
line 1375: 
line 1376: " Leo
line 1377: au BufNewFile,BufRead *.leo^I^I^Isetf leo
line 1378: 
line 1379: " Less
line 1380: au BufNewFile,BufRead *.less^I^I^Isetf less
line 1381: 
line 1382: " Lex
line 1383: au BufNewFile,BufRead *.lex,*.l,*.lxx,*.l++^Isetf lex
line 1384: 
line 1385: " Libao
line 1386: au BufNewFile,BufRead */etc/libao.conf,*/.libao^Isetf libao
line 1387: 
line 1388: " Libsensors
line 1389: au BufNewFile,BufRead */etc/sensors.conf,*/etc/sensors3.conf^Isetf sensors
line 1390: 
line 1391: " LFTP
line 1392: au BufNewFile,BufRead lftp.conf,.lftprc,*lftp/rc^Isetf lftp
line 1393: 
line 1394: " Lifelines (or Lex for C++!)
line 1395: au BufNewFile,BufRead *.ll^I^I^Icall dist#ft#FTll()
line 1396: 
line 1397: " Lilo: Linux loader
line 1398: au BufNewFile,BufRead lilo.conf^I^I^Isetf lilo
line 1399: 
line 1400: " Lilypond
line 1401: au BufNewFile,BufRead *.ly,*.ily^I^Isetf lilypond
line 1402: 
line 1403: " Lisp (*.el = ELisp)
line 1404: " *.jl was removed, it's also used for Julia, better skip than guess wrong.
line 1405: if has("fname_case")
line 1406:   au BufNewFile,BufRead *.lsp,*.lisp,*.asd,*.el,*.L,.emacs,.sawfishrc setf lisp
line 1407: else
line 1408:   au BufNewFile,BufRead *.lsp,*.lisp,*.asd,*.el,.emacs,.sawfishrc setf lisp
line 1409: endif
line 1410: 
line 1411: " *.cl = Common Lisp or OpenCL
line 1412: au BufNewFile,BufRead *.cl call dist#ft#FTcl()
line 1413: 
line 1414: " SBCL implementation of Common Lisp
line 1415: au BufNewFile,BufRead sbclrc,.sbclrc^I^Isetf lisp
line 1416: 
line 1417: " Liquidsoap
line 1418: au BufNewFile,BufRead *.liq^I^I^Isetf liquidsoap
line 1419: 
line 1420: " Liquid
line 1421: au BufNewFile,BufRead *.liquid^I^I^Isetf liquid
line 1422: 
line 1423: " Lite
line 1424: au BufNewFile,BufRead *.lite,*.lt^I^Isetf lite
line 1425: 
line 1426: " LiteStep RC files
line 1427: au BufNewFile,BufRead */LiteStep/*/*.rc^I^Isetf litestep
line 1428: 
line 1429: " Livebook
line 1430: au BufNewFile,BufRead *.livemd^I^I^Isetf livebook
line 1431: 
line 1432: " Login access
line 1433: au BufNewFile,BufRead */etc/login.access^Isetf loginaccess
line 1434: 
line 1435: " Login defs
line 1436: au BufNewFile,BufRead */etc/login.defs^I^Isetf logindefs
line 1437: 
line 1438: " Logtalk
line 1439: au BufNewFile,BufRead *.lgt^I^I^Isetf logtalk
line 1440: 
line 1441: " LOTOS
line 1442: au BufNewFile,BufRead *.lotos^I^Isetf lotos
line 1443: 
line 1444: " LOTOS or LaTeX \listoftables files
line 1445: au BufNewFile,BufRead *.lot if getline(1) =~# '\\contentsline' |setf tex|else|setf lotos|endif
line 1447: 
line 1448: " Lout (also: *.lt)
line 1449: au BufNewFile,BufRead *.lou,*.lout^I^Isetf lout
line 1450: 
line 1451: " Lua, Texlua
line 1452: au BufNewFile,BufRead *.lua,*.tlu,.lua_history^Isetf lua
line 1453: 
line 1454: " Luau
line 1455: au BufNewFile,BufRead *.luau^I^Isetf luau
line 1456: 
line 1457: " Luau config
line 1458: au BufNewFile,BufRead .luaurc^I^Isetf jsonc
line 1459: 
line 1460: " Luacheck
line 1461: au BufNewFile,BufRead .luacheckrc^I^Isetf lua
line 1462: 
line 1463: " Luarocks
line 1464: au BufNewFile,BufRead *.rockspec,rock_manifest^Isetf lua
line 1465: 
line 1466: " Linden Scripting Language (Second Life)
line 1467: au BufNewFile,BufRead *.lsl^I^I^Icall dist#ft#FTlsl()
line 1468: 
line 1469: " Lynx style file (or LotusScript!)
line 1470: au BufNewFile,BufRead *.lss^I^I^Isetf lss
line 1471: 
line 1472: " M4
line 1473: au BufNewFile,BufRead *.m4 if expand("<afile>") !~? 'html.m4$\|fvwm2rc' | setf m4 | endif
line 1475: au BufNewFile,BufRead .m4_history^I^Isetf m4
line 1476: 
line 1477: " MaGic Point
line 1478: au BufNewFile,BufRead *.mgp^I^I^Isetf mgp
line 1479: 
line 1480: " Mail (for Elm, trn, mutt, muttng, rn, slrn, neomutt)
line 1481: au BufNewFile,BufRead snd.\d\+,.letter,.letter.\d\+,.followup,.article,.article.\d\+,pico.\d\+,mutt{ng,}-*-\w\+,mutt[[:alnum:]_-]\\\{6\},neomutt-*-\w\+,neomutt[[:alnum:]_-]\\\{6\},ae\d\+.txt,/tmp/SLRN[0-9A-Z.]\+,*.eml setf mail
line 1482: 
line 1483: " Mail aliases
line 1484: au BufNewFile,BufRead */etc/mail/aliases,*/etc/aliases^Isetf mailaliases
line 1485: 
line 1486: " Mailcap configuration file
line 1487: au BufNewFile,BufRead .mailcap,mailcap^I^Isetf mailcap
line 1488: 
line 1489: " Makefile
line 1490: au BufNewFile,BufRead *[mM]akefile,*.mk,*.mak^Icall dist#ft#FTmake()
line 1491: au BufNewFile,BufRead Kbuild^I^I^Isetf make
line 1492: 
line 1493: " MakeIndex
line 1494: au BufNewFile,BufRead *.ist,*.mst^I^Isetf ist
line 1495: 
line 1496: " Mallard
line 1497: au BufNewFile,BufRead *.page^I^I^Isetf mallard
line 1498: 
line 1499: " Manpage
line 1500: au BufNewFile,BufRead *.man^I^I^Isetf man
line 1501: 
line 1502: " Man config
line 1503: au BufNewFile,BufRead */etc/man.conf,man.config^Isetf manconf
line 1504: 
line 1505: " Maple V
line 1506: au BufNewFile,BufRead *.mv,*.mpl,*.mws^I^Isetf maple
line 1507: 
line 1508: " Map (UMN mapserver config file)
line 1509: au BufNewFile,BufRead *.map if getline(1) =~ '^\*\+$' |   setf lnkmap | else |   setf map | endif
line 1515: 
line 1516: " Markdown
line 1517: au BufNewFile,BufRead *.markdown,*.mdown,*.mkd,*.mkdn,*.mdwn,*.md if exists("g:filetype_md") |   exe "setf " . g:filetype_md | else |   setf markdown | endif
line 1523: 
line 1524: " Mason (it used to include *.comp, are those Mason files?)
line 1525: au BufNewFile,BufRead *.mason,*.mhtml^Isetf mason
line 1526: 
line 1527: " Mathematica, Matlab, Murphi, Objective C or Octave
line 1528: au BufNewFile,BufRead *.m^I^I^Icall dist#ft#FTm()
line 1529: 
line 1530: " Mathematica notebook and package files
line 1531: au BufNewFile,BufRead *.nb,*.wl^I^I^Isetf mma
line 1532: 
line 1533: " Maya Extension Language
line 1534: au BufNewFile,BufRead *.mel^I^I^Isetf mel
line 1535: 
line 1536: " mbsync
line 1537: au BufNewFile,BufRead .mbsyncrc^I^I^Isetf conf
line 1538: 
line 1539: " mcmeta
line 1540: au BufNewFile,BufRead *.mcmeta^I^I^Isetf json
line 1541: 
line 1542: " MediaWiki
line 1543: au BufNewFile,BufRead *.mw,*.wiki^I^Isetf mediawiki
line 1544: 
line 1545: " Mercurial (hg) commit file
line 1546: au BufNewFile,BufRead hg-editor-*.txt^I^Isetf hgcommit
line 1547: 
line 1548: " Mercurial config (looks like generic config file)
line 1549: au BufNewFile,BufRead *.hgrc,*hgrc^I^Isetf cfg
line 1550: 
line 1551: " Mermaid
line 1552: au BufNewFile,BufRead *.mmd,*.mmdc,*.mermaid^Isetf mermaid
line 1553: 
line 1554: " Meson Build system config
line 1555: au BufNewFile,BufRead meson.build,meson.options,meson_options.txt setf meson
line 1556: au BufNewFile,BufRead *.wrap^I^I^Isetf dosini
line 1557: 
line 1558: " Messages (logs mostly)
line 1559: au BufNewFile,BufRead */log/{auth,cron,daemon,debug,kern,lpr,mail,messages,news/news,syslog,user}{,.log,.err,.info,.warn,.crit,.notice}{,.[0-9]*,-[0-9]*} setf messages
line 1560: 
line 1561: " Metafont
line 1562: au BufNewFile,BufRead *.mf^I^I^Isetf mf
line 1563: 
line 1564: " MetaPost
line 1565: au BufNewFile,BufRead *.mp^I^I^Isetf mp
line 1566: au BufNewFile,BufRead *.mpxl,*.mpiv,*.mpvi^Ilet b:mp_metafun = 1 | setf mp
line 1567: 
line 1568: " MGL
line 1569: au BufNewFile,BufRead *.mgl^I^I^Isetf mgl
line 1570: 
line 1571: " MIX - Knuth assembly
line 1572: au BufNewFile,BufRead *.mix,*.mixal^I^Isetf mix
line 1573: 
line 1574: " MMIX or VMS makefile
line 1575: au BufNewFile,BufRead *.mms^I^I^Icall dist#ft#FTmms()
line 1576: 
line 1577: " msmtp
line 1578: au BufNewFile,BufRead .msmtprc^I^I^Isetf msmtp
line 1579: 
line 1580: " Symbian meta-makefile definition (MMP)
line 1581: au BufNewFile,BufRead *.mmp^I^I^Isetf mmp
line 1582: 
line 1583: " ABB Rapid, Modula-2, Modsim III or LambdaProlog
line 1584: au BufNewFile,BufRead *.mod^I^I^Icall dist#ft#FTmod()
line 1585: if has("fname_case")
line 1586:    au BufNewFile,BufRead *.Mod,*.MOD^I^Icall dist#ft#FTmod()
line 1587: endif
line 1588: au BufNewFile,BufRead *.modx^I^I^Isetf rapid
line 1589: if has("fname_case")
line 1590:    au BufNewFile,BufRead *.modX,*.Modx,*.ModX,*.MODX,*.MODx^Isetf rapid
line 1591: endif
line 1592: 
line 1593: " Modula-3 (.m3, .i3, .mg, .ig)
line 1594: au BufNewFile,BufRead *.[mi][3g]^I^Isetf modula3
line 1595: 
line 1596: " Larch/Modula-3
line 1597: au BufNewFile,BufRead *.lm3^I^I^Isetf modula3
line 1598: 
line 1599: " Modconf
line 1600: au BufNewFile,BufRead */etc/modules.conf,*/etc/modules,*/etc/conf.modules setf modconf
line 1601: 
line 1602: " Monk
line 1603: au BufNewFile,BufRead *.isc,*.monk,*.ssc,*.tsc^Isetf monk
line 1604: 
line 1605: " MOO
line 1606: au BufNewFile,BufRead *.moo^I^I^Isetf moo
line 1607: 
line 1608: " Moonscript
line 1609: au BufNewFile,BufRead *.moon^I^I^Isetf moonscript
line 1610: 
line 1611: " Move language
line 1612: au BufNewFile,BufRead *.move^I^I^Isetf move
line 1613: 
line 1614: " MPD is based on XML
line 1615: au BufNewFile,BufRead *.mpd^I^I^Isetf xml
line 1616: 
line 1617: " Mplayer config
line 1618: au BufNewFile,BufRead mplayer.conf,*/.mplayer/config^Isetf mplayerconf
line 1619: 
line 1620: " Motorola S record
line 1621: au BufNewFile,BufRead *.s19,*.s28,*.s37,*.mot,*.srec^Isetf srec
line 1622: 
line 1623: " Mrxvtrc
line 1624: au BufNewFile,BufRead mrxvtrc,.mrxvtrc^I^Isetf mrxvtrc
line 1625: 
line 1626: " Msql
line 1627: au BufNewFile,BufRead *.msql^I^I^Isetf msql
line 1628: 
line 1629: " Mysql
line 1630: au BufNewFile,BufRead *.mysql,.mysql_history^Isetf mysql
line 1631: 
line 1632: " Tcl Shell RC file
line 1633: au BufNewFile,BufRead tclsh.rc^I^I^Isetf tcl
line 1634: 
line 1635: " M$ Resource files
line 1636: " /etc/Muttrc.d/file.rc is muttrc
line 1637: au BufNewFile,BufRead *.rc,*.rch if expand("<afile>") !~ "/etc/Muttrc.d/" |   setf rc | endif
line 1641: 
line 1642: " Mojo
line 1643: " Mojo files use either .mojo or . as extension
line 1644: au BufNewFile,BufRead *.mojo,*.^I^Isetf mojo
line 1645: 
line 1646: " MuPAD source
line 1647: au BufRead,BufNewFile *.mu^I^I^Isetf mupad
line 1648: 
line 1649: " Mush
line 1650: au BufNewFile,BufRead *.mush^I^I^Isetf mush
line 1651: 
line 1652: " Mustache
line 1653: au BufNewFile,BufRead *.mustache^I^Isetf mustache
line 1654: 
line 1655: " Mutt setup file (also for Muttng)
line 1656: au BufNewFile,BufRead Mutt{ng,}rc^I^Isetf muttrc
line 1657: 
line 1658: " N1QL
line 1659: au BufRead,BufNewfile *.n1ql,*.nql^I^Isetf n1ql
line 1660: 
line 1661: " Neomutt log
line 1662: au BufNewFile,BufRead *.neomuttdebug*^I^Isetf neomuttlog
line 1663: 
line 1664: " Nano
line 1665: au BufNewFile,BufRead */etc/nanorc,*.nanorc^Isetf nanorc
line 1666: 
line 1667: " Nastran input/DMAP
line 1668: "au BufNewFile,BufRead *.dat^I^I^Isetf nastran
line 1669: 
line 1670: " Natural
line 1671: au BufNewFile,BufRead *.NS[ACGLMNPS]^I^Isetf natural
line 1672: 
line 1673: " Noemutt setup file
line 1674: au BufNewFile,BufRead Neomuttrc^I^I^Isetf neomuttrc
line 1675: 
line 1676: " Netrc
line 1677: au BufNewFile,BufRead .netrc^I^I^Isetf netrc
line 1678: 
line 1679: " Neofetch
line 1680: au BufNewFile,BufRead */neofetch/config.conf^Isetf sh
line 1681: 
line 1682: " Nginx
line 1683: au BufNewFile,BufRead *.nginx,nginx*.conf,*nginx.conf,*/etc/nginx/*,*/usr/local/nginx/conf/*,*/nginx/*.conf^I^I^Isetf nginx
line 1684: 
line 1685: " Nim file
line 1686: au BufNewFile,BufRead *.nim,*.nims,*.nimble^Isetf nim
line 1687: 
line 1688: " Ninja file
line 1689: au BufNewFile,BufRead *.ninja^I^I^Isetf ninja
line 1690: 
line 1691: " Nix
line 1692: au BufRead,BufNewFile *.nix^I^I^Isetf nix
line 1693: 
line 1694: " Norg
line 1695: au BufNewFile,BufRead *.norg^I^Isetf norg
line 1696: 
line 1697: " NPM RC file
line 1698: au BufNewFile,BufRead npmrc,.npmrc^I^Isetf dosini
line 1699: 
line 1700: " Novell netware batch files
line 1701: au BufNewFile,BufRead *.ncf^I^I^Isetf ncf
line 1702: 
line 1703: " Nroff/Troff (*.ms and *.t are checked below)
line 1704: au BufNewFile,BufRead *.me if expand("<afile>") != "read.me" && expand("<afile>") != "click.me" |   setf nroff | endif
line 1708: au BufNewFile,BufRead *.tr,*.nr,*.roff,*.tmac,*.mom^Isetf nroff
line 1709: au BufNewFile,BufRead *.[1-9]^I^I^Icall dist#ft#FTnroff()
line 1710: 
line 1711: " Nroff or Objective C++
line 1712: au BufNewFile,BufRead *.mm^I^I^Icall dist#ft#FTmm()
line 1713: 
line 1714: " Not Quite C
line 1715: au BufNewFile,BufRead *.nqc^I^I^Isetf nqc
line 1716: 
line 1717: " notmuch
line 1718: au BufNewFile,BufRead .notmuch-config{,.*}^I^Isetf dosini
line 1719: au BufNewFile,BufRead ~/.config/notmuch/*/config^Isetf dosini
line 1720: if exists('$XDG_CONFIG_HOME')
line 1721:   au BufNewFile,BufRead $XDG_CONFIG_HOME/notmuch/*/config setf dosini
line 1722: endif
line 1723: 
line 1724: " NSE - Nmap Script Engine - uses Lua syntax
line 1725: au BufNewFile,BufRead *.nse^I^I^Isetf lua
line 1726: 
line 1727: " NSIS
line 1728: au BufNewFile,BufRead *.nsi,*.nsh^I^Isetf nsis
line 1729: 
line 1730: " Nu
line 1731: au BufNewFile,BufRead *.nu^I^Isetf nu
line 1732: 
line 1733: " Oblivion Language and Oblivion Script Extender
line 1734: au BufNewFile,BufRead *.obl,*.obse,*.oblivion,*.obscript  setf obse
line 1735: 
line 1736: " Objdump
line 1737: au BufNewFile,BufRead *.objdump,*.cppobjdump  setf objdump
line 1738: 
line 1739: " OCaml
line 1740: au BufNewFile,BufRead *.ml,*.mli,*.mll,*.mly,.ocamlinit,*.mlt,*.mlp,*.mlip,*.mli.cppo,*.ml.cppo setf ocaml
line 1741: 
line 1742: " Occam
line 1743: au BufNewFile,BufRead *.occ^I^I^Isetf occam
line 1744: 
line 1745: " Octave
line 1746: au BufNewFile,BufRead octave.conf,.octaverc,octaverc,*/octave/history^Isetf octave
line 1747: 
line 1748: " Odin
line 1749: au BufNewFile,BufRead *.odin^I^I^Isetf odin
line 1750: 
line 1751: " Omnimark
line 1752: au BufNewFile,BufRead *.xom,*.xin^I^Isetf omnimark
line 1753: 
line 1754: " ondir
line 1755: au BufNewFile,BufRead .ondirrc^I^I^Isetf ondir
line 1756: 
line 1757: " OPAM
line 1758: au BufNewFile,BufRead opam,*.opam,*.opam.template,opam.locked,*.opam.locked setf opam
line 1759: 
line 1760: " OpenFOAM
line 1761: au BufNewFile,BufRead [a-zA-Z0-9]*Dict\(.*\)\=,[a-zA-Z]*Properties\(.*\)\=,*Transport\(.*\),fvSchemes,fvSolution,fvConstrains,fvModels,*/constant/g,*/0\(\.orig\)\=/* call dist#ft#FTfoam()
line 1762: 
line 1763: " OpenROAD
line 1764: au BufNewFile,BufRead *.or^I^I^I^Isetf openroad
line 1765: 
line 1766: " OPL
line 1767: au BufNewFile,BufRead *.[Oo][Pp][Ll]^I^I^Isetf opl
line 1768: 
line 1769: " OpenSCAD
line 1770: au BufNewFile,BufRead *.scad^I^I^I^Isetf openscad
line 1771: 
line 1772: " Oracle config file
line 1773: au BufNewFile,BufRead *.ora^I^I^I^Isetf ora
line 1774: 
line 1775: " Org (Emacs' org-mode)
line 1776: au BufNewFile,BufRead *.org,*.org_archive^I^Isetf org
line 1777: 
line 1778: " Packet filter conf
line 1779: au BufNewFile,BufRead pf.conf^I^I^I^Isetf pf
line 1780: 
line 1781: " ini style config files, using # comments
line 1782: au BufNewFile,BufRead pacman.conf,mpv.conf^I^Isetf confini
line 1783: au BufNewFile,BufRead */.aws/config,*/.aws/credentials^Isetf confini
line 1784: au BufNewFile,BufRead *.nmconnection^I^I^Isetf confini
line 1785: au BufNewFile,BufRead paru.conf^I^I^I^Isetf confini
line 1786: 
line 1787: " Pacman hooks
line 1788: au BufNewFile,BufRead *.hook if getline(1) == '[Trigger]' |   setf confini | endif
line 1792: 
line 1793: " Pacman makepkg
line 1794: au BufNewFile,BufRead {.,}makepkg.conf^I^I^Isetf sh
line 1795: 
line 1796: " Pacman log
line 1797: au BufNewFile,BufRead pacman.log^I^I^Isetf pacmanlog
line 1798: 
line 1799: " Pam conf
line 1800: au BufNewFile,BufRead */etc/pam.conf^I^I^Isetf pamconf
line 1801: 
line 1802: " Pam environment
line 1803: au BufNewFile,BufRead pam_env.conf,.pam_environment^Isetf pamenv
line 1804: 
line 1805: " PApp
line 1806: au BufNewFile,BufRead *.papp,*.pxml,*.pxsl^I^Isetf papp
line 1807: 
line 1808: " Password file
line 1809: au BufNewFile,BufRead */etc/passwd,*/etc/passwd-,*/etc/passwd.edit,*/etc/shadow,*/etc/shadow-,*/etc/shadow.edit,*/var/backups/passwd.bak,*/var/backups/shadow.bak setf passwd
line 1810: 
line 1811: " Pascal (also *.p, *.pp, *.inc)
line 1812: au BufNewFile,BufRead *.pas^I^I^I^Isetf pascal
line 1813: 
line 1814: " Pascal or Puppet manifest
line 1815: au BufNewFile,BufRead *.pp^I^I^I^Icall dist#ft#FTpp()
line 1816: 
line 1817: " Delphi
line 1818: au BufNewFile,BufRead *.dpr^I^I^I^Isetf pascal
line 1819: 
line 1820: " Xilinx labtools project file or Lazarus program file
line 1821: au BufNewFile,BufRead *.lpr if getline(1) =~# "<?xml" |   setf xml | else |   setf pascal | endif
line 1827: 
line 1828: " Free Pascal makefile definition file
line 1829: au BufNewFile,BufRead *.fpc^I^I^I^Isetf fpcmake
line 1830: 
line 1831: " Path of Exile item filter
line 1832: au BufNewFile,BufRead *.filter^I^I^I^Isetf poefilter
line 1833: 
line 1834: " PDF
line 1835: au BufNewFile,BufRead *.pdf^I^I^I^Isetf pdf
line 1836: 
line 1837: " PCMK - HAE - crm configure edit
line 1838: au BufNewFile,BufRead *.pcmk^I^I^I^Isetf pcmk
line 1839: 
line 1840: " PEM (Privacy-Enhanced Mail)
line 1841: au BufNewFile,BufRead *.pem,*.cer,*.crt,*.csr^I^Isetf pem
line 1842: 
line 1843: " Perl or Prolog
line 1844: if has("fname_case")
line 1845:   au BufNewFile,BufRead *.pl,*.PL^I^I^Icall dist#ft#FTpl()
line 1846: else
line 1847:   au BufNewFile,BufRead *.pl^I^I^I^Icall dist#ft#FTpl()
line 1848: endif
line 1849: au BufNewFile,BufRead *.plx,*.al,*.psgi^I^I^Isetf perl
line 1850: 
line 1851: " Perl Reply
line 1852: au BufNewFile,BufRead .replyrc^I^I^I^Isetf dosini
line 1853: 
line 1854: " Perl, XPM or XPM2
line 1855: au BufNewFile,BufRead *.pm if getline(1) =~ "XPM2" |   setf xpm2 | elseif getline(1) =~ "XPM" |   setf xpm | else |   setf perl | endif
line 1863: 
line 1864: " Perl POD
line 1865: au BufNewFile,BufRead *.pod^I^I^Isetf pod
line 1866: 
line 1867: " Php, php3, php4, etc.
line 1868: " Also Phtml (was used for PHP 2 in the past).
line 1869: " Also .ctp for Cake template file.
line 1870: " Also .phpt for php tests.
line 1871: " Also .theme for Drupal theme files.
line 1872: au BufNewFile,BufRead *.php,*.php\d,*.phtml,*.ctp,*.phpt,*.theme^Isetf php
line 1873: 
line 1874: " PHP config
line 1875: au BufNewFile,BufRead php.ini-*,php-fpm.conf*,www.conf*^I^Isetf dosini
line 1876: 
line 1877: " Pike and Cmod
line 1878: au BufNewFile,BufRead *.pike,*.pmod^I^Isetf pike
line 1879: au BufNewFile,BufRead *.cmod^I^I^Isetf cmod
line 1880: 
line 1881: " Pinfo config
line 1882: au BufNewFile,BufRead */etc/pinforc,*/.pinforc^Isetf pinfo
line 1883: 
line 1884: " Palm Resource compiler
line 1885: au BufNewFile,BufRead *.rcp^I^I^Isetf pilrc
line 1886: 
line 1887: " Pine config
line 1888: au BufNewFile,BufRead .pinerc,pinerc,.pinercex,pinercex^I^Isetf pine
line 1889: 
line 1890: " Pip requirements
line 1891: au BufNewFile,BufRead *.pip^I^I^Isetf requirements
line 1892: au BufNewFile,BufRead requirements.txt^I^Isetf requirements
line 1893: au BufNewFile,BufRead *-requirements.txt^Isetf requirements
line 1894: au BufNewFile,BufRead constraints.txt^I^Isetf requirements
line 1895: au BufNewFile,BufRead requirements.in^I^Isetf requirements
line 1896: au BufNewFile,BufRead requirements/*.txt^Isetf requirements
line 1897: au BufNewFile,BufRead requires/*.txt^I^Isetf requirements
line 1898: 
line 1899: " Pipenv Pipfiles
line 1900: au BufNewFile,BufRead Pipfile^I^I^Isetf toml
line 1901: au BufNewFile,BufRead Pipfile.lock^I^Isetf json
line 1902: 
line 1903: " Pixi lock
line 1904: au BufNewFile,BufRead pixi.lock^I^I^Isetf yaml
line 1905: 
line 1906: " PL/1, PL/I
line 1907: au BufNewFile,BufRead *.pli,*.pl1^I^Isetf pli
line 1908: 
line 1909: " PL/M (also: *.inp)
line 1910: au BufNewFile,BufRead *.plm,*.p36,*.pac^I^Isetf plm
line 1911: 
line 1912: " PL/SQL
line 1913: au BufNewFile,BufRead *.pls,*.plsql^I^Isetf plsql
line 1914: 
line 1915: " PLP
line 1916: au BufNewFile,BufRead *.plp^I^I^Isetf plp
line 1917: 
line 1918: " PO and PO template (GNU gettext)
line 1919: au BufNewFile,BufRead *.po,*.pot^I^Isetf po
line 1920: 
line 1921: " Pony
line 1922: au BufNewFile,BufRead *.pony^I^I^Isetf pony
line 1923: 
line 1924: " Postfix main config
line 1925: au BufNewFile,BufRead main.cf,main.cf.proto^Isetf pfmain
line 1926: 
line 1927: " PostScript (+ font files, encapsulated PostScript, Adobe Illustrator)
line 1928: au BufNewFile,BufRead *.ps,*.pfa,*.afm,*.eps,*.epsf,*.epsi,*.ai^I  setf postscr
line 1929: 
line 1930: " PostScript Printer Description
line 1931: au BufNewFile,BufRead *.ppd^I^I^Isetf ppd
line 1932: 
line 1933: " Povray
line 1934: au BufNewFile,BufRead *.pov^I^I^Isetf pov
line 1935: 
line 1936: " Povray configuration
line 1937: au BufNewFile,BufRead .povrayrc^I^I^Isetf povini
line 1938: 
line 1939: " Povray, Pascal, PHP or assembly
line 1940: au BufNewFile,BufRead *.inc^I^I^Icall dist#ft#FTinc()
line 1941: 
line 1942: " PowerShell
line 1943: au BufNewFile,BufRead^I*.ps1,*.psd1,*.psm1,*.pssc^Isetf ps1
line 1944: au BufNewFile,BufRead^I*.ps1xml^I^I^Isetf ps1xml
line 1945: au BufNewFile,BufRead^I*.cdxml,*.psc1^I^I^Isetf xml
line 1946: 
line 1947: " Printcap and Termcap
line 1948: au BufNewFile,BufRead *printcap let b:ptcap_type = "print" | setf ptcap
line 1950: au BufNewFile,BufRead *termcap let b:ptcap_type = "term" | setf ptcap
line 1952: 
line 1953: " Prisma
line 1954: au BufRead,BufNewFile *.prisma^I^I^Isetf prisma
line 1955: 
line 1956: " PPWizard
line 1957: au BufNewFile,BufRead *.it,*.ih^I^I^Isetf ppwiz
line 1958: 
line 1959: " Pug
line 1960: au BufRead,BufNewFile *.pug^I^I^Isetf pug
line 1961: 
line 1962: " Puppet
line 1963: au BufNewFile,BufRead Puppetfile^I^Isetf ruby
line 1964: 
line 1965: " Embedded Puppet
line 1966: au BufNewFile,BufRead *.epp^I^I^Isetf epuppet
line 1967: 
line 1968: " Obj 3D file format
line 1969: " TODO: is there a way to avoid MS-Windows Object files?
line 1970: au BufNewFile,BufRead *.obj^I^I^Isetf obj
line 1971: 
line 1972: " Oracle Pro*C/C++
line 1973: au BufNewFile,BufRead *.pc^I^I^Isetf proc
line 1974: 
line 1975: " Privoxy actions file
line 1976: au BufNewFile,BufRead *.action^I^I^Isetf privoxy
line 1977: 
line 1978: " Procmail
line 1979: au BufNewFile,BufRead .procmail,.procmailrc^Isetf procmail
line 1980: 
line 1981: " Progress or CWEB
line 1982: au BufNewFile,BufRead *.w^I^I^Icall dist#ft#FTprogress_cweb()
line 1983: 
line 1984: " Progress or assembly or Swig
line 1985: au BufNewFile,BufRead *.i^I^I^Icall dist#ft#FTi()
line 1986: 
line 1987: " Progress or Pascal
line 1988: au BufNewFile,BufRead *.p^I^I^Icall dist#ft#FTprogress_pascal()
line 1989: 
line 1990: " Software Distributor Product Specification File (POSIX 1387.2-1995)
line 1991: au BufNewFile,BufRead *.psf^I^I^Isetf psf
line 1992: au BufNewFile,BufRead INDEX,INFO if getline(1) =~ '^\s*\(distribution\|installed_software\|root\|bundle\|product\)\s*$' |   setf psf | endif
line 1996: 
line 1997: " Prolog
line 1998: au BufNewFile,BufRead *.pdb^I^I^Isetf prolog
line 1999: 
line 2000: " Promela
line 2001: au BufNewFile,BufRead *.pml^I^I^Isetf promela
line 2002: 
line 2003: " Property Specification Language (PSL)
line 2004: au BufNewFile,BufRead *.psl^I^I^Isetf psl
line 2005: 
line 2006: " Google protocol buffers
line 2007: au BufNewFile,BufRead *.proto^I^I^Isetf proto
line 2008: au BufNewFile,BufRead *.txtpb,*.textproto,*.textpb,*.pbtxt setf pbtxt
line 2009: 
line 2010: " Poke
line 2011: au BufNewFile,BufRead *.pk^I^I^Isetf poke
line 2012: 
line 2013: " Protocols
line 2014: au BufNewFile,BufRead */etc/protocols^I^Isetf protocols
line 2015: 
line 2016: " Nvidia PTX (Parallel Thread Execution)
line 2017: " See https://docs.nvidia.com/cuda/parallel-thread-execution/
line 2018: au BufNewFile,BufRead *.ptx^I^I^Isetf ptx
line 2019: 
line 2020: " Purescript
line 2021: au BufNewFile,BufRead *.purs^I^I^Isetf purescript
line 2022: 
line 2023: " PyPA manifest files
line 2024: au BufNewFile,BufRead MANIFEST.in^I^Isetf pymanifest
line 2025: 
line 2026: " Pyret
line 2027: au BufNewFile,BufRead *.arr^I^I^Isetf pyret
line 2028: 
line 2029: " Pyrex/Cython
line 2030: au BufNewFile,BufRead *.pyx,*.pyx+,*.pxd,*.pxi^Isetf pyrex
line 2031: 
line 2032: " Python, Python Shell Startup and Python Stub Files
line 2033: " Quixote (Python-based web framework)
line 2034: au BufNewFile,BufRead *.py,*.pyw,.pythonstartup,.pythonrc,.python_history,.jline-jython.history^Isetf python
line 2035: au BufNewFile,BufRead *.ptl,*.pyi,SConstruct^I^I   setf python
line 2036: 
line 2037: " QL
line 2038: au BufRead,BufNewFile *.ql,*.qll^I^Isetf ql
line 2039: 
line 2040: " QML
line 2041: au BufRead,BufNewFile *.qml,*.qbs^I^I^Isetf qml
line 2042: 
line 2043: " QMLdir
line 2044: au BufRead,BufNewFile qmldir^I^I^Isetf qmldir
line 2045: 
line 2046: " Quarto
line 2047: au BufRead,BufNewFile *.qmd^I^I^Isetf quarto
line 2048: 
line 2049: " Racket (formerly detected as "scheme")
line 2050: au BufNewFile,BufRead *.rkt,*.rktd,*.rktl^Isetf racket
line 2051: 
line 2052: " Radiance
line 2053: au BufNewFile,BufRead *.rad,*.mat^I^Isetf radiance
line 2054: 
line 2055: " Raku (formerly Perl6)
line 2056: au BufNewFile,BufRead *.pm6,*.p6,*.t6,*.pod6,*.raku,*.rakumod,*.rakudoc,*.rakutest  setf raku
line 2057: 
line 2058: " Ratpoison config/command files
line 2059: au BufNewFile,BufRead .ratpoisonrc,ratpoisonrc^Isetf ratpoison
line 2060: 
line 2061: " RCS file
line 2062: au BufNewFile,BufRead *\,v^I^I^Isetf rcs
line 2063: 
line 2064: " Readline
line 2065: au BufNewFile,BufRead .inputrc,inputrc^I^Isetf readline
line 2066: 
line 2067: " Registry for MS-Windows
line 2068: au BufNewFile,BufRead *.reg if getline(1) =~? '^REGEDIT[0-9]*\s*$\|^Windows Registry Editor Version \d*\.\d*\s*$' | setf registry | endif
line 2070: 
line 2071: " Renderman Interface Bytestream
line 2072: au BufNewFile,BufRead *.rib^I^I^Isetf rib
line 2073: 
line 2074: " Rego Policy Language
line 2075: au BufNewFile,BufRead *.rego^I^I^Isetf rego
line 2076: 
line 2077: " Rexx
line 2078: au BufNewFile,BufRead *.rex,*.orx,*.rxo,*.rxj,*.jrexx,*.rexxj,*.rexx,*.testGroup,*.testUnit^Isetf rexx
line 2079: 
line 2080: " Ripgrep rc
line 2081: au BufNewFile,BufRead {.,}ripgreprc^I^I^Isetf conf
line 2082: 
line 2083: " R Help file
line 2084: if has("fname_case")
line 2085:   au BufNewFile,BufRead *.rd,*.Rd^I^Isetf rhelp
line 2086: else
line 2087:   au BufNewFile,BufRead *.rd^I^I^Isetf rhelp
line 2088: endif
line 2089: 
line 2090: " R noweb file
line 2091: if has("fname_case")
line 2092:   au BufNewFile,BufRead *.Rnw,*.rnw,*.Snw,*.snw^I^Isetf rnoweb
line 2093: else
line 2094:   au BufNewFile,BufRead *.rnw,*.snw^I^I^Isetf rnoweb
line 2095: endif
line 2096: 
line 2097: " R Markdown file
line 2098: if has("fname_case")
line 2099:   au BufNewFile,BufRead *.Rmd,*.rmd,*.Smd,*.smd^I^Isetf rmd
line 2100: else
line 2101:   au BufNewFile,BufRead *.rmd,*.smd^I^I^Isetf rmd
line 2102: endif
line 2103: 
line 2104: " R profile file
line 2105: au BufNewFile,BufRead .Rhistory,.Rprofile,Rprofile,Rprofile.site^Isetf r
line 2106: 
line 2107: " RSS looks like XML
line 2108: au BufNewFile,BufRead *.rss^I^I^I^Isetf xml
line 2109: 
line 2110: " R reStructuredText file
line 2111: if has("fname_case")
line 2112:   au BufNewFile,BufRead *.Rrst,*.rrst,*.Srst,*.srst^Isetf rrst
line 2113: else
line 2114:   au BufNewFile,BufRead *.rrst,*.srst^I^I^Isetf rrst
line 2115: endif
line 2116: 
line 2117: " Rexx, Rebol or R
line 2118: au BufNewFile,BufRead *.r,*.R^I^I^I^Icall dist#ft#FTr()
line 2119: 
line 2120: " Remind
line 2121: au BufNewFile,BufRead .reminders,*.remind,*.rem^I^Isetf remind
line 2122: 
line 2123: " ReScript
line 2124: au BufNewFile,BufRead *.res,*.resi^I^I^Isetf rescript
line 2125: 
line 2126: " Resolv.conf
line 2127: au BufNewFile,BufRead resolv.conf^I^Isetf resolv
line 2128: 
line 2129: " Relax NG Compact
line 2130: au BufNewFile,BufRead *.rnc^I^I^Isetf rnc
line 2131: 
line 2132: " Relax NG XML
line 2133: au BufNewFile,BufRead *.rng^I^I^Isetf rng
line 2134: 
line 2135: " ILE RPG
line 2136: au BufNewFile,BufRead *.rpgle,*.rpgleinc^Isetf rpgle
line 2137: 
line 2138: " RPL/2
line 2139: au BufNewFile,BufRead *.rpl^I^I^Isetf rpl
line 2140: 
line 2141: " Robot Framework
line 2142: au BufNewFile,BufRead *.robot,*.resource^Isetf robot
line 2143: 
line 2144: " Robots.txt
line 2145: au BufNewFile,BufRead robots.txt^I^Isetf robots
line 2146: 
line 2147: " Roc
line 2148: au BufNewFile,BufRead *.roc^I^I^Isetf roc
line 2149: 
line 2150: " RON (Rusty Object Notation)
line 2151: au BufNewFile,BufRead *.ron^I^I^Isetf ron
line 2152: 
line 2153: " MikroTik RouterOS script
line 2154: au BufRead,BufNewFile *.rsc^I^I^Isetf routeros
line 2155: 
line 2156: " Rpcgen
line 2157: au BufNewFile,BufRead *.x^I^I^Isetf rpcgen
line 2158: 
line 2159: " reStructuredText Documentation Format
line 2160: au BufNewFile,BufRead *.rst^I^I^Isetf rst
line 2161: 
line 2162: " RTF
line 2163: au BufNewFile,BufRead *.rtf^I^I^Isetf rtf
line 2164: 
line 2165: " Interactive Ruby shell
line 2166: au BufNewFile,BufRead .irbrc,irbrc,.irb_history,irb_history^Isetf ruby
line 2167: 
line 2168: " Ruby
line 2169: au BufNewFile,BufRead *.rb,*.rbw^I^Isetf ruby
line 2170: 
line 2171: " RubyGems
line 2172: au BufNewFile,BufRead *.gemspec^I^I^Isetf ruby
line 2173: 
line 2174: " RBS (Ruby Signature)
line 2175: au BufNewFile,BufRead *.rbs^I^I^Isetf rbs
line 2176: 
line 2177: " Rackup
line 2178: au BufNewFile,BufRead *.ru^I^I^Isetf ruby
line 2179: 
line 2180: " Bundler
line 2181: au BufNewFile,BufRead Gemfile^I^I^Isetf ruby
line 2182: 
line 2183: " Ruby on Rails
line 2184: au BufNewFile,BufRead *.builder,*.rxml,*.rjs^Isetf ruby
line 2185: 
line 2186: " Rantfile and Rakefile is like Ruby
line 2187: au BufNewFile,BufRead [rR]antfile,*.rant,[rR]akefile,*.rake^Isetf ruby
line 2188: 
line 2189: " Rust
line 2190: au BufNewFile,BufRead *.rs^I^I^Isetf rust
line 2191: au BufNewFile,BufRead Cargo.lock,*/.cargo/config,*/.cargo/credentials^Isetf toml
line 2192: 
line 2193: " S-lang
line 2194: au BufNewFile,BufRead *.sl^I^I^Isetf slang
line 2195: 
line 2196: " Sage
line 2197: au BufNewFile,BufRead *.sage^I^I^Isetf sage
line 2198: 
line 2199: " Samba config
line 2200: au BufNewFile,BufRead smb.conf^I^I^Isetf samba
line 2201: 
line 2202: " SAS script
line 2203: au BufNewFile,BufRead *.sas^I^I^Isetf sas
line 2204: 
line 2205: " Sass
line 2206: au BufNewFile,BufRead *.sass^I^I^Isetf sass
line 2207: 
line 2208: " Sather, TI linear assembly
line 2209: au BufNewFile,BufRead *.sa^I^I^Icall dist#ft#FTsa()
line 2210: 
line 2211: " Scala
line 2212: au BufNewFile,BufRead *.scala^I^I^Isetf scala
line 2213: 
line 2214: " SBT - Scala Build Tool
line 2215: au BufNewFile,BufRead *.sbt^I^I^Isetf sbt
line 2216: 
line 2217: " Slang Shading Language
line 2218: au BufNewFile,BufRead *.slang^I^I^Isetf shaderslang
line 2219: 
line 2220: " Slint
line 2221: au BufNewFile,BufRead *.slint^I^I^Isetf slint
line 2222: 
line 2223: " SuperCollider
line 2224: au BufNewFile,BufRead *.sc^I^I^Icall dist#ft#FTsc()
line 2225: 
line 2226: au BufNewFile,BufRead *.quark^I^I^Isetf supercollider
line 2227: 
line 2228: " scdoc
line 2229: au BufNewFile,BufRead *.scd^I^I^Icall dist#ft#FTscd()
line 2230: 
line 2231: " Scilab
line 2232: au BufNewFile,BufRead *.sci,*.sce^I^Isetf scilab
line 2233: 
line 2234: 
line 2235: " SCSS
line 2236: au BufNewFile,BufRead *.scss^I^I^Isetf scss
line 2237: 
line 2238: " SD: Streaming Descriptors
line 2239: au BufNewFile,BufRead *.sd^I^I^Isetf sd
line 2240: 
line 2241: " SDL
line 2242: au BufNewFile,BufRead *.sdl,*.pr^I^Isetf sdl
line 2243: 
line 2244: " sed
line 2245: au BufNewFile,BufRead *.sed^I^I^Isetf sed
line 2246: 
line 2247: " SubRip
line 2248: au BufNewFile,BufRead *.srt^I^I^Isetf srt
line 2249: 
line 2250: " SubStation Alpha
line 2251: au BufNewFile,BufRead *.ass,*.ssa^I^Isetf ssa
line 2252: 
line 2253: " svelte
line 2254: au BufNewFile,BufRead *.svelte^I^I^Isetf svelte
line 2255: 
line 2256: " Sieve (RFC 3028, 5228)
line 2257: au BufNewFile,BufRead *.siv,*.sieve^I^Isetf sieve
line 2258: 
line 2259: " Sendmail
line 2260: au BufNewFile,BufRead sendmail.cf^I^Isetf sm
line 2261: 
line 2262: " Sendmail .mc files are actually m4.  Could also be MS Message text file or
line 2263: " Maxima.
line 2264: au BufNewFile,BufRead *.mc^I^I^Icall dist#ft#McSetf()
line 2265: 
line 2266: " Services
line 2267: au BufNewFile,BufRead */etc/services^I^Isetf services
line 2268: 
line 2269: " Service Location config
line 2270: au BufNewFile,BufRead */etc/slp.conf^I^Isetf slpconf
line 2271: 
line 2272: " Service Location registration
line 2273: au BufNewFile,BufRead */etc/slp.reg^I^Isetf slpreg
line 2274: 
line 2275: " Service Location SPI
line 2276: au BufNewFile,BufRead */etc/slp.spi^I^Isetf slpspi
line 2277: 
line 2278: " Setserial config
line 2279: au BufNewFile,BufRead */etc/serial.conf^I^Isetf setserial
line 2280: 
line 2281: " SGML
line 2282: au BufNewFile,BufRead *.sgm,*.sgml if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'linuxdoc' |   setf sgmllnx | elseif getline(1) =~ '<!DOCTYPE.*DocBook' || getline(2) =~ '<!DOCTYPE.*DocBook' |   let b:docbk_type = "sgml" |   let b:docbk_ver = 4 |   setf docbk | else |   setf sgml | endif
line 2292: 
line 2293: " SGMLDECL
line 2294: au BufNewFile,BufRead *.decl,*.dcl,*.dec if getline(1).getline(2).getline(3) =~? '^<!SGML' |    setf sgmldecl | endif
line 2298: 
line 2299: " SGML catalog file
line 2300: au BufNewFile,BufRead catalog^I^I^Isetf catalog
line 2301: 
line 2302: " Shell scripts (sh, ksh, bash, bash2, csh); Allow .profile_foo etc.
line 2303: " Gentoo ebuilds and Arch Linux PKGBUILDs are actually bash scripts.
line 2304: " NOTE: Patterns ending in a star are further down, these have lower priority.
line 2305: au BufNewFile,BufRead .bashrc,bashrc,bash.bashrc,.bash[_-]profile,.bash[_-]logout,.bash[_-]aliases,.bash[_-]history,bash-fc[-.],*.ebuild,*.bash,*.eclass,PKGBUILD,*.bats,*.cygport call dist#ft#SetFileTypeSH("bash")
line 2306: au BufNewFile,BufRead .kshrc,*.ksh call dist#ft#SetFileTypeSH("ksh")
line 2307: au BufNewFile,BufRead */etc/profile,.profile,*.sh,*.env{rc,} call dist#ft#SetFileTypeSH(getline(1))
line 2308: " Alpine Linux APKBUILDs are actually POSIX sh scripts with special treatment.
line 2309: au BufNewFile,BufRead APKBUILD^Isetf apkbuild
line 2310: 
line 2311: " Shell script (Arch Linux) or PHP file (Drupal)
line 2312: au BufNewFile,BufRead *.install if getline(1) =~ '<?php' |   setf php | else |   call dist#ft#SetFileTypeSH("bash") | endif
line 2318: 
line 2319: " tcsh scripts (patterns ending in a star further below)
line 2320: au BufNewFile,BufRead .tcshrc,*.tcsh,tcsh.tcshrc,tcsh.login^Icall dist#ft#SetFileTypeShell("tcsh")
line 2321: 
line 2322: " csh scripts, but might also be tcsh scripts (on some systems csh is tcsh)
line 2323: " (patterns ending in a start further below)
line 2324: au BufNewFile,BufRead .login,.cshrc,csh.cshrc,csh.login,csh.logout,*.csh,.alias  call dist#ft#CSH()
line 2325: 
line 2326: " Zig and Zig Object Notation (ZON)
line 2327: au BufNewFile,BufRead *.zig,*.zon^I^Isetf zig
line 2328: 
line 2329: " Ziggy and Ziggy Schema
line 2330: au BufNewFile,BufRead *.ziggy                   setf ziggy
line 2331: au BufNewFile,BufRead *.ziggy-schema            setf ziggy_schema
line 2332: 
line 2333: " Zserio
line 2334: au BufNewFile,BufRead *.zs^I^I^Isetf zserio
line 2335: 
line 2336: " Z-Shell script (patterns ending in a star further below)
line 2337: au BufNewFile,BufRead .zprofile,*/etc/zprofile,.zfbfmarks  setf zsh
line 2338: au BufNewFile,BufRead .zshrc,.zshenv,.zlogin,.zlogout,.zcompdump,.zsh_history setf zsh
line 2339: au BufNewFile,BufRead *.zsh,*.zsh-theme,*.zunit^I^Isetf zsh
line 2340: 
line 2341: " Salt state files
line 2342: au BufNewFile,BufRead *.sls^I^I^Isetf salt
line 2343: 
line 2344: " Scheme, Supertux configuration, Lips.js history ("racket" patterns are now separate, see above)
line 2345: au BufNewFile,BufRead *.scm,*.ss,*.sld,*.stsg,*/supertux2/config,.lips_repl_history^Isetf scheme
line 2346: 
line 2347: " Screen RC
line 2348: au BufNewFile,BufRead .screenrc,screenrc^Isetf screen
line 2349: 
line 2350: " Sexplib
line 2351: au BufNewFile,BufRead *.sexp setf sexplib
line 2352: 
line 2353: " Simula
line 2354: au BufNewFile,BufRead *.sim^I^I^Isetf simula
line 2355: 
line 2356: " SINDA
line 2357: au BufNewFile,BufRead *.sin,*.s85^I^Isetf sinda
line 2358: 
line 2359: " SiSU
line 2360: au BufNewFile,BufRead *.sst,*.ssm,*.ssi,*.-sst,*._sst setf sisu
line 2361: au BufNewFile,BufRead *.sst.meta,*.-sst.meta,*._sst.meta setf sisu
line 2362: 
line 2363: " SKILL
line 2364: au BufNewFile,BufRead *.il,*.ils,*.cdf^I^Isetf skill
line 2365: 
line 2366: " Cadence
line 2367: au BufNewFile,BufRead *.cdc^I^I^Isetf cdc
line 2368: 
line 2369: " SLRN
line 2370: au BufNewFile,BufRead .slrnrc^I^I^Isetf slrnrc
line 2371: au BufNewFile,BufRead *.score^I^I^Isetf slrnsc
line 2372: 
line 2373: " Smali
line 2374: au BufNewFile,BufRead *.smali^I^I^Isetf smali
line 2375: 
line 2376: " Smalltalk
line 2377: au BufNewFile,BufRead *.st^I^I^Isetf st
line 2378: 
line 2379: " Smalltalk (and Rexx, TeX, and Visual Basic)
line 2380: au BufNewFile,BufRead *.cls^I^I^Icall dist#ft#FTcls()
line 2381: 
line 2382: " Smarty templates
line 2383: au BufNewFile,BufRead *.tpl^I^I^Isetf smarty
line 2384: 
line 2385: " SMIL or XML
line 2386: au BufNewFile,BufRead *.smil if getline(1) =~ '<?\s*xml.*?>' |   setf xml | else |   setf smil | endif
line 2392: 
line 2393: " SMIL or SNMP MIB file
line 2394: au BufNewFile,BufRead *.smi if getline(1) =~ '\<smil\>' |   setf smil | else |   setf mib | endif
line 2400: 
line 2401: " SMITH
line 2402: au BufNewFile,BufRead *.smt,*.smith^I^Isetf smith
line 2403: 
line 2404: " Smithy
line 2405: au BufNewFile,BufRead *.smithy^I^I^Isetf smithy
line 2406: 
line 2407: " Snakemake
line 2408: au BufNewFile,BufRead Snakefile,*.smk^I^Isetf snakemake
line 2409: 
line 2410: " Snobol4 and spitbol
line 2411: au BufNewFile,BufRead *.sno,*.spt^I^Isetf snobol4
line 2412: 
line 2413: " SNMP MIB files
line 2414: au BufNewFile,BufRead *.mib,*.my^I^Isetf mib
line 2415: 
line 2416: " Snort Configuration
line 2417: au BufNewFile,BufRead *.hog,snort.conf,vision.conf^Isetf hog
line 2418: au BufNewFile,BufRead *.rules^I^I^Icall dist#ft#FTRules()
line 2419: 
line 2420: " Solidity
line 2421: au BufRead,BufNewFile *.sol^I^I^Isetf solidity
line 2422: 
line 2423: " SPARQL queries
line 2424: au BufNewFile,BufRead *.rq,*.sparql^I^Isetf sparql
line 2425: 
line 2426: " Spec (Linux RPM)
line 2427: au BufNewFile,BufRead *.spec^I^I^Isetf spec
line 2428: 
line 2429: " Speedup (AspenTech plant simulator)
line 2430: au BufNewFile,BufRead *.speedup,*.spdata,*.spd^Isetf spup
line 2431: 
line 2432: " Slice
line 2433: au BufNewFile,BufRead *.ice^I^I^Isetf slice
line 2434: 
line 2435: " Microsoft Visual Studio Solution
line 2436: au BufNewFile,BufRead *.sln^I^I^Isetf solution
line 2437: au BufNewFile,BufRead *.slnf^I^I^Isetf json
line 2438: au BufNewFile,BufRead *.slnx^I^I^Isetf xml
line 2439: 
line 2440: " Spice
line 2441: au BufNewFile,BufRead *.sp,*.spice^I^Isetf spice
line 2442: 
line 2443: " Spyce
line 2444: au BufNewFile,BufRead *.spy,*.spi^I^Isetf spyce
line 2445: 
line 2446: " Squid
line 2447: au BufNewFile,BufRead squid.conf^I^Isetf squid
line 2448: 
line 2449: " SQL for Oracle Designer
line 2450: au BufNewFile,BufRead *.tyb,*.tyc,*.pkb,*.pks^Isetf sql
line 2451: 
line 2452: " *.typ can be either SQL or Typst files
line 2453: au BufNewFile,BufRead *.typ^I^I^Icall dist#ft#FTtyp()
line 2454: 
line 2455: " SQL
line 2456: au BufNewFile,BufRead *.sql^I^I^Icall dist#ft#SQL()
line 2457: au BufNewFile,BufRead .sqlite_history^I^Isetf sql
line 2458: 
line 2459: " SQLJ
line 2460: au BufNewFile,BufRead *.sqlj^I^I^Isetf sqlj
line 2461: 
line 2462: " PRQL
line 2463: au BufNewFile,BufRead *.prql^I^I^Isetf prql
line 2464: 
line 2465: " SQR
line 2466: au BufNewFile,BufRead *.sqr,*.sqi^I^Isetf sqr
line 2467: 
line 2468: " Squirrel
line 2469: au BufNewFile,BufRead *.nut^I^I^Isetf squirrel
line 2470: 
line 2471: " OpenSSH configuration
line 2472: au BufNewFile,BufRead ssh_config,*/.ssh/config,*/.ssh/*.conf^Isetf sshconfig
line 2473: au BufNewFile,BufRead */etc/ssh/ssh_config.d/*.conf^I^Isetf sshconfig
line 2474: 
line 2475: " OpenSSH server configuration
line 2476: au BufNewFile,BufRead sshd_config^I^I^Isetf sshdconfig
line 2477: au BufNewFile,BufRead */etc/ssh/sshd_config.d/*.conf^Isetf sshdconfig
line 2478: 
line 2479: " Starlark
line 2480: au BufNewFile,BufRead *.ipd,*.star,*.starlark^Isetf starlark
line 2481: 
line 2482: " OpenVPN configuration
line 2483: au BufNewFile,BufRead *.ovpn^I^I^Isetf openvpn
line 2484: au BufNewFile,BufRead */openvpn/*/*.conf^Isetf openvpn
line 2485: 
line 2486: " Stata
line 2487: au BufNewFile,BufRead *.ado,*.do,*.imata,*.mata^Isetf stata
line 2488: " Also *.class, but not when it's a Java bytecode file
line 2489: au BufNewFile,BufRead *.class if getline(1) !~ "^\xca\xfe\xba\xbe" | setf stata | endif
line 2491: 
line 2492: " SMCL
line 2493: au BufNewFile,BufRead *.hlp,*.ihlp,*.smcl^Isetf smcl
line 2494: 
line 2495: " Stored Procedures
line 2496: au BufNewFile,BufRead *.stp^I^I^Isetf stp
line 2497: 
line 2498: " Standard ML
line 2499: au BufNewFile,BufRead *.sml^I^I^Isetf sml
line 2500: 
line 2501: " Sratus VOS command macro
line 2502: au BufNewFile,BufRead *.cm^I^I^Isetf voscm
line 2503: 
line 2504: " Sway (programming language)
line 2505: au BufNewFile,BufRead *.sw^I^I^Isetf sway
line 2506: 
line 2507: " Swift
line 2508: au BufNewFile,BufRead *.swift,*.swiftinterface^Isetf swift
line 2509: au BufNewFile,BufRead *.swift.gyb^I^Isetf swiftgyb
line 2510: 
line 2511: " Swift Intermediate Language or SILE
line 2512: au BufNewFile,BufRead *.sil^I^I^Icall dist#ft#FTsil()
line 2513: 
line 2514: " Swig
line 2515: au BufNewFile,BufRead *.swg,*.swig setf swig
line 2516: 
line 2517: " Sysctl
line 2518: au BufNewFile,BufRead */etc/sysctl.conf,*/etc/sysctl.d/*.conf^Isetf sysctl
line 2519: 
line 2520: " Systemd unit files
line 2521: au BufNewFile,BufRead */systemd/*.{automount,dnssd,link,mount,netdev,network,nspawn,path,service,slice,socket,swap,target,timer}^Isetf systemd
line 2522: " Systemd overrides
line 2523: au BufNewFile,BufRead */etc/systemd/*.conf.d/*.conf^Isetf systemd
line 2524: au BufNewFile,BufRead */etc/systemd/system/*.d/*.conf^Isetf systemd
line 2525: au BufNewFile,BufRead */.config/systemd/user/*.d/*.conf^Isetf systemd
line 2526: " Systemd temp files
line 2527: au BufNewFile,BufRead */etc/systemd/system/*.d/.#*^Isetf systemd
line 2528: au BufNewFile,BufRead */etc/systemd/system/.#*^I^Isetf systemd
line 2529: au BufNewFile,BufRead */.config/systemd/user/*.d/.#*^Isetf systemd
line 2530: au BufNewFile,BufRead */.config/systemd/user/.#*^Isetf systemd
line 2531: 
line 2532: " Synopsys Design Constraints
line 2533: au BufNewFile,BufRead *.sdc^I^I^Isetf sdc
line 2534: 
line 2535: " Sudoers
line 2536: au BufNewFile,BufRead */etc/sudoers,sudoers.tmp^Isetf sudoers
line 2537: 
line 2538: " SVG (Scalable Vector Graphics)
line 2539: au BufNewFile,BufRead *.svg^I^I^Isetf svg
line 2540: 
line 2541: " Surface
line 2542: au BufRead,BufNewFile *.sface^I^I^Isetf surface
line 2543: 
line 2544: " LLVM TableGen
line 2545: au BufNewFile,BufRead *.td^I^I^Isetf tablegen
line 2546: 
line 2547: " Tads (or Nroff or Perl test file)
line 2548: au BufNewFile,BufRead *.t if !dist#ft#FTnroff() && !dist#ft#FTperl() | setf tads | endif
line 2550: 
line 2551: " Tags
line 2552: au BufNewFile,BufRead tags^I^I^Isetf tags
line 2553: 
line 2554: " TAK
line 2555: au BufNewFile,BufRead *.tak^I^I^Isetf tak
line 2556: 
line 2557: " Unx Tal
line 2558: au BufNewFile,BufRead *.tal^I^I^Isetf tal
line 2559: 
line 2560: " Task
line 2561: au BufRead,BufNewFile {pending,completed,undo}.data  setf taskdata
line 2562: au BufRead,BufNewFile *.task^I^I^Isetf taskedit
line 2563: 
line 2564: " Tcl (JACL too)
line 2565: au BufNewFile,BufRead *.tcl,*.tm,*.tk,*.itcl,*.itk,*.jacl,.tclshrc,.wishrc,.tclsh-history^Isetf tcl
line 2566: 
line 2567: " Xilinx's xsct and xsdb use tcl
line 2568: au BufNewFile,BufRead .xsctcmdhistory,.xsdbcmdhistory^Isetf tcl
line 2569: 
line 2570: " templ
line 2571: au BufNewFile,BufRead *.templ^I^I^Isetf templ
line 2572: 
line 2573: " Teal
line 2574: au BufRead,BufNewFile *.tl^I^I^Isetf teal
line 2575: 
line 2576: " TealInfo
line 2577: au BufNewFile,BufRead *.tli^I^I^Isetf tli
line 2578: 
line 2579: " Telix Salt
line 2580: au BufNewFile,BufRead *.slt^I^I^Isetf tsalt
line 2581: 
line 2582: " Tera Term Language or Turtle
line 2583: au BufRead,BufNewFile *.ttl if getline(1) =~ '^@\?\(prefix\|base\)' |   setf turtle | else |   setf teraterm | endif
line 2589: 
line 2590: " Terminfo
line 2591: au BufNewFile,BufRead *.ti^I^I^Isetf terminfo
line 2592: 
line 2593: " Terraform variables
line 2594: au BufRead,BufNewFile *.tfvars^I^I^Isetf terraform-vars
line 2595: 
line 2596: " TeX
line 2597: au BufNewFile,BufRead *.latex,*.sty,*.dtx,*.ltx,*.bbl^Isetf tex
line 2598: au BufNewFile,BufRead *.tex^I^I^Icall dist#ft#FTtex()
line 2599: au BufNewFile,BufRead texdoc.cnf^I^Isetf conf
line 2600: 
line 2601: " LaTeX packages will generate some medium LaTeX files during compiling
line 2602: " They should be ignored by .gitignore https://github.com/github/gitignore/blob/main/TeX.gitignore
line 2603: " Sometime we need to view its content for debugging
line 2604: au BufNewFile,BufRead *.{pgf,nlo,nls,thm,eps_tex,pygtex,pygstyle,clo,aux,brf,ind,lof,loe,nav,vrb,ins,tikz,bbx,cbx,beamer}^Isetf tex
line 2605: 
line 2606: " LaTeX files generated by Inkscape
line 2607: au BufNewFile,BufRead *.pdf_tex^I^I^Isetf tex
line 2608: 
line 2609: " ConTeXt
line 2610: au BufNewFile,BufRead *.mkii,*.mkiv,*.mkvi,*.mkxl,*.mklx   setf context
line 2611: 
line 2612: " Texinfo
line 2613: au BufNewFile,BufRead *.texinfo,*.texi,*.txi^Isetf texinfo
line 2614: 
line 2615: " TeX configuration
line 2616: au BufNewFile,BufRead texmf.cnf^I^I^Isetf texmf
line 2617: 
line 2618: " Thrift (Apache)
line 2619: au BufNewFile,BufRead *.thrift^I^I^Isetf thrift
line 2620: 
line 2621: " Tidy config
line 2622: au BufNewFile,BufRead .tidyrc,tidyrc,tidy.conf^Isetf tidy
line 2623: 
line 2624: " TF (TinyFugue) mud client
line 2625: au BufNewFile,BufRead .tfrc,tfrc^I^Isetf tf
line 2626: 
line 2627: " TF (TinyFugue) mud client or terraform
line 2628: au BufNewFile,BufRead *.tf^I^I^Icall dist#ft#FTtf()
line 2629: 
line 2630: " TLA+
line 2631: au BufNewFile,BufRead *.tla^I^I^Isetf tla
line 2632: 
line 2633: " tmux configuration
line 2634: au BufNewFile,BufRead {.,}tmux*.conf^I^Isetf tmux
line 2635: 
line 2636: " TOML
line 2637: au BufNewFile,BufRead *.toml^I^I^Isetf toml
line 2638: 
line 2639: " TPP - Text Presentation Program
line 2640: au BufNewFile,BufRead *.tpp^I^I^Isetf tpp
line 2641: 
line 2642: " TRACE32 Script Language
line 2643: au BufNewFile,BufRead *.cmm,*.t32^I^Isetf trace32
line 2644: 
line 2645: " Treetop
line 2646: au BufRead,BufNewFile *.treetop^I^I^Isetf treetop
line 2647: 
line 2648: " Trustees
line 2649: au BufNewFile,BufRead trustees.conf^I^Isetf trustees
line 2650: 
line 2651: " TSS - Geometry
line 2652: au BufNewFile,BufReadPost *.tssgm^I^Isetf tssgm
line 2653: 
line 2654: " TSS - Optics
line 2655: au BufNewFile,BufReadPost *.tssop^I^Isetf tssop
line 2656: 
line 2657: " TSS - Command Line (temporary)
line 2658: au BufNewFile,BufReadPost *.tsscl^I^Isetf tsscl
line 2659: 
line 2660: " TSV Files
line 2661: au BufNewFile,BufRead *.tsv^I^I^Isetf tsv
line 2662: 
line 2663: " Tutor mode
line 2664: au BufNewFile,BufReadPost *.tutor^I^Isetf tutor
line 2665: 
line 2666: " TWIG files
line 2667: au BufNewFile,BufReadPost *.twig^I^Isetf twig
line 2668: 
line 2669: " TypeScript or Qt translation file (which is XML)
line 2670: au BufNewFile,BufReadPost *.ts if getline(1) =~ '<?xml' |   setf xml | else |   setf typescript | endif
line 2676: au BufNewFile,BufRead .ts_node_repl_history^Isetf typescript
line 2677: 
line 2678: " TypeScript module and common
line 2679: au BufNewFile,BufRead *.mts,*.cts^I^Isetf typescript
line 2680: 
line 2681: " TypeScript with React
line 2682: au BufNewFile,BufRead *.tsx^I^I^Isetf typescriptreact
line 2683: 
line 2684: " TypeSpec files
line 2685: au BufNewFile,BufRead *.tsp^I^I^Isetf typespec
line 2686: 
line 2687: " Motif UIT/UIL files
line 2688: au BufNewFile,BufRead *.uit,*.uil^I^Isetf uil
line 2689: 
line 2690: " Udev conf
line 2691: au BufNewFile,BufRead */etc/udev/udev.conf^Isetf udevconf
line 2692: 
line 2693: " Udev permissions
line 2694: au BufNewFile,BufRead */etc/udev/permissions.d/*.permissions setf udevperm
line 2695: "
line 2696: " Udev symlinks config
line 2697: au BufNewFile,BufRead */etc/udev/cdsymlinks.conf^Isetf sh
line 2698: 
line 2699: " Ungrammar, AKA Un-grammar
line 2700: au BufNewFile,BufRead *.ungram^I^I^Isetf ungrammar
line 2701: 
line 2702: " UnrealScript
line 2703: au BufNewFile,BufRead *.uc^I^I^Isetf uc
line 2704: 
line 2705: " Updatedb
line 2706: au BufNewFile,BufRead */etc/updatedb.conf^Isetf updatedb
line 2707: 
line 2708: " Upstart (init(8)) config files
line 2709: au BufNewFile,BufRead */usr/share/upstart/*.conf^I       setf upstart
line 2710: au BufNewFile,BufRead */usr/share/upstart/*.override^I       setf upstart
line 2711: au BufNewFile,BufRead */etc/init/*.conf,*/etc/init/*.override  setf upstart
line 2712: au BufNewFile,BufRead */.init/*.conf,*/.init/*.override^I       setf upstart
line 2713: au BufNewFile,BufRead */.config/upstart/*.conf^I^I       setf upstart
line 2714: au BufNewFile,BufRead */.config/upstart/*.override^I       setf upstart
line 2715: 
line 2716: " URL shortcut
line 2717: au BufNewFile,BufRead *.url^I^I^Isetf urlshortcut
line 2718: 
line 2719: " V
line 2720: au BufNewFile,BufRead *.vsh,*.vv^I^I^Isetf v
line 2721: 
line 2722: " Vala
line 2723: au BufNewFile,BufRead *.vala^I^I^Isetf vala
line 2724: 
line 2725: " VDF
line 2726: au BufNewFile,BufRead *.vdf^I^I^Isetf vdf
line 2727: 
line 2728: " VDM
line 2729: au BufRead,BufNewFile *.vdmpp,*.vpp^I^Isetf vdmpp
line 2730: au BufRead,BufNewFile *.vdmrt^I^I^Isetf vdmrt
line 2731: au BufRead,BufNewFile *.vdmsl,*.vdm^I^Isetf vdmsl
line 2732: 
line 2733: " Vento
line 2734: au BufNewFile,BufRead *.vto^I^I^Isetf vento
line 2735: 
line 2736: " Vera
line 2737: au BufNewFile,BufRead *.vr,*.vri,*.vrh^I^Isetf vera
line 2738: 
line 2739: " Vagrant (uses Ruby syntax)
line 2740: au BufNewFile,BufRead Vagrantfile^I^Isetf ruby
line 2741: 
line 2742: " Verilog HDL, V or Coq
line 2743: au BufNewFile,BufRead *.v^I^I^Icall dist#ft#FTv()
line 2744: 
line 2745: " Verilog-AMS HDL
line 2746: au BufNewFile,BufRead *.va,*.vams^I^Isetf verilogams
line 2747: 
line 2748: " SystemVerilog
line 2749: au BufNewFile,BufRead *.sv,*.svh^I^Isetf systemverilog
line 2750: 
line 2751: " VHS tape
line 2752: " .tape is also used by TapeCalc, which we do not support ATM.  If TapeCalc
line 2753: " support is needed the contents of the file needs to be inspected.
line 2754: au BufNewFile,BufRead *.tape^I^I^Isetf vhs
line 2755: 
line 2756: " VHDL
line 2757: au BufNewFile,BufRead *.hdl,*.vhd,*.vhdl,*.vbe,*.vst,*.vho  setf vhdl
line 2758: 
line 2759: " Vim script
line 2760: au BufNewFile,BufRead *.vim,.exrc,_exrc,.netrwhist^Isetf vim
line 2761: 
line 2762: " Viminfo file
line 2763: au BufNewFile,BufRead .viminfo,_viminfo^I^Isetf viminfo
line 2764: 
line 2765: " Virata Config Script File or Drupal module
line 2766: au BufRead,BufNewFile *.hw,*.module,*.pkg if getline(1) =~ '<?php' |   setf php | else |   setf virata | endif
line 2772: 
line 2773: " Visual Basic (see also *.bas *.cls)
line 2774: 
line 2775: " Visual Basic or FORM
line 2776: au BufNewFile,BufRead *.frm^I^I^Icall dist#ft#FTfrm()
line 2777: 
line 2778: " Visual Basic
line 2779: " user control, ActiveX document form, active designer, property page
line 2780: au BufNewFile,BufRead *.ctl,*.dob,*.dsr,*.pag^Isetf vb
line 2781: 
line 2782: " Visual Basic or Vimball Archiver
line 2783: au BufNewFile,BufRead *.vba^I^I^Icall dist#ft#FTvba()
line 2784: 
line 2785: " Visual Basic Project
line 2786: au BufNewFile,BufRead *.vbp^I^I^Isetf dosini
line 2787: 
line 2788: " VBScript (close to Visual Basic)
line 2789: au BufNewFile,BufRead *.vbs^I^I^Isetf vb
line 2790: 
line 2791: " Visual Basic .NET (close to Visual Basic)
line 2792: au BufNewFile,BufRead *.vb^I^I^Isetf vb
line 2793: 
line 2794: " Visual Studio Macro
line 2795: au BufNewFile,BufRead *.dsm^I^I^Isetf vb
line 2796: 
line 2797: " SaxBasic (close to Visual Basic)
line 2798: au BufNewFile,BufRead *.sba^I^I^Isetf vb
line 2799: 
line 2800: " Vgrindefs file
line 2801: au BufNewFile,BufRead vgrindefs^I^I^Isetf vgrindefs
line 2802: 
line 2803: " VRML V1.0c
line 2804: au BufNewFile,BufRead *.wrl^I^I^Isetf vrml
line 2805: 
line 2806: " Vroom (vim testing and executable documentation)
line 2807: au BufNewFile,BufRead *.vroom^I^I^Isetf vroom
line 2808: 
line 2809: " Vue.js Single File Component
line 2810: au BufNewFile,BufRead *.vue^I^I^Isetf vue
line 2811: 
line 2812: " WebAssembly
line 2813: au BufNewFile,BufRead *.wat,*.wast^I^Isetf wat
line 2814: 
line 2815: " WebAssembly Interface Type (WIT)
line 2816: au BufNewFile,BufRead *.wit^I^I^Isetf wit
line 2817: 
line 2818: " Webmacro
line 2819: au BufNewFile,BufRead *.wm^I^I^Isetf webmacro
line 2820: 
line 2821: " Wget config
line 2822: au BufNewFile,BufRead .wgetrc,wgetrc^I^Isetf wget
line 2823: 
line 2824: " Wget2 config
line 2825: au BufNewFile,BufRead .wget2rc,wget2rc^I^Isetf wget2
line 2826: 
line 2827: " WebGPU Shading Language (WGSL)
line 2828: au BufNewFile,BufRead *.wgsl^I^I^Isetf wgsl
line 2829: 
line 2830: " Website MetaLanguage
line 2831: au BufNewFile,BufRead *.wml^I^I^Isetf wml
line 2832: 
line 2833: " Winbatch
line 2834: au BufNewFile,BufRead *.wbt^I^I^Isetf winbatch
line 2835: 
line 2836: " WSML
line 2837: au BufNewFile,BufRead *.wsml^I^I^Isetf wsml
line 2838: 
line 2839: " WPL
line 2840: au BufNewFile,BufRead *.wpl^I^I^Isetf xml
line 2841: 
line 2842: " WvDial
line 2843: au BufNewFile,BufRead wvdial.conf,.wvdialrc^Isetf wvdial
line 2844: 
line 2845: " CVS RC file
line 2846: au BufNewFile,BufRead .cvsrc^I^I^Isetf cvsrc
line 2847: 
line 2848: " CVS commit file
line 2849: au BufNewFile,BufRead cvs\d\+^I^I^Isetf cvs
line 2850: 
line 2851: " WEB (*.web is also used for Winbatch: Guess, based on expecting "%" comment
line 2852: " lines in a WEB file).
line 2853: au BufNewFile,BufRead *.web if getline(1)[0].getline(2)[0].getline(3)[0].getline(4)[0].getline(5)[0] =~ "%" |   setf web | else |   setf winbatch | endif
line 2859: 
line 2860: " Windows Scripting Host and Windows Script Component
line 2861: au BufNewFile,BufRead *.ws[fc]^I^I^Isetf wsh
line 2862: 
line 2863: " Xdg-user-dirs
line 2864: au BufNewFile,BufRead user-dirs.dirs,user-dirs.defaults^I^Isetf sh
line 2865: 
line 2866: " XHTML
line 2867: au BufNewFile,BufRead *.xhtml,*.xht^I^Isetf xhtml
line 2868: 
line 2869: " X11vnc
line 2870: au BufNewFile,BufRead .x11vncrc^I^I^Isetf conf
line 2871: 
line 2872: " Xprofile
line 2873: au BufNewFile,BufRead .xprofile^I^I^Isetf sh
line 2874: 
line 2875: " X Pixmap (dynamically sets colors, this used to trigger on BufEnter to make
line 2876: " it work better, but that breaks setting 'filetype' manually)
line 2877: au BufNewFile,BufRead *.xpm if getline(1) =~ "XPM2" |   setf xpm2 | else |   setf xpm | endif
line 2883: au BufNewFile,BufRead *.xpm2^I^I^Isetf xpm2
line 2884: 
line 2885: " XFree86 config
line 2886: au BufNewFile,BufRead XF86Config if getline(1) =~ '\<XConfigurator\>' |   let b:xf86conf_xfree86_version = 3 | endif | setf xf86conf
line 2891: au BufNewFile,BufRead */xorg.conf.d/*.conf let b:xf86conf_xfree86_version = 4 | setf xf86conf
line 2894: 
line 2895: " Xorg config
line 2896: au BufNewFile,BufRead xorg.conf,xorg.conf-4^Ilet b:xf86conf_xfree86_version = 4 | setf xf86conf
line 2897: 
line 2898: " Xinetd conf
line 2899: au BufNewFile,BufRead */etc/xinetd.conf^I^Isetf xinetd
line 2900: 
line 2901: " Xilinx Vivado/Vitis project files and block design files
line 2902: au BufNewFile,BufRead *.xpr,*.xpfm,*.spfm,*.bxml,*.mmi^I^Isetf xml
line 2903: au BufNewFile,BufRead *.bd,*.bda,*.xci^I^I^I^Isetf json
line 2904: au BufNewFile,BufRead *.mss^I^I^I^I^Isetf mss
line 2905: 
line 2906: " XS Perl extension interface language
line 2907: au BufNewFile,BufRead *.xs^I^I^Isetf xs
line 2908: 
line 2909: " X compose file
line 2910: au BufNewFile,BufRead .XCompose,Compose^Isetf xcompose
line 2911: 
line 2912: " X resources file
line 2913: au BufNewFile,BufRead .Xdefaults,.Xpdefaults,.Xresources,xdm-config,*.ad setf xdefaults
line 2914: 
line 2915: " Xmath
line 2916: au BufNewFile,BufRead *.msc,*.msf^I^Isetf xmath
line 2917: au BufNewFile,BufRead *.ms if !dist#ft#FTnroff() | setf xmath | endif
line 2919: 
line 2920: " XML  specific variants: docbk and xbl
line 2921: au BufNewFile,BufRead *.xml^I^I^Icall dist#ft#FTxml()
line 2922: 
line 2923: " XMI (holding UML models) is also XML
line 2924: au BufNewFile,BufRead *.xmi^I^I^Isetf xml
line 2925: 
line 2926: " CSPROJ files are Visual Studio.NET's XML-based C# project config files
line 2927: au BufNewFile,BufRead *.csproj,*.csproj.user^Isetf xml
line 2928: 
line 2929: " FSPROJ files are Visual Studio.NET's XML-based F# project config files
line 2930: au BufNewFile,BufRead *.fsproj,*.fsproj.user^Isetf xml
line 2931: 
line 2932: " VBPROJ files are Visual Studio.NET's XML-based Visual Basic project config files
line 2933: au BufNewFile,BufRead *.vbproj,*.vbproj.user^Isetf xml
line 2934: 
line 2935: " MSBUILD configuration files are also XML
line 2936: au BufNewFile,BufRead Directory.Packages.props,Directory.Build.targets,Directory.Build.props^Isetf xml
line 2937: 
line 2938: " Unison Language
line 2939: au BufNewFile,BufRead *.u,*.uu^I^I^I^Isetf unison
line 2940: 
line 2941: " Qt Linguist translation source and Qt User Interface Files are XML
line 2942: " However, for .ts TypeScript is more common.
line 2943: au BufNewFile,BufRead *.ui^I^I^Isetf xml
line 2944: 
line 2945: " TPM's are RDF-based descriptions of TeX packages (Nikolai Weibull)
line 2946: au BufNewFile,BufRead *.tpm^I^I^Isetf xml
line 2947: 
line 2948: " Xdg menus
line 2949: au BufNewFile,BufRead */etc/xdg/menus/*.menu^Isetf xml
line 2950: 
line 2951: " ATI graphics driver configuration
line 2952: au BufNewFile,BufRead fglrxrc^I^I^Isetf xml
line 2953: 
line 2954: " Web Services Description Language (WSDL)
line 2955: au BufNewFile,BufRead *.wsdl^I^I^Isetf xml
line 2956: 
line 2957: " Workflow Description Language (WDL)
line 2958: au BufNewFile,BufRead *.wdl^I^I^Isetf wdl
line 2959: 
line 2960: " XLIFF (XML Localisation Interchange File Format) is also XML
line 2961: au BufNewFile,BufRead *.xlf^I^I^Isetf xml
line 2962: au BufNewFile,BufRead *.xliff^I^I^Isetf xml
line 2963: 
line 2964: " XML User Interface Language
line 2965: au BufNewFile,BufRead *.xul^I^I^Isetf xml
line 2966: 
line 2967: " X11 xmodmap (also see below)
line 2968: au BufNewFile,BufRead *Xmodmap^I^I^Isetf xmodmap
line 2969: 
line 2970: " Xquery
line 2971: au BufNewFile,BufRead *.xq,*.xql,*.xqm,*.xquery,*.xqy^Isetf xquery
line 2972: 
line 2973: " XSD
line 2974: au BufNewFile,BufRead *.xsd^I^I^Isetf xsd
line 2975: 
line 2976: " Xslt
line 2977: au BufNewFile,BufRead *.xsl,*.xslt^I^Isetf xslt
line 2978: 
line 2979: " Yacc
line 2980: au BufNewFile,BufRead *.yy,*.yxx,*.y++^I^Isetf yacc
line 2981: 
line 2982: " Yacc or racc
line 2983: au BufNewFile,BufRead *.y^I^I^Icall dist#ft#FTy()
line 2984: 
line 2985: " Yaml
line 2986: au BufNewFile,BufRead *.yaml,*.yml,*.eyaml^I^Isetf yaml
line 2987: au BufNewFile,BufRead */.kube/config^Isetf yaml
line 2988: 
line 2989: " Raml
line 2990: au BufNewFile,BufRead *.raml^I^I^Isetf raml
line 2991: 
line 2992: " yum conf (close enough to dosini)
line 2993: au BufNewFile,BufRead */etc/yum.conf^I^Isetf dosini
line 2994: 
line 2995: " YANG
line 2996: au BufRead,BufNewFile *.yang^I^I^Isetf yang
line 2997: 
line 2998: " Yuck
line 2999: au BufNewFile,BufRead *.yuck^I^I^Isetf yuck
line 3000: 
line 3001: " Zimbu
line 3002: au BufNewFile,BufRead *.zu^I^I^Isetf zimbu
line 3003: " Zimbu Templates
line 3004: au BufNewFile,BufRead *.zut^I^I^Isetf zimbutempl
line 3005: 
line 3006: " Zope
line 3007: "   dtml (zope dynamic template markup language), pt (zope page template),
line 3008: "   cpt (zope form controller page template)
line 3009: au BufNewFile,BufRead *.dtml,*.pt,*.cpt^I^Icall dist#ft#FThtml()
line 3010: "   zsql (zope sql method)
line 3011: au BufNewFile,BufRead *.zsql^I^I^Icall dist#ft#SQL()
line 3012: 
line 3013: " Z80 assembler asz80
line 3014: au BufNewFile,BufRead *.z8a^I^I^Isetf z8a
line 3015: 
line 3016: augroup END
line 3017: 
line 3018: 
line 3019: " Source the user-specified filetype file, for backwards compatibility with
line 3020: " Vim 5.x.
line 3021: if exists("myfiletypefile") && filereadable(expand(myfiletypefile))
line 3022:   execute "source " . myfiletypefile
line 3023: endif
line 3024: 
line 3025: 
line 3026: " Check for "*" after loading myfiletypefile, so that scripts.vim is only used
line 3027: " when there are no matching file name extensions.
line 3028: " Don't do this for compressed files.
line 3029: augroup filetypedetect
line 3030: au BufNewFile,BufRead * if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat | runtime! scripts.vim | endif
line 3033: au StdinReadPost * if !did_filetype() | runtime! scripts.vim | endif
line 3034: 
line 3035: 
line 3036: " Plain text files, needs to be far down to not override others.  This avoids
line 3037: " the "conf" type being used if there is a line starting with '#'.
line 3038: " But before patterns matching everything in a directory.
line 3039: au BufNewFile,BufRead *.text,README,LICENSE,COPYING,AUTHORS^Isetf text
line 3040: 
line 3041: " What should *.out files be? Text?
line 3042: " Disabled until it is clear, to what this should be set
line 3043: "au BufNewFile,BufRead *.out^Isetf text
line 3044: 
line 3045: 
line 3046: " Extra checks for when no filetype has been detected now.  Mostly used for
line 3047: " patterns that end in "*".  E.g., "zsh*" matches "zsh.vim", but that's a Vim
line 3048: " script file.
line 3049: " Most of these should call s:StarSetf() to avoid names ending in .gz and the
line 3050: " like are used.
line 3051: 
line 3052: " More Apache style config files
line 3053: au BufNewFile,BufRead */etc/proftpd/*.conf*,*/etc/proftpd/conf.*/*^Icall s:StarSetf('apachestyle')
line 3054: au BufNewFile,BufRead proftpd.conf*^I^I^I^I^Icall s:StarSetf('apachestyle')
line 3055: 
line 3056: " More Apache config files
line 3057: au BufNewFile,BufRead access.conf*,apache.conf*,apache2.conf*,httpd.conf*,httpd-*.conf*,srm.conf*,proxy-html.conf*^Icall s:StarSetf('apache')
line 3058: au BufNewFile,BufRead */etc/apache2/*.conf*,*/etc/apache2/conf.*/*,*/etc/apache2/mods-*/*,*/etc/apache2/sites-*/*,*/etc/httpd/conf.*/*,*/etc/httpd/mods-*/*,*/etc/httpd/sites-*/*,*/etc/httpd/conf.d/*.conf*^I^Icall s:StarSetf('apache')
line 3059: 
line 3060: " APT config file
line 3061: au BufNewFile,BufRead */etc/apt/apt.conf.d/{[-_[:alnum:]]\+,[-_.[:alnum:]]\+.conf} call s:StarSetf('aptconf')
line 3062: 
line 3063: " Asterisk config file
line 3064: au BufNewFile,BufRead *asterisk/*.conf*^I^Icall s:StarSetf('asterisk')
line 3065: au BufNewFile,BufRead *asterisk*/*voicemail.conf* call s:StarSetf('asteriskvm')
line 3066: 
line 3067: " Bazaar version control
line 3068: au BufNewFile,BufRead bzr_log.*^I^I^Isetf bzr
line 3069: 
line 3070: " Bazel and Buck2 build file
line 3071: if !has("fname_case")
line 3072:   au BufNewFile,BufRead *.BUILD,BUILD,BUCK^Isetf bzl
line 3073: endif
line 3074: 
line 3075: " BIND zone
line 3076: au BufNewFile,BufRead */named/db.*,*/bind/db.*^Icall s:StarSetf('bindzone')
line 3077: 
line 3078: au BufNewFile,BufRead cabal.project.*^I^Icall s:StarSetf('cabalproject')
line 3079: 
line 3080: " Calendar
line 3081: au BufNewFile,BufRead */.calendar/*,*/share/calendar/*/calendar.*,*/share/calendar/calendar.*^I^I^I^I^Icall s:StarSetf('calendar')
line 3084: 
line 3085: " Changelog
line 3086: au BufNewFile,BufRead [cC]hange[lL]og* if getline(1) =~ '; urgency='|  call s:StarSetf('debchangelog')|else|  call s:StarSetf('changelog')|endif
line 3092: 
line 3093: " Crontab
line 3094: au BufNewFile,BufRead crontab,crontab.*,*/etc/cron.d/*^I^Icall s:StarSetf('crontab')
line 3095: 
line 3096: " dnsmasq(8) configuration
line 3097: au BufNewFile,BufRead */etc/dnsmasq.d/*^I^Icall s:StarSetf('dnsmasq')
line 3098: 
line 3099: " Dockerfile
line 3100: au BufNewFile,BufRead Dockerfile.*,Containerfile.*^Icall s:StarSetf('dockerfile')
line 3101: 
line 3102: " Dracula
line 3103: au BufNewFile,BufRead drac.*^I^I^Icall s:StarSetf('dracula')
line 3104: 
line 3105: " Fvwm
line 3106: au BufNewFile,BufRead */.fvwm/*^I^I^Icall s:StarSetf('fvwm')
line 3107: au BufNewFile,BufRead *fvwmrc*,*fvwm95*.hook let b:fvwm_version = 1 | call s:StarSetf('fvwm')
line 3109: au BufNewFile,BufRead *fvwm2rc* if expand("<afile>:e") == "m4"|  call s:StarSetf('fvwm2m4')|else|  let b:fvwm_version = 2 | call s:StarSetf('fvwm')|endif
line 3115: 
line 3116: " Gedcom
line 3117: au BufNewFile,BufRead */tmp/lltmp*^I^Icall s:StarSetf('gedcom')
line 3118: 
line 3119: " Git
line 3120: au BufNewFile,BufRead */.gitconfig.d/*,*/etc/gitconfig.d/*^Icall s:StarSetf('gitconfig')
line 3121: 
line 3122: " Gitolite
line 3123: au BufNewFile,BufRead */gitolite-admin/conf/*^Icall s:StarSetf('gitolite')
line 3124: 
line 3125: " GTK RC
line 3126: au BufNewFile,BufRead .gtkrc*,gtkrc*^I^Icall s:StarSetf('gtkrc')
line 3127: 
line 3128: " Jam
line 3129: au BufNewFile,BufRead Prl*.*,JAM*.*^I^Icall s:StarSetf('jam')
line 3130: 
line 3131: " Jargon
line 3132: au! BufNewFile,BufRead *jarg* if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'THIS IS THE JARGON FILE'|  call s:StarSetf('jargon')|endif
line 3136: 
line 3137: " Java Properties resource file (note: doesn't catch font.properties.pl)
line 3138: au BufNewFile,BufRead *.properties_??_??_*^Icall s:StarSetf('jproperties')
line 3139: 
line 3140: " Kconfig
line 3141: au BufNewFile,BufRead Kconfig.*,Config.in.*^Icall s:StarSetf('kconfig')
line 3142: 
line 3143: " Lilo: Linux loader
line 3144: au BufNewFile,BufRead lilo.conf*^I^Icall s:StarSetf('lilo')
line 3145: 
line 3146: " Libsensors
line 3147: au BufNewFile,BufRead */etc/sensors.d/[^.]*^Icall s:StarSetf('sensors')
line 3148: 
line 3149: " Logcheck
line 3150: au BufNewFile,BufRead */etc/logcheck/*.d*/*^Icall s:StarSetf('logcheck')
line 3151: 
line 3152: " Makefile
line 3153: au BufNewFile,BufRead [mM]akefile*^I^Icall s:StarSetf('make')
line 3154: 
line 3155: " Ruby Makefile
line 3156: au BufNewFile,BufRead [rR]akefile*^I^Icall s:StarSetf('ruby')
line 3157: 
line 3158: " Mail (also matches muttrc.vim, so this is below the other checks)
line 3159: au BufNewFile,BufRead {neo,}mutt[[:alnum:]._-]\\\{6\}^Isetf mail
line 3160: 
line 3161: au BufNewFile,BufRead reportbug-*^I^Icall s:StarSetf('mail')
line 3162: 
line 3163: " Modconf
line 3164: au BufNewFile,BufRead */etc/modutils/* if executable(expand("<afile>")) != 1|  call s:StarSetf('modconf')|endif
line 3168: au BufNewFile,BufRead */etc/modprobe.*^I^Icall s:StarSetf('modconf')
line 3169: 
line 3170: " Mutt setup files (must be before catch *.rc)
line 3171: au BufNewFile,BufRead */etc/Muttrc.d/*^I^Icall s:StarSetf('muttrc')
line 3172: 
line 3173: " Mutt setup file
line 3174: au BufNewFile,BufRead .mutt{ng,}rc*,*/.mutt{ng,}/mutt{ng,}rc*^Icall s:StarSetf('muttrc')
line 3175: au BufNewFile,BufRead mutt{ng,}rc*,Mutt{ng,}rc*^I^Icall s:StarSetf('muttrc')
line 3176: 
line 3177: " Neomutt setup file
line 3178: au BufNewFile,BufRead .neomuttrc*,*/.neomutt/neomuttrc*^Icall s:StarSetf('neomuttrc')
line 3179: au BufNewFile,BufRead neomuttrc*,Neomuttrc*^I^Icall s:StarSetf('neomuttrc')
line 3180: 
line 3181: " Nfs
line 3182: au BufNewFile,BufRead nfs.conf,nfsmount.conf^I^Isetf dosini
line 3183: 
line 3184: " Nroff macros
line 3185: au BufNewFile,BufRead tmac.*^I^I^Icall s:StarSetf('nroff')
line 3186: 
line 3187: " OpenBSD hostname.if
line 3188: au BufNewFile,BufRead */etc/hostname.*^I^Icall s:StarSetf('config')
line 3189: 
line 3190: " Pam conf
line 3191: au BufNewFile,BufRead */etc/pam.d/*^I^Icall s:StarSetf('pamconf')
line 3192: 
line 3193: " Pandoc
line 3194: au BufNewFile,BufRead,BufFilePost *.pandoc,*.pdk,*.pd,*.pdc^Isetf pandoc
line 3195: 
line 3196: " Printcap and Termcap
line 3197: au BufNewFile,BufRead *printcap* if !did_filetype()|  let b:ptcap_type = "print" | call s:StarSetf('ptcap')|endif
line 3201: au BufNewFile,BufRead *termcap* if !did_filetype()|  let b:ptcap_type = "term" | call s:StarSetf('ptcap')|endif
line 3205: 
line 3206: " ReDIF
line 3207: " Only used when the .rdf file was not detected to be XML.
line 3208: au BufRead,BufNewFile *.rdf^I^I^Icall dist#ft#Redif()
line 3209: 
line 3210: " Remind
line 3211: au BufNewFile,BufRead .reminders*^I^Icall s:StarSetf('remind')
line 3212: 
line 3213: " SGML catalog file
line 3214: au BufNewFile,BufRead sgml.catalog*^I^Icall s:StarSetf('catalog')
line 3215: 
line 3216: " Stylus
line 3217: au BufNewFile,BufReadPost *.styl,*.stylus^Isetf stylus
line 3218: 
line 3219: " avoid doc files being recognized a shell files
line 3220: au BufNewFile,BufRead */doc/{,.}bash[_-]completion{,.d,.sh}{,/*} setf text
line 3221: 
line 3222: " Shell scripts ending in a star
line 3223: au BufNewFile,BufRead .bashrc*,.bash[_-]profile*,.bash[_-]logout*,.bash[_-]aliases*,bash-fc[-.]*,PKGBUILD*,APKBUILD*,*/{,.}bash[_-]completion{,.d,.sh}{,/*} call dist#ft#SetFileTypeSH("bash")
line 3224: au BufNewFile,BufRead .kshrc* call dist#ft#SetFileTypeSH("ksh")
line 3225: au BufNewFile,BufRead .profile* call dist#ft#SetFileTypeSH(getline(1))
line 3226: 
line 3227: " Sudoers
line 3228: au BufNewFile,BufRead */etc/sudoers.d/*^I^Icall s:StarSetf('sudoers')
line 3229: 
line 3230: " tcsh scripts ending in a star
line 3231: au BufNewFile,BufRead .tcshrc*^Icall dist#ft#SetFileTypeShell("tcsh")
line 3232: 
line 3233: " csh scripts ending in a star
line 3234: au BufNewFile,BufRead .login*,.cshrc*  call dist#ft#CSH()
line 3235: 
line 3236: " tmux configuration with arbitrary extension
line 3237: au BufNewFile,BufRead {.,}tmux*.conf*^I^Isetf tmux
line 3238: 
line 3239: " Universal Scene Description
line 3240: au BufNewFile,BufRead *.usda,*.usd^I^Isetf usd
line 3241: 
line 3242: " UCI
line 3243: " UCI files are normally in /etc/config, but that might be mounted over sshfs or similar, so we match more loosely.
line 3244: " There was some concern[1] that this pattern would match too much, so now we check the file content as well.
line 3245: " [1]: https://github.com/vim/vim/pull/14385#discussion_r1558878741
line 3246: au BufNewFile,BufRead */etc/config/*^I^Iif dist#ft#Detect_UCI_statements() | call s:StarSetf('uci') | endif
line 3247: 
line 3248: " VHDL
line 3249: au BufNewFile,BufRead *.vhdl_[0-9]*^I^Icall s:StarSetf('vhdl')
line 3250: 
line 3251: " Vim script
line 3252: au BufNewFile,BufRead *vimrc*^I^I^Icall s:StarSetf('vim')
line 3253: 
line 3254: " Subversion commit file
line 3255: au BufNewFile,BufRead svn-commit*.tmp^I^Isetf svn
line 3256: 
line 3257: " X resources file
line 3258: au BufNewFile,BufRead Xresources*,*/app-defaults/*,*/Xresources/* call s:StarSetf('xdefaults')
line 3259: 
line 3260: " XFree86 config
line 3261: au BufNewFile,BufRead XF86Config-4* let b:xf86conf_xfree86_version = 4 | call s:StarSetf('xf86conf')
line 3263: au BufNewFile,BufRead XF86Config* if getline(1) =~ '\<XConfigurator\>'|  let b:xf86conf_xfree86_version = 3|endif|call s:StarSetf('xf86conf')
line 3268: 
line 3269: " XKB
line 3270: au BufNewFile,BufRead */usr/share/X11/xkb/{compat,geometry,keycodes,symbols,types}/*^Icall s:StarSetf('xkb')
line 3271: 
line 3272: " X11 xmodmap
line 3273: au BufNewFile,BufRead *xmodmap*^I^I^Icall s:StarSetf('xmodmap')
line 3274: 
line 3275: " Xinetd conf
line 3276: au BufNewFile,BufRead */etc/xinetd.d/*^I^Icall s:StarSetf('xinetd')
line 3277: 
line 3278: " yum conf (close enough to dosini)
line 3279: au BufNewFile,BufRead */etc/yum.repos.d/*^Icall s:StarSetf('dosini')
line 3280: 
line 3281: " Z-Shell script ending in a star
line 3282: au BufNewFile,BufRead .zsh*,.zlog*,.zcompdump*  call s:StarSetf('zsh')
line 3283: au BufNewFile,BufRead zsh*,zlog*^I^Icall s:StarSetf('zsh')
line 3284: 
line 3285: " Zsh module
line 3286: " mdd: https://github.com/zsh-users/zsh/blob/57248b88830ce56adc243a40c7773fb3825cab34/Etc/zsh-development-guide#L285-L288
line 3287: " mdh, pro: https://github.com/zsh-users/zsh/blob/57248b88830ce56adc243a40c7773fb3825cab34/Etc/zsh-development-guide#L268-L271
line 3288: " *.mdd will generate *.mdh, *.pro and *.epro.
line 3289: " module's *.c will #include *.mdh containing module dependency information and
line 3290: " *.pro containing all static declarations of *.c
line 3291: " *.epro contains all external declarations of *.c
line 3292: au BufNewFile,BufRead *.mdh,*.epro^I^Isetf c
line 3293: au BufNewFile,BufRead *.mdd^I^I^Isetf sh
line 3294: 
line 3295: " Help files match *.txt but should have a last line that is a modeline.
line 3296: au BufNewFile,BufRead *.txt  if getline('$') !~ 'vim:.*ft=help'|   setf text| endif
line 3300: 
line 3301: " Blueprint markup files
line 3302: au BufNewFile,BufRead *.blp^I^I^Isetf blueprint
line 3303: 
line 3304: " Blueprint build system file
line 3305: au BufNewFile,BufRead *.bp^I^I^Isetf bp
line 3306: 
line 3307: " Use the filetype detect plugins.  They may overrule any of the previously
line 3308: " detected filetypes.
line 3309: runtime! ftdetect/*.vim
Searching for "ftdetect/*.vim" in "/home/Dante/.vim,/home/Dante/.vim/plugged/onedark.vim,/home/Dante/.vim/plugged/onehalf/vim,/home/Dante/.vim/plugged/gruvbox,/home/Dante/.vim/plugged/lightline.vim,/home/Dante/.vim/plugged/vim-tmux-navigator,/home/Dante/.vim/plugged/vimtex,/home/Dante/.vim/plugged/nerdtree,/home/Dante/.vim/plugged/fzf,/home/Dante/.vim/plugged/fzf.vim,/home/Dante/.vim/plugged/vim-wayland-clipboard,/home/Dante/.vim/plugged/coc.nvim,/home/Dante/.vim/plugged/vim-obsession,/usr/share/vim/vimfiles,/usr/share/vim/vim91,/usr/share/vim/vimfiles/after,/home/Dante/.vim/plugged/vimtex/after,/home/Dante/.vim/after"
Searching for "/home/Dante/.vim/ftdetect/*.vim"
Searching for "/home/Dante/.vim/plugged/onedark.vim/ftdetect/*.vim"
Searching for "/home/Dante/.vim/plugged/onehalf/vim/ftdetect/*.vim"
Searching for "/home/Dante/.vim/plugged/gruvbox/ftdetect/*.vim"
Searching for "/home/Dante/.vim/plugged/lightline.vim/ftdetect/*.vim"
Searching for "/home/Dante/.vim/plugged/vim-tmux-navigator/ftdetect/*.vim"
Searching for "/home/Dante/.vim/plugged/vimtex/ftdetect/*.vim"
chdir(/home/Dante/.vim/plugged/vimtex/ftdetect)
fchdir() to previous dir
line 3309: sourcing "/home/Dante/.vim/plugged/vimtex/ftdetect/cls.vim"
line 1: " VimTeX - LaTeX plugin for Vim
line 2: "
line 3: " Maintainer: Karl Yngve Lervg
line 4: " Email:      karl.yngve@gmail.com
line 5: "
line 6: 
line 7: if !get(g:, 'vimtex_enabled', 1) | finish | endif
line 7:  finish | endif
line 7:  endif
line 8: 
line 9: autocmd BufRead,BufNewFile *.cls set filetype=tex
finished sourcing /home/Dante/.vim/plugged/vimtex/ftdetect/cls.vim
continuing in /usr/share/vim/vim91/filetype.vim
chdir(/home/Dante/.vim/plugged/vimtex/ftdetect)
fchdir() to previous dir
line 3309: sourcing "/home/Dante/.vim/plugged/vimtex/ftdetect/tex.vim"
line 1: " VimTeX - LaTeX plugin for Vim
line 2: "
line 3: " Maintainer: Karl Yngve Lervg
line 4: " Email:      karl.yngve@gmail.com
line 5: "
line 6: 
line 7: if !get(g:, 'vimtex_enabled', 1) || get(g:, 'tex_flavor', 'latex') !=# 'latex'
line 9:   finish
line 10: endif
line 11: 
line 12: " For some reason, it seems the best way to ensure filetype "tex" is to just
line 13: " set the g:tex_flavor option. Overriding the autocmds or similar seems to make
line 14: " startup slower, for some unknown reason.
line 15: let g:tex_flavor = 'latex'
finished sourcing /home/Dante/.vim/plugged/vimtex/ftdetect/tex.vim
continuing in /usr/share/vim/vim91/filetype.vim
chdir(/home/Dante/.vim/plugged/vimtex/ftdetect)
fchdir() to previous dir
line 3309: sourcing "/home/Dante/.vim/plugged/vimtex/ftdetect/tikz.vim"
line 1: " VimTeX - LaTeX plugin for Vim
line 2: "
line 3: " Maintainer: Karl Yngve Lervg
line 4: " Email:      karl.yngve@gmail.com
line 5: "
line 6: 
line 7: if !get(g:, 'vimtex_enabled', 1) | finish | endif
line 7:  finish | endif
line 7:  endif
line 8: 
line 9: autocmd BufRead,BufNewFile *.tikz set filetype=tex
finished sourcing /home/Dante/.vim/plugged/vimtex/ftdetect/tikz.vim
continuing in /usr/share/vim/vim91/filetype.vim
Searching for "/home/Dante/.vim/plugged/nerdtree/ftdetect/*.vim"
Searching for "/home/Dante/.vim/plugged/fzf/ftdetect/*.vim"
Searching for "/home/Dante/.vim/plugged/fzf.vim/ftdetect/*.vim"
Searching for "/home/Dante/.vim/plugged/vim-wayland-clipboard/ftdetect/*.vim"
Searching for "/home/Dante/.vim/plugged/coc.nvim/ftdetect/*.vim"
Searching for "/home/Dante/.vim/plugged/vim-obsession/ftdetect/*.vim"
Searching for "/usr/share/vim/vimfiles/ftdetect/*.vim"
chdir(/usr/share/vim/vimfiles/ftdetect)
fchdir() to previous dir
line 3309: sourcing "/usr/share/vim/vimfiles/ftdetect/PKGBUILD.vim"
line 1: augroup ftdetect_pkgbuild
line 2:   autocmd!
line 3:   au BufNewFile,BufRead PKGBUILD set filetype=PKGBUILD
line 4: augroup END
finished sourcing /usr/share/vim/vimfiles/ftdetect/PKGBUILD.vim
continuing in /usr/share/vim/vim91/filetype.vim
chdir(/usr/share/vim/vimfiles/ftdetect)
fchdir() to previous dir
line 3309: sourcing "/usr/share/vim/vimfiles/ftdetect/SRCINFO.vim"
line 1: augroup ftdetect_srcinfo
line 2:   autocmd!
line 3:   au BufNewFile,BufRead .SRCINFO set filetype=SRCINFO
line 4: augroup END
finished sourcing /usr/share/vim/vimfiles/ftdetect/SRCINFO.vim
continuing in /usr/share/vim/vim91/filetype.vim
Searching for "/usr/share/vim/vim91/ftdetect/*.vim"
Searching for "/usr/share/vim/vimfiles/after/ftdetect/*.vim"
Searching for "/home/Dante/.vim/plugged/vimtex/after/ftdetect/*.vim"
Searching for "/home/Dante/.vim/after/ftdetect/*.vim"
line 3310: 
line 3311: " NOTE: The above command could have ended the filetypedetect autocmd group
line 3312: " and started another one. Let's make sure it has ended to get to a consistent
line 3313: " state.
line 3314: augroup END
line 3315: 
line 3316: " Generic configuration file. Use FALLBACK, it's just guessing!
line 3317: au filetypedetect BufNewFile,BufRead,StdinReadPost * if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat    && (expand("<amatch>") =~# '\.conf$'^I|| getline(1) =~ '^#' || getline(2) =~ '^#'^I|| getline(3) =~ '^#' || getline(4) =~ '^#'^I|| getline(5) =~ '^#') |   setf FALLBACK conf | endif
line 3325: 
line 3326: " Yarn lock
line 3327: au BufNewFile,BufRead yarn.lock^I^I^Isetf yaml
line 3328: 
line 3329: " Zathurarc
line 3330: au BufNewFile,BufRead zathurarc^I^I^Isetf zathurarc
line 3331: 
line 3332: " Rofi stylesheet
line 3333: au BufNewFile,BufRead *.rasi^I^I^Isetf rasi
line 3334: 
line 3335: " If the GUI is already running, may still need to install the Syntax menu.
line 3336: " Don't do it when the 'M' flag is included in 'guioptions'.
line 3337: if has("menu") && has("gui_running") && !exists("did_install_syntax_menu") && &guioptions !~# "M"
line 3339:   source <sfile>:p:h/menu.vim
line 3340: endif
line 3341: 
line 3342: " Function called for testing all functions defined here.  These are
line 3343: " script-local, thus need to be executed here.
line 3344: " Returns a string with error messages (hopefully empty).
line 3345: func TestFiletypeFuncs(testlist)
line 3356: 
line 3357: " Restore 'cpoptions'
line 3358: let &cpo = s:cpo_save
line 3359: unlet s:cpo_save
line 3360: 
line 3361: " vim: ts=8
finished sourcing /usr/share/vim/vim91/filetype.vim
continuing in plug#end
Searching for "/usr/share/vim/vimfiles/after/filetype.vim"
Searching for "/home/Dante/.vim/plugged/vimtex/after/filetype.vim"
Searching for "/home/Dante/.vim/after/filetype.vim"
Searching for "ftplugin.vim" in "/home/Dante/.vim,/home/Dante/.vim/plugged/onedark.vim,/home/Dante/.vim/plugged/onehalf/vim,/home/Dante/.vim/plugged/gruvbox,/home/Dante/.vim/plugged/lightline.vim,/home/Dante/.vim/plugged/vim-tmux-navigator,/home/Dante/.vim/plugged/vimtex,/home/Dante/.vim/plugged/nerdtree,/home/Dante/.vim/plugged/fzf,/home/Dante/.vim/plugged/fzf.vim,/home/Dante/.vim/plugged/vim-wayland-clipboard,/home/Dante/.vim/plugged/coc.nvim,/home/Dante/.vim/plugged/vim-obsession,/usr/share/vim/vimfiles,/usr/share/vim/vim91,/usr/share/vim/vimfiles/after,/home/Dante/.vim/plugged/vimtex/after,/home/Dante/.vim/after"
Searching for "/home/Dante/.vim/ftplugin.vim"
Searching for "/home/Dante/.vim/plugged/onedark.vim/ftplugin.vim"
Searching for "/home/Dante/.vim/plugged/onehalf/vim/ftplugin.vim"
Searching for "/home/Dante/.vim/plugged/gruvbox/ftplugin.vim"
Searching for "/home/Dante/.vim/plugged/lightline.vim/ftplugin.vim"
Searching for "/home/Dante/.vim/plugged/vim-tmux-navigator/ftplugin.vim"
Searching for "/home/Dante/.vim/plugged/vimtex/ftplugin.vim"
Searching for "/home/Dante/.vim/plugged/nerdtree/ftplugin.vim"
Searching for "/home/Dante/.vim/plugged/fzf/ftplugin.vim"
Searching for "/home/Dante/.vim/plugged/fzf.vim/ftplugin.vim"
Searching for "/home/Dante/.vim/plugged/vim-wayland-clipboard/ftplugin.vim"
Searching for "/home/Dante/.vim/plugged/coc.nvim/ftplugin.vim"
Searching for "/home/Dante/.vim/plugged/vim-obsession/ftplugin.vim"
Searching for "/usr/share/vim/vimfiles/ftplugin.vim"
Searching for "/usr/share/vim/vim91/ftplugin.vim"
chdir(/usr/share/vim/vim91)
fchdir() to previous dir
line 86: sourcing "/usr/share/vim/vim91/ftplugin.vim"
line 1: vim9script noclear
line 2: 
line 3: # Vim support file to switch on loading plugins for file types
line 4: #
line 5: # Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 6: # Last change:^I2023 Aug 10
line 7: # Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 8: 
line 9: if exists("g:did_load_ftplugin")
line 10:   finish
line 11: endif
line 12: g:did_load_ftplugin = 1
line 14: augroup filetypeplugin
line 15:   au FileType * call LoadFTPlugin()
line 16: augroup END
line 17: 
line 18: if exists('*LoadFTPlugin')
line 20:   finish
line 21: endif
line 22: 
line 23: def LoadFTPlugin()
finished sourcing /usr/share/vim/vim91/ftplugin.vim
continuing in plug#end
Searching for "/usr/share/vim/vimfiles/after/ftplugin.vim"
Searching for "/home/Dante/.vim/plugged/vimtex/after/ftplugin.vim"
Searching for "/home/Dante/.vim/after/ftplugin.vim"
Searching for "indent.vim" in "/home/Dante/.vim,/home/Dante/.vim/plugged/onedark.vim,/home/Dante/.vim/plugged/onehalf/vim,/home/Dante/.vim/plugged/gruvbox,/home/Dante/.vim/plugged/lightline.vim,/home/Dante/.vim/plugged/vim-tmux-navigator,/home/Dante/.vim/plugged/vimtex,/home/Dante/.vim/plugged/nerdtree,/home/Dante/.vim/plugged/fzf,/home/Dante/.vim/plugged/fzf.vim,/home/Dante/.vim/plugged/vim-wayland-clipboard,/home/Dante/.vim/plugged/coc.nvim,/home/Dante/.vim/plugged/vim-obsession,/usr/share/vim/vimfiles,/usr/share/vim/vim91,/usr/share/vim/vimfiles/after,/home/Dante/.vim/plugged/vimtex/after,/home/Dante/.vim/after"
Searching for "/home/Dante/.vim/indent.vim"
Searching for "/home/Dante/.vim/plugged/onedark.vim/indent.vim"
Searching for "/home/Dante/.vim/plugged/onehalf/vim/indent.vim"
Searching for "/home/Dante/.vim/plugged/gruvbox/indent.vim"
Searching for "/home/Dante/.vim/plugged/lightline.vim/indent.vim"
Searching for "/home/Dante/.vim/plugged/vim-tmux-navigator/indent.vim"
Searching for "/home/Dante/.vim/plugged/vimtex/indent.vim"
Searching for "/home/Dante/.vim/plugged/nerdtree/indent.vim"
Searching for "/home/Dante/.vim/plugged/fzf/indent.vim"
Searching for "/home/Dante/.vim/plugged/fzf.vim/indent.vim"
Searching for "/home/Dante/.vim/plugged/vim-wayland-clipboard/indent.vim"
Searching for "/home/Dante/.vim/plugged/coc.nvim/indent.vim"
Searching for "/home/Dante/.vim/plugged/vim-obsession/indent.vim"
Searching for "/usr/share/vim/vimfiles/indent.vim"
Searching for "/usr/share/vim/vim91/indent.vim"
chdir(/usr/share/vim/vim91)
fchdir() to previous dir
line 86: sourcing "/usr/share/vim/vim91/indent.vim"
line 1: " Vim support file to switch on loading indent files for file types
line 2: "
line 3: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 4: " Last Change:^I2023 Aug 10
line 5: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 6: 
line 7: if exists("did_indent_on")
line 8:   finish
line 9: endif
line 10: let did_indent_on = 1
line 11: 
line 12: augroup filetypeindent
line 13:   au FileType * call s:LoadIndent()
line 14: augroup END
line 15: 
line 16: def s:LoadIndent()
finished sourcing /usr/share/vim/vim91/indent.vim
continuing in plug#end
Searching for "/usr/share/vim/vimfiles/after/indent.vim"
Searching for "/home/Dante/.vim/plugged/vimtex/after/indent.vim"
Searching for "/home/Dante/.vim/after/indent.vim"
line 87:   if has('vim_starting')
line 88:     if has('syntax') && !exists('g:syntax_on')
line 89:       syntax enable
line 89: so $VIMRUNTIME/syntax/syntax.vim
chdir(/usr/share/vim/vim91/syntax)
fchdir() to previous dir
line 89: sourcing "/usr/share/vim/vim91/syntax/syntax.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 3: " Last Change:^I2023 Aug 10
line 4: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 5: 
line 6: " This file is used for ":syntax on".
line 7: " It installs the autocommands and starts highlighting for all buffers.
line 8: 
line 9: if !has("syntax")
line 10:   finish
line 11: endif
line 12: 
line 13: " If Syntax highlighting appears to be on already, turn it off first, so that
line 14: " any leftovers are cleared.
line 15: if exists("syntax_on") || exists("syntax_manual")
line 16:   so <sfile>:p:h/nosyntax.vim
line 17: endif
line 18: 
line 19: " Load the Syntax autocommands and set the default methods for highlighting.
line 20: runtime syntax/synload.vim
Searching for "syntax/synload.vim" in "/home/Dante/.vim,/home/Dante/.vim/plugged/onedark.vim,/home/Dante/.vim/plugged/onehalf/vim,/home/Dante/.vim/plugged/gruvbox,/home/Dante/.vim/plugged/lightline.vim,/home/Dante/.vim/plugged/vim-tmux-navigator,/home/Dante/.vim/plugged/vimtex,/home/Dante/.vim/plugged/nerdtree,/home/Dante/.vim/plugged/fzf,/home/Dante/.vim/plugged/fzf.vim,/home/Dante/.vim/plugged/vim-wayland-clipboard,/home/Dante/.vim/plugged/coc.nvim,/home/Dante/.vim/plugged/vim-obsession,/usr/share/vim/vimfiles,/usr/share/vim/vim91,/usr/share/vim/vimfiles/after,/home/Dante/.vim/plugged/vimtex/after,/home/Dante/.vim/after"
Searching for "/home/Dante/.vim/syntax/synload.vim"
Searching for "/home/Dante/.vim/plugged/onedark.vim/syntax/synload.vim"
Searching for "/home/Dante/.vim/plugged/onehalf/vim/syntax/synload.vim"
Searching for "/home/Dante/.vim/plugged/gruvbox/syntax/synload.vim"
Searching for "/home/Dante/.vim/plugged/lightline.vim/syntax/synload.vim"
Searching for "/home/Dante/.vim/plugged/vim-tmux-navigator/syntax/synload.vim"
Searching for "/home/Dante/.vim/plugged/vimtex/syntax/synload.vim"
Searching for "/home/Dante/.vim/plugged/nerdtree/syntax/synload.vim"
Searching for "/home/Dante/.vim/plugged/fzf/syntax/synload.vim"
Searching for "/home/Dante/.vim/plugged/fzf.vim/syntax/synload.vim"
Searching for "/home/Dante/.vim/plugged/vim-wayland-clipboard/syntax/synload.vim"
Searching for "/home/Dante/.vim/plugged/coc.nvim/syntax/synload.vim"
Searching for "/home/Dante/.vim/plugged/vim-obsession/syntax/synload.vim"
Searching for "/usr/share/vim/vimfiles/syntax/synload.vim"
Searching for "/usr/share/vim/vim91/syntax/synload.vim"
chdir(/usr/share/vim/vim91/syntax)
fchdir() to previous dir
line 20: sourcing "/usr/share/vim/vim91/syntax/synload.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 3: " Last Change:^I2023 Aug 10
line 4: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 5: 
line 6: " This file sets up for syntax highlighting.
line 7: " It is loaded from "syntax.vim" and "manual.vim".
line 8: " 1. Set the default highlight groups.
line 9: " 2. Install Syntax autocommands for all the available syntax files.
line 10: 
line 11: if !has("syntax")
line 12:   finish
line 13: endif
line 14: 
line 15: " let others know that syntax has been switched on
line 16: let syntax_on = 1
line 17: 
line 18: " Set the default highlighting colors.  Use a color scheme if specified.
line 19: if exists("colors_name")
line 20:   exe "colors " . colors_name
line 21: else
line 22:   runtime! syntax/syncolor.vim
Searching for "syntax/syncolor.vim" in "/home/Dante/.vim,/home/Dante/.vim/plugged/onedark.vim,/home/Dante/.vim/plugged/onehalf/vim,/home/Dante/.vim/plugged/gruvbox,/home/Dante/.vim/plugged/lightline.vim,/home/Dante/.vim/plugged/vim-tmux-navigator,/home/Dante/.vim/plugged/vimtex,/home/Dante/.vim/plugged/nerdtree,/home/Dante/.vim/plugged/fzf,/home/Dante/.vim/plugged/fzf.vim,/home/Dante/.vim/plugged/vim-wayland-clipboard,/home/Dante/.vim/plugged/coc.nvim,/home/Dante/.vim/plugged/vim-obsession,/usr/share/vim/vimfiles,/usr/share/vim/vim91,/usr/share/vim/vimfiles/after,/home/Dante/.vim/plugged/vimtex/after,/home/Dante/.vim/after"
Searching for "/home/Dante/.vim/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/onedark.vim/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/onehalf/vim/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/gruvbox/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/lightline.vim/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/vim-tmux-navigator/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/vimtex/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/nerdtree/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/fzf/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/fzf.vim/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/vim-wayland-clipboard/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/coc.nvim/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/vim-obsession/syntax/syncolor.vim"
Searching for "/usr/share/vim/vimfiles/syntax/syncolor.vim"
Searching for "/usr/share/vim/vim91/syntax/syncolor.vim"
chdir(/usr/share/vim/vim91/syntax)
fchdir() to previous dir
line 22: sourcing "/usr/share/vim/vim91/syntax/syncolor.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 3: " Last Change:^I2023 Aug 10
line 4: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 5: 
line 6: " This file sets up the default methods for highlighting.
line 7: " It is loaded from "synload.vim" and from Vim for ":syntax reset".
line 8: " Also used from init_highlight().
line 9: 
line 10: if !exists("syntax_cmd") || syntax_cmd == "on"
line 11:   " ":syntax on" works like in Vim 5.7: set colors but keep links
line 12:   command -nargs=* SynColor hi <args>
line 13:   command -nargs=* SynLink hi link <args>
line 14: else
line 15:   if syntax_cmd == "enable"
line 16:     " ":syntax enable" keeps any existing colors
line 17:     command -nargs=* SynColor hi def <args>
line 18:     command -nargs=* SynLink hi def link <args>
line 19:   elseif syntax_cmd == "reset"
line 20:     " ":syntax reset" resets all colors to the default
line 21:     command -nargs=* SynColor hi <args>
line 22:     command -nargs=* SynLink hi! link <args>
line 23:   else
line 24:     " User defined syncolor file has already set the colors.
line 25:     finish
line 26:   endif
line 27: endif
line 28: 
line 29: " Many terminals can only use six different colors (plus black and white).
line 30: " Therefore the number of colors used is kept low. It doesn't look nice with
line 31: " too many colors anyway.
line 32: " Careful with "cterm=bold", it changes the color to bright for some terminals.
line 33: " There are two sets of defaults: for a dark and a light background.
line 34: if &background == "dark"
line 35:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 36:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 37:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 38:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 39:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 40:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 41:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 42:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 43:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 44:   SynColor Added^Iterm=NONE cterm=NONE ctermfg=Green ctermbg=NONE gui=NONE guifg=LimeGreen guibg=NONE
line 45:   SynColor Changed^Iterm=NONE cterm=NONE ctermfg=Blue ctermbg=NONE gui=NONE guifg=DodgerBlue guibg=NONE
line 46:   SynColor Removed^Iterm=NONE cterm=NONE ctermfg=Red ctermbg=NONE gui=NONE guifg=Red guibg=NONE
line 47: else
line 48:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
line 48: hi def Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
line 49:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
line 49: hi def Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
line 50:   " #6a5acd is SlateBlue
line 51:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=#6a5acd guibg=NONE
line 51: hi def Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=#6a5acd guibg=NONE
line 52:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
line 52: hi def Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
line 53:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
line 53: hi def Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
line 54:   " #6a0dad is Purple
line 55:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=#6a0dad guibg=NONE
line 55: hi def PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=#6a0dad guibg=NONE
line 56:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
line 56: hi def Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
line 57:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
line 57: hi def Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
Searching for "colors/lists/default.vim" in "/home/Dante/.vim,/home/Dante/.vim/plugged/onedark.vim,/home/Dante/.vim/plugged/onehalf/vim,/home/Dante/.vim/plugged/gruvbox,/home/Dante/.vim/plugged/lightline.vim,/home/Dante/.vim/plugged/vim-tmux-navigator,/home/Dante/.vim/plugged/vimtex,/home/Dante/.vim/plugged/nerdtree,/home/Dante/.vim/plugged/fzf,/home/Dante/.vim/plugged/fzf.vim,/home/Dante/.vim/plugged/vim-wayland-clipboard,/home/Dante/.vim/plugged/coc.nvim,/home/Dante/.vim/plugged/vim-obsession,/usr/share/vim/vimfiles,/usr/share/vim/vim91,/usr/share/vim/vimfiles/after,/home/Dante/.vim/plugged/vimtex/after,/home/Dante/.vim/after"
Searching for "/home/Dante/.vim/colors/lists/default.vim"
Searching for "/home/Dante/.vim/plugged/onedark.vim/colors/lists/default.vim"
Searching for "/home/Dante/.vim/plugged/onehalf/vim/colors/lists/default.vim"
Searching for "/home/Dante/.vim/plugged/gruvbox/colors/lists/default.vim"
Searching for "/home/Dante/.vim/plugged/lightline.vim/colors/lists/default.vim"
Searching for "/home/Dante/.vim/plugged/vim-tmux-navigator/colors/lists/default.vim"
Searching for "/home/Dante/.vim/plugged/vimtex/colors/lists/default.vim"
Searching for "/home/Dante/.vim/plugged/nerdtree/colors/lists/default.vim"
Searching for "/home/Dante/.vim/plugged/fzf/colors/lists/default.vim"
Searching for "/home/Dante/.vim/plugged/fzf.vim/colors/lists/default.vim"
Searching for "/home/Dante/.vim/plugged/vim-wayland-clipboard/colors/lists/default.vim"
Searching for "/home/Dante/.vim/plugged/coc.nvim/colors/lists/default.vim"
Searching for "/home/Dante/.vim/plugged/vim-obsession/colors/lists/default.vim"
Searching for "/usr/share/vim/vimfiles/colors/lists/default.vim"
Searching for "/usr/share/vim/vim91/colors/lists/default.vim"
chdir(/usr/share/vim/vim91/colors/lists)
fchdir() to previous dir
line 57: sourcing "/usr/share/vim/vim91/colors/lists/default.vim"
line 1: " Maintainer:  Drew Vogel <dvogel@sidejump.org>
line 2: " Last Change: 2024 Mar 20
line 3: "
line 4: " Replaced rgb.txt as the source of de facto standard color names. This is
line 5: " sourced each time the colorscheme command is run. It is also sourced each
line 6: " time the highlight command fails to recognize a gui color. You can override
line 7: " these colors by introducing a new colors/lists/default.vim file earlier in
line 8: " the runtimepath.
line 9: " Note: the color names should be in lower case, because Vim will lookup the
line 10: " a color by its lower case name.
line 11: 
line 12: " make sure line continuation works
line 13: let s:keepcpo = &cpo
line 14: set cpo&vim
line 15: 
line 16: function! s:Cleanup()
line 20: 
line 21: function! s:AddColors(cnames) abort
line 40: 
line 41: if exists('s:default_cnames')
line 42:   call s:AddColors(s:default_cnames)
line 43:   call s:Cleanup()
line 44:   finish
line 45: endif
line 46: 
line 47: let s:default_cnames = { 'snow': '#fffafa', 'ghost white': '#f8f8ff', 'ghostwhite': '#f8f8ff', 'white smoke': '#f5f5f5', 'whitesmoke': '#f5f5f5', 'gainsboro': '#dcdcdc', 'floral white': '#fffaf0', 'floralwhite': '#fffaf0', 'old lace': '#fdf5e6', 'oldlace': '#fdf5e6', 'linen': '#faf0e6', 'antique white': '#faebd7', 'antiquewhite': '#faebd7', 'papaya whip': '#ffefd5', 'papayawhip': '#ffefd5', 'blanched almond': '#ffebcd', 'blanchedalmond': '#ffebcd', 'bisque': '#ffe4c4', 'peach puff': '#ffdab9', 'peachpuff': '#ffdab9', 'navajo white': '#ffdead', 'navajowhite': '#ffdead', 'moccasin': '#ffe4b5', 'cornsilk': '#fff8dc', 'ivory': '#fffff0', 'lemon chiffon': '#fffacd', 'lemonchiffon': '#fffacd', 'seashell': '#fff5ee', 'honeydew': '#f0fff0', 'mint cream': '#f5fffa', 'mintcream': '#f5fffa', 'azure': '#f0ffff', 'alice blue': '#f0f8ff', 'aliceblue': '#f0f8ff', 'lavender': '#e6e6fa', 'lavender blush': '#fff0f5', 'lavenderblush': '#fff0f5', 'misty rose': '#ffe4e1', 'mistyrose': '#ffe4e1', 'white': '#ffffff', 'blac
line 837: 
line 838: call s:AddColors(s:default_cnames)
calling <SNR>16_AddColors({'medium blue': '#0000cd', 'indianred'...mon3': '#cd7054', 'salmon4': '#8b4c39'})

line 1:   call extend(v:colornames, a:cnames, 'keep')
line 2: 
line 3:   " all keys should be in lower case, convert keys that are not yet
line 4:   let len_after = len(v:colornames)
line 5:   if len_after == len(a:cnames)
line 6:     " after extend(): v:colornames has all the keys of default_cnames
line 7:     " checked: v:colornames also has no extra keys
line 8:     " => keys are the same, and keys(default_cnames) are known to be ok
line 9:     return
<SNR>16_AddColors returning #0

continuing in /usr/share/vim/vim91/colors/lists/default.vim

line 839: call s:Cleanup()
calling <SNR>16_Cleanup()

line 1:   let &cpo = s:keepcpo
line 2:   unlet s:keepcpo
<SNR>16_Cleanup returning #0

continuing in /usr/share/vim/vim91/colors/lists/default.vim

line 840: 
line 841: "vim: sw=4
finished sourcing /usr/share/vim/vim91/colors/lists/default.vim
continuing in /usr/share/vim/vim91/syntax/syncolor.vim
Searching for "/usr/share/vim/vimfiles/after/colors/lists/default.vim"
Searching for "/home/Dante/.vim/plugged/vimtex/after/colors/lists/default.vim"
Searching for "/home/Dante/.vim/after/colors/lists/default.vim"
line 58:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 58: hi def Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 59:   SynColor Added^Iterm=NONE cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=NONE guifg=SeaGreen guibg=NONE
line 59: hi def Added^Iterm=NONE cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=NONE guifg=SeaGreen guibg=NONE
line 60:   SynColor Changed^Iterm=NONE cterm=NONE ctermfg=Blue ctermbg=NONE gui=NONE guifg=DodgerBlue guibg=NONE
line 60: hi def Changed^Iterm=NONE cterm=NONE ctermfg=Blue ctermbg=NONE gui=NONE guifg=DodgerBlue guibg=NONE
line 61:   SynColor Removed^Iterm=NONE cterm=NONE ctermfg=Red ctermbg=NONE gui=NONE guifg=Red guibg=NONE
line 61: hi def Removed^Iterm=NONE cterm=NONE ctermfg=Red ctermbg=NONE gui=NONE guifg=Red guibg=NONE
line 62: endif
line 63: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 63: hi def Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 64: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 64: hi def Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 65: 
line 66: " Common groups that link to default highlighting.
line 67: " You can specify other highlighting easily.
line 68: SynLink String^I^IConstant
line 68: hi def link String^I^IConstant
line 69: SynLink Character^IConstant
line 69: hi def link Character^IConstant
line 70: SynLink Number^I^IConstant
line 70: hi def link Number^I^IConstant
line 71: SynLink Boolean^I^IConstant
line 71: hi def link Boolean^I^IConstant
line 72: SynLink Float^I^INumber
line 72: hi def link Float^I^INumber
line 73: SynLink Function^IIdentifier
line 73: hi def link Function^IIdentifier
line 74: SynLink Conditional^IStatement
line 74: hi def link Conditional^IStatement
line 75: SynLink Repeat^I^IStatement
line 75: hi def link Repeat^I^IStatement
line 76: SynLink Label^I^IStatement
line 76: hi def link Label^I^IStatement
line 77: SynLink Operator^IStatement
line 77: hi def link Operator^IStatement
line 78: SynLink Keyword^I^IStatement
line 78: hi def link Keyword^I^IStatement
line 79: SynLink Exception^IStatement
line 79: hi def link Exception^IStatement
line 80: SynLink Include^I^IPreProc
line 80: hi def link Include^I^IPreProc
line 81: SynLink Define^I^IPreProc
line 81: hi def link Define^I^IPreProc
line 82: SynLink Macro^I^IPreProc
line 82: hi def link Macro^I^IPreProc
line 83: SynLink PreCondit^IPreProc
line 83: hi def link PreCondit^IPreProc
line 84: SynLink StorageClass^IType
line 84: hi def link StorageClass^IType
line 85: SynLink Structure^IType
line 85: hi def link Structure^IType
line 86: SynLink Typedef^I^IType
line 86: hi def link Typedef^I^IType
line 87: SynLink Tag^I^ISpecial
line 87: hi def link Tag^I^ISpecial
line 88: SynLink SpecialChar^ISpecial
line 88: hi def link SpecialChar^ISpecial
line 89: SynLink Delimiter^ISpecial
line 89: hi def link Delimiter^ISpecial
line 90: SynLink SpecialComment^ISpecial
line 90: hi def link SpecialComment^ISpecial
line 91: SynLink Debug^I^ISpecial
line 91: hi def link Debug^I^ISpecial
line 92: 
line 93: delcommand SynColor
line 94: delcommand SynLink
finished sourcing /usr/share/vim/vim91/syntax/syncolor.vim
continuing in /usr/share/vim/vim91/syntax/synload.vim
Searching for "/usr/share/vim/vimfiles/after/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/vimtex/after/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/after/syntax/syncolor.vim"
line 23: endif
line 24: 
line 25: " Line continuation is used here, remove 'C' from 'cpoptions'
line 26: let s:cpo_save = &cpo
line 27: set cpo&vim
line 28: 
line 29: " First remove all old syntax autocommands.
line 30: au! Syntax
line 31: 
line 32: au Syntax *^I^Icall s:SynSet()
line 33: 
line 34: fun! s:SynSet()
line 64: 
line 65: 
line 66: " Handle adding doxygen to other languages (C, C++, C#, IDL, java, php, DataScript)
line 67: au Syntax c,cpp,cs,idl,java,php,datascript if (exists('b:load_doxygen_syntax') && b:load_doxygen_syntax)^I|| (exists('g:load_doxygen_syntax') && g:load_doxygen_syntax)   | runtime! syntax/doxygen.vim | endif
line 72: 
line 73: 
line 74: " Source the user-specified syntax highlighting file
line 75: if exists("mysyntaxfile")
line 76:   let s:fname = expand(mysyntaxfile)
line 77:   if filereadable(s:fname)
line 78:     execute "source " . fnameescape(s:fname)
line 79:   endif
line 80: endif
line 81: 
line 82: " Restore 'cpoptions'
line 83: let &cpo = s:cpo_save
line 84: unlet s:cpo_save
finished sourcing /usr/share/vim/vim91/syntax/synload.vim
continuing in /usr/share/vim/vim91/syntax/syntax.vim
line 21: 
line 22: " Load the FileType autocommands if not done yet.
line 23: if exists("did_load_filetypes")
line 24:   let s:did_ft = 1
line 25: else
line 26:   filetype on
line 27:   let s:did_ft = 0
line 28: endif
line 29: 
line 30: " Set up the connection between FileType and Syntax autocommands.
line 31: " This makes the syntax automatically set when the file type is detected.
line 32: " Avoid an error when 'verbose' is set and <amatch> expansion fails.
line 33: augroup syntaxset
line 34:   au! FileType *^I0verbose exe "set syntax=" . expand("<amatch>")
line 35: augroup END
line 36: 
line 37: 
line 38: " Execute the syntax autocommands for the each buffer.
line 39: " If the filetype wasn't detected yet, do that now.
line 40: " Always do the syntaxset autocommands, for buffers where the 'filetype'
line 41: " already was set manually (e.g., help buffers).
line 42: doautoall syntaxset FileType
Executing FileType Autocommands for "*"
autocommand 0verbose exe "set syntax=" . expand("<amatch>")

Executing: 0verbose exe "set syntax=" . expand("<amatch>")
line 43: if !s:did_ft
line 44:   doautoall filetypedetect BufRead
line 45: endif
finished sourcing /usr/share/vim/vim91/syntax/syntax.vim
continuing in plug#end
line 90:     end
line 91:   else
line 92:     call s:reload_plugins()
line 93:   endif
plug#end returning #0

continuing in /home/Dante/.vimrc

line 64: "}}}
line 65: 
line 66: "General Binds {{{
line 67: let mapleader=" "
line 68: let maplocalleader="\\"
line 69: nnoremap <leader>s :w<CR>
line 70: nnoremap <leader>r :source ~/.vimrc<CR>
line 71: nnoremap <leader>i :PlugInstall<CR>
line 72: nnoremap <leader>u :PlugUpdate<CR>
line 73: nnoremap <leader>f :SFiles<CR>
line 74: nnoremap <leader>g :Rg<CR>
line 75: nnoremap <leader>n :bnext<CR>
line 76: nnoremap <leader>p :bprev<CR>
line 77: nnoremap <leader>b :Buffers<CR>
line 78: nnoremap <leader>v :vsplit<CR>
line 79: nnoremap <leader>c :CocConfig<CR>
line 80: nnoremap <leader>ev :vsplit $MYVIMRC<CR>
line 81: nnoremap - ddp
line 82: nnoremap _ ddkkp
line 83: noremap H 0
line 84: noremap L $
line 85: 
line 86: "}}}
line 87: 
line 88: "Functions {{{
line 89: 
line 90: "This is from the Coc.nvim documentation
line 91: function! ShowDocumentation()
line 98: 
line 99: "}}}
line 100: 
line 101: "Vimscript {{{
line 102: augroup filetype_vim
line 103:     autocmd!
line 104:     autocmd FileType vim nnoremap c I"<esc>$
line 105:     autocmd FileType vim nnoremap C ^x<esc>$
line 106:     autocmd FileType vim setlocal foldmethod=marker
line 107: augroup END
line 108: "}}}
line 109: 
line 110: "Tmux {{{
line 111: augroup filetype_tmux
line 112:     autocmd!
line 113:     autocmd FileType tmux nnoremap c I#<esc>$
line 114:     autocmd FileType tmux nnoremap C ^x<esc>$
line 115:     autocmd FileType tmux set tabstop=4
line 116:     autocmd FileType tmux set shiftwidth=4
line 117: augroup END
line 118: "}}}
line 119: 
line 120: "LaTeX {{{
line 121: augroup filetype_tex
line 122:     autocmd!
line 123:     autocmd FileType tex nnoremap <buffer>c I%<esc>$
line 124:     autocmd FileType tex nnoremap <buffer>C ^x<esc>$
line 125:     autocmd FileType tex setlocal textwidth=80
line 126:     autocmd FileType tex setlocal autoindent
line 127:     "autocmd FileType tex nnoremap <buffer> <localleader>b viwbf_hc\bs{}<esc>P
line 128:     autocmd FileType tex vnoremap <buffer> <localleader>b c\bs{}<esc>P
line 129:     autocmd FileType tex vnoremap <buffer> <localleader>m c$$<esc>P
line 130:     autocmd FileType tex vnoremap <buffer> <localleader>c c%<esc>p
line 131:     autocmd FileType tex vnoremap <buffer> <localleader>h c\hl{}<esc>P
line 132: augroup END
line 133: "}}}
line 134: 
line 135: "Python {{{
line 136: "I don't really use python that much, but if I ever do again this will get
line 137: "longer trust me
line 138: augroup filetype_python
line 139:     autocmd!
line 140:     autocmd FileType python nnoremap <buffer> c I#<esc>$
line 141:     autocmd FileType python nnoremap <buffer> C 
line 142:     autocmd FileType python setlocal textwidth=80
line 143:     autocmd FileType python setlocal autoindent
line 144: augroup END
line 145: "}}}
line 146: 
line 147: "Fortran {{{
line 148: augroup filetype_fortran 
line 149:     autocmd!
line 150:     autocmd FileType fortran nnoremap <buffer> c I!<esc>$
line 151:     autocmd FileType fortran nnoremap <buffer> C ^x$
line 152:     autocmd FileType fortran :iabbrev <buffer> do <esc>:set autoindent <cr>Ado<cr><cr>end do <esc>:set noautoindent <cr>kkA
line 153:     autocmd FileType fortran :iabbrev <buffer> sr <esc>:set autoindent <cr>Asubroutine<cr><cr>implicit none<cr><cr>end subroutine <esc>:set noautoindent <cr>kkkkA
line 154:     autocmd FileType fortran :iabbrev <buffer> md <esc>:set autoindent <cr>Amodule<cr><cr>implicit none<cr><cr>end module<esc>:set noautoindent <cr>kkkkA
line 155:     autocmd FileType fortran :iabbrev <buffer> pg <esc>:set autoindent <cr>Aprogram<cr><cr>implicit none<cr><cr>end program<esc>:set noautoindent <cr>kkkkA
line 156:     autocmd FileType fortran :iabbrev <buffer> fct <esc>:set autoindent <cr>Afunction<cr><cr>implicit none<cr><cr>end function<esc>:set noautoindent <cr>kkkkA
line 157:     autocmd FileType fortran :iabbrev <buffer> lg logical ::
line 158:     autocmd FileType fortran :iabbrev <buffer> rd real, dimension() :: <esc>F)i
line 159:     autocmd FileType fortran :iabbrev <buffer> ra real, allocatable :: 
line 160:     autocmd FileType fortran nnoremap <buffer> <localleader>n i&<cr><esc>
line 161:     autocmd FileType fortran nnoremap <buffer> <TAB> >>
line 162:     autocmd FileType fortran vnoremap <buffer> ( c()<esc>P
line 163:     "autocmd FileType fortran :iabbrev <buffer> ( ()<esc>i
line 164:     autocmd FileType fortran setlocal textwidth=80
line 165:     autocmd FileType fortran setlocal tabstop=2
line 166:     autocmd FileType fortran setlocal shiftwidth=2
line 167:     autocmd FileType fortran setlocal foldmethod=indent
line 168: augroup END
line 169: "}}}
line 170: 
line 171: "Matlab {{{
line 172: augroup filetype_matlab
line 173:     autocmd FileType matlab nnoremap <buffer>c I%<esc>$
line 174:     autocmd FileType matlab nnoremap <buffer>C ^x<esc>$
line 175: augroup END
line 176: "}}}
line 177: 
line 178: "Make {{{
line 179: augroup filetype_make
line 180:     autocmd!
line 181:     autocmd FileType make nnoremap c I#<esc>$
line 182:     autocmd FileType make nnoremap C ^x<esc>$
line 183:     autocmd FileType make nnoremap - ddp
line 184:     autocmd FileType make nnoremap _ ddkkp
line 185: augroup END
line 186: "}}}
line 187: 
line 188: "SBatch (PBS) / Shell (sh) {{{
line 189: "I don't do shell script editting all that much so this is not the most used. 
line 190: augroup filetype_pbs
line 191:     autocmd!
line 192:     autocmd FileType sh :nnoremap <buffer> c I#<esc>$
line 193:     autocmd FileType sh :nnoremap <buffer> C I#<esc>$
line 194: augroup END 
line 195: 
line 196: "}}}
line 197: 
line 198: "LSP {{{
line 199: 
line 200: "Some of the Coc Config file contains LSP configuration options. This section is to adjust binds and vim functions that utilize the LSP
line 201: 
line 202: " use <tab> to trigger completion and navigate to the next complete item
line 203: function! CheckBackspace() abort
line 207: 
line 208: "Use tab to refresh the list
line 209: inoremap <silent><expr> <Tab> coc#pum#visible() ? coc#pum#next(1) : CheckBackspace() ? "\<Tab>" : coc#refresh()
line 213: "Press shift+k in order to show documentation for a function
line 214: nnoremap <silent> K :call ShowDocumentation()<CR>
line 215: nnoremap <silent> gd <Plug>(coc-definition)
line 216: nnoremap <silent> gy <Plug>(coc-type-definition)
line 217: nnoremap <silent> gi <Plug>(coc-implementation)
line 218: nnoremap <silent> gr <Plug>(coc-references)
line 219: 
line 220: 
line 221: "Use Tab / Shift+Tab in order to navigate the dropdown
line 222: inoremap <expr> <Tab> coc#pum#visible() ? coc#pum#next(1) : "\<Tab>"
line 223: inoremap <expr> <S-Tab> coc#pum#visible() ? coc#pum#prev(1) : "\<S-Tab>"
line 224: 
line 225: "Use <CR> in order to select an option from the LSP dropdown
line 226: inoremap <expr> <cr> coc#pum#visible() ? coc#pum#confirm() : "\<CR>"
line 227: 
line 228: "}}}
line 229: 
line 230: "General Settings {{{
line 231: set updatetime=300
line 232: set mouse=a
line 233: set encoding=UTF-8
line 234: set ignorecase
line 235: set smartcase
line 236: set linebreak
line 237: set tabstop=4
line 238: set shiftwidth=4
line 239: set expandtab
line 240: set autoread
line 241: set hlsearch incsearch
line 242: set clipboard=unnamedplus
line 243: 
line 244: set cursorline
line 245: set number 
line 246: set signcolumn=yes
line 247: 
line 248: set background=dark
Searching for "syntax/syncolor.vim" in "/home/Dante/.vim,/home/Dante/.vim/plugged/onedark.vim,/home/Dante/.vim/plugged/onehalf/vim,/home/Dante/.vim/plugged/gruvbox,/home/Dante/.vim/plugged/lightline.vim,/home/Dante/.vim/plugged/vim-tmux-navigator,/home/Dante/.vim/plugged/vimtex,/home/Dante/.vim/plugged/nerdtree,/home/Dante/.vim/plugged/fzf,/home/Dante/.vim/plugged/fzf.vim,/home/Dante/.vim/plugged/vim-wayland-clipboard,/home/Dante/.vim/plugged/coc.nvim,/home/Dante/.vim/plugged/vim-obsession,/usr/share/vim/vimfiles,/usr/share/vim/vim91,/usr/share/vim/vimfiles/after,/home/Dante/.vim/plugged/vimtex/after,/home/Dante/.vim/after"
Searching for "/home/Dante/.vim/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/onedark.vim/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/onehalf/vim/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/gruvbox/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/lightline.vim/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/vim-tmux-navigator/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/vimtex/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/nerdtree/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/fzf/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/fzf.vim/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/vim-wayland-clipboard/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/coc.nvim/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/vim-obsession/syntax/syncolor.vim"
Searching for "/usr/share/vim/vimfiles/syntax/syncolor.vim"
Searching for "/usr/share/vim/vim91/syntax/syncolor.vim"
chdir(/usr/share/vim/vim91/syntax)
fchdir() to previous dir
line 248: sourcing "/usr/share/vim/vim91/syntax/syncolor.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 3: " Last Change:^I2023 Aug 10
line 4: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 5: 
line 6: " This file sets up the default methods for highlighting.
line 7: " It is loaded from "synload.vim" and from Vim for ":syntax reset".
line 8: " Also used from init_highlight().
line 9: 
line 10: if !exists("syntax_cmd") || syntax_cmd == "on"
line 11:   " ":syntax on" works like in Vim 5.7: set colors but keep links
line 12:   command -nargs=* SynColor hi <args>
line 13:   command -nargs=* SynLink hi link <args>
line 14: else
line 15:   if syntax_cmd == "enable"
line 16:     " ":syntax enable" keeps any existing colors
line 17:     command -nargs=* SynColor hi def <args>
line 18:     command -nargs=* SynLink hi def link <args>
line 19:   elseif syntax_cmd == "reset"
line 20:     " ":syntax reset" resets all colors to the default
line 21:     command -nargs=* SynColor hi <args>
line 22:     command -nargs=* SynLink hi! link <args>
line 23:   else
line 24:     " User defined syncolor file has already set the colors.
line 25:     finish
line 26:   endif
line 27: endif
line 28: 
line 29: " Many terminals can only use six different colors (plus black and white).
line 30: " Therefore the number of colors used is kept low. It doesn't look nice with
line 31: " too many colors anyway.
line 32: " Careful with "cterm=bold", it changes the color to bright for some terminals.
line 33: " There are two sets of defaults: for a dark and a light background.
line 34: if &background == "dark"
line 35:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 35: hi Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 36:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 36: hi Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 37:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 37: hi Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 38:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 38: hi Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 39:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 39: hi Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 40:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 40: hi PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 41:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 41: hi Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 42:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 42: hi Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 43:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 43: hi Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 44:   SynColor Added^Iterm=NONE cterm=NONE ctermfg=Green ctermbg=NONE gui=NONE guifg=LimeGreen guibg=NONE
line 44: hi Added^Iterm=NONE cterm=NONE ctermfg=Green ctermbg=NONE gui=NONE guifg=LimeGreen guibg=NONE
line 45:   SynColor Changed^Iterm=NONE cterm=NONE ctermfg=Blue ctermbg=NONE gui=NONE guifg=DodgerBlue guibg=NONE
line 45: hi Changed^Iterm=NONE cterm=NONE ctermfg=Blue ctermbg=NONE gui=NONE guifg=DodgerBlue guibg=NONE
line 46:   SynColor Removed^Iterm=NONE cterm=NONE ctermfg=Red ctermbg=NONE gui=NONE guifg=Red guibg=NONE
line 46: hi Removed^Iterm=NONE cterm=NONE ctermfg=Red ctermbg=NONE gui=NONE guifg=Red guibg=NONE
line 47: else
line 48:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
line 49:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
line 50:   " #6a5acd is SlateBlue
line 51:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=#6a5acd guibg=NONE
line 52:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
line 53:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
line 54:   " #6a0dad is Purple
line 55:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=#6a0dad guibg=NONE
line 56:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
line 57:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
line 58:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 59:   SynColor Added^Iterm=NONE cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=NONE guifg=SeaGreen guibg=NONE
line 60:   SynColor Changed^Iterm=NONE cterm=NONE ctermfg=Blue ctermbg=NONE gui=NONE guifg=DodgerBlue guibg=NONE
line 61:   SynColor Removed^Iterm=NONE cterm=NONE ctermfg=Red ctermbg=NONE gui=NONE guifg=Red guibg=NONE
line 62: endif
line 63: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 63: hi Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 64: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 64: hi Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 65: 
line 66: " Common groups that link to default highlighting.
line 67: " You can specify other highlighting easily.
line 68: SynLink String^I^IConstant
line 68: hi link String^I^IConstant
line 69: SynLink Character^IConstant
line 69: hi link Character^IConstant
line 70: SynLink Number^I^IConstant
line 70: hi link Number^I^IConstant
line 71: SynLink Boolean^I^IConstant
line 71: hi link Boolean^I^IConstant
line 72: SynLink Float^I^INumber
line 72: hi link Float^I^INumber
line 73: SynLink Function^IIdentifier
line 73: hi link Function^IIdentifier
line 74: SynLink Conditional^IStatement
line 74: hi link Conditional^IStatement
line 75: SynLink Repeat^I^IStatement
line 75: hi link Repeat^I^IStatement
line 76: SynLink Label^I^IStatement
line 76: hi link Label^I^IStatement
line 77: SynLink Operator^IStatement
line 77: hi link Operator^IStatement
line 78: SynLink Keyword^I^IStatement
line 78: hi link Keyword^I^IStatement
line 79: SynLink Exception^IStatement
line 79: hi link Exception^IStatement
line 80: SynLink Include^I^IPreProc
line 80: hi link Include^I^IPreProc
line 81: SynLink Define^I^IPreProc
line 81: hi link Define^I^IPreProc
line 82: SynLink Macro^I^IPreProc
line 82: hi link Macro^I^IPreProc
line 83: SynLink PreCondit^IPreProc
line 83: hi link PreCondit^IPreProc
line 84: SynLink StorageClass^IType
line 84: hi link StorageClass^IType
line 85: SynLink Structure^IType
line 85: hi link Structure^IType
line 86: SynLink Typedef^I^IType
line 86: hi link Typedef^I^IType
line 87: SynLink Tag^I^ISpecial
line 87: hi link Tag^I^ISpecial
line 88: SynLink SpecialChar^ISpecial
line 88: hi link SpecialChar^ISpecial
line 89: SynLink Delimiter^ISpecial
line 89: hi link Delimiter^ISpecial
line 90: SynLink SpecialComment^ISpecial
line 90: hi link SpecialComment^ISpecial
line 91: SynLink Debug^I^ISpecial
line 91: hi link Debug^I^ISpecial
line 92: 
line 93: delcommand SynColor
line 94: delcommand SynLink
finished sourcing /usr/share/vim/vim91/syntax/syncolor.vim
continuing in /home/Dante/.vimrc
Searching for "/usr/share/vim/vimfiles/after/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/vimtex/after/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/after/syntax/syncolor.vim"
line 249: filetype indent off
Searching for "indoff.vim" in "/home/Dante/.vim,/home/Dante/.vim/plugged/onedark.vim,/home/Dante/.vim/plugged/onehalf/vim,/home/Dante/.vim/plugged/gruvbox,/home/Dante/.vim/plugged/lightline.vim,/home/Dante/.vim/plugged/vim-tmux-navigator,/home/Dante/.vim/plugged/vimtex,/home/Dante/.vim/plugged/nerdtree,/home/Dante/.vim/plugged/fzf,/home/Dante/.vim/plugged/fzf.vim,/home/Dante/.vim/plugged/vim-wayland-clipboard,/home/Dante/.vim/plugged/coc.nvim,/home/Dante/.vim/plugged/vim-obsession,/usr/share/vim/vimfiles,/usr/share/vim/vim91,/usr/share/vim/vimfiles/after,/home/Dante/.vim/plugged/vimtex/after,/home/Dante/.vim/after"
Searching for "/home/Dante/.vim/indoff.vim"
Searching for "/home/Dante/.vim/plugged/onedark.vim/indoff.vim"
Searching for "/home/Dante/.vim/plugged/onehalf/vim/indoff.vim"
Searching for "/home/Dante/.vim/plugged/gruvbox/indoff.vim"
Searching for "/home/Dante/.vim/plugged/lightline.vim/indoff.vim"
Searching for "/home/Dante/.vim/plugged/vim-tmux-navigator/indoff.vim"
Searching for "/home/Dante/.vim/plugged/vimtex/indoff.vim"
Searching for "/home/Dante/.vim/plugged/nerdtree/indoff.vim"
Searching for "/home/Dante/.vim/plugged/fzf/indoff.vim"
Searching for "/home/Dante/.vim/plugged/fzf.vim/indoff.vim"
Searching for "/home/Dante/.vim/plugged/vim-wayland-clipboard/indoff.vim"
Searching for "/home/Dante/.vim/plugged/coc.nvim/indoff.vim"
Searching for "/home/Dante/.vim/plugged/vim-obsession/indoff.vim"
Searching for "/usr/share/vim/vimfiles/indoff.vim"
Searching for "/usr/share/vim/vim91/indoff.vim"
chdir(/usr/share/vim/vim91)
fchdir() to previous dir
line 249: sourcing "/usr/share/vim/vim91/indoff.vim"
line 1: " Vim support file to switch off loading indent files for file types
line 2: "
line 3: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 4: " Last Change:^I2023 Aug 10
line 5: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 6: 
line 7: if exists("did_indent_on")
line 8:   unlet did_indent_on
line 9: endif
line 10: 
line 11: " Remove all autocommands in the filetypeindent group
line 12: silent! au! filetypeindent *
finished sourcing /usr/share/vim/vim91/indoff.vim
continuing in /home/Dante/.vimrc
Searching for "/usr/share/vim/vimfiles/after/indoff.vim"
Searching for "/home/Dante/.vim/plugged/vimtex/after/indoff.vim"
Searching for "/home/Dante/.vim/after/indoff.vim"
line 250: syntax on
line 250: so $VIMRUNTIME/syntax/syntax.vim
chdir(/usr/share/vim/vim91/syntax)
fchdir() to previous dir
line 250: sourcing "/usr/share/vim/vim91/syntax/syntax.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 3: " Last Change:^I2023 Aug 10
line 4: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 5: 
line 6: " This file is used for ":syntax on".
line 7: " It installs the autocommands and starts highlighting for all buffers.
line 8: 
line 9: if !has("syntax")
line 10:   finish
line 11: endif
line 12: 
line 13: " If Syntax highlighting appears to be on already, turn it off first, so that
line 14: " any leftovers are cleared.
line 15: if exists("syntax_on") || exists("syntax_manual")
line 16:   so <sfile>:p:h/nosyntax.vim
chdir(/usr/share/vim/vim91/syntax)
fchdir() to previous dir
line 16: sourcing "/usr/share/vim/vim91/syntax/nosyntax.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 3: " Last Change:^I2023 Aug 10
line 4: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 5: 
line 6: " This file is used for ":syntax off".
line 7: " It removes the autocommands and stops highlighting for all buffers.
line 8: 
line 9: if !has("syntax")
line 10:   finish
line 11: endif
line 12: 
line 13: " Remove all autocommands for the Syntax event.  This also avoids that
line 14: " "syntax=foo" in a modeline triggers the SynSet() function of synload.vim.
line 15: au! Syntax
line 16: 
line 17: " remove all syntax autocommands and remove the syntax for each buffer
line 18: augroup syntaxset
line 19:   au!
line 20:   au BufEnter * syn clear
line 21:   au BufEnter * if exists("b:current_syntax") | unlet b:current_syntax | endif
line 22:   doautoall syntaxset BufEnter *
Executing BufEnter Autocommands for "*"
autocommand syn clear

Executing: syn clear
autocommand if exists("b:current_syntax") | unlet b:current_syntax | endif

Executing: if exists("b:current_syntax") | unlet b:current_syntax | endif
Executing:  unlet b:current_syntax | endif
Executing:  endif
line 23:   au!
line 24: augroup END
line 25: 
line 26: if exists("syntax_on")
line 27:   unlet syntax_on
line 28: endif
line 29: if exists("syntax_manual")
line 30:   unlet syntax_manual
line 31: endif
finished sourcing /usr/share/vim/vim91/syntax/nosyntax.vim
continuing in /usr/share/vim/vim91/syntax/syntax.vim
line 17: endif
line 18: 
line 19: " Load the Syntax autocommands and set the default methods for highlighting.
line 20: runtime syntax/synload.vim
Searching for "syntax/synload.vim" in "/home/Dante/.vim,/home/Dante/.vim/plugged/onedark.vim,/home/Dante/.vim/plugged/onehalf/vim,/home/Dante/.vim/plugged/gruvbox,/home/Dante/.vim/plugged/lightline.vim,/home/Dante/.vim/plugged/vim-tmux-navigator,/home/Dante/.vim/plugged/vimtex,/home/Dante/.vim/plugged/nerdtree,/home/Dante/.vim/plugged/fzf,/home/Dante/.vim/plugged/fzf.vim,/home/Dante/.vim/plugged/vim-wayland-clipboard,/home/Dante/.vim/plugged/coc.nvim,/home/Dante/.vim/plugged/vim-obsession,/usr/share/vim/vimfiles,/usr/share/vim/vim91,/usr/share/vim/vimfiles/after,/home/Dante/.vim/plugged/vimtex/after,/home/Dante/.vim/after"
Searching for "/home/Dante/.vim/syntax/synload.vim"
Searching for "/home/Dante/.vim/plugged/onedark.vim/syntax/synload.vim"
Searching for "/home/Dante/.vim/plugged/onehalf/vim/syntax/synload.vim"
Searching for "/home/Dante/.vim/plugged/gruvbox/syntax/synload.vim"
Searching for "/home/Dante/.vim/plugged/lightline.vim/syntax/synload.vim"
Searching for "/home/Dante/.vim/plugged/vim-tmux-navigator/syntax/synload.vim"
Searching for "/home/Dante/.vim/plugged/vimtex/syntax/synload.vim"
Searching for "/home/Dante/.vim/plugged/nerdtree/syntax/synload.vim"
Searching for "/home/Dante/.vim/plugged/fzf/syntax/synload.vim"
Searching for "/home/Dante/.vim/plugged/fzf.vim/syntax/synload.vim"
Searching for "/home/Dante/.vim/plugged/vim-wayland-clipboard/syntax/synload.vim"
Searching for "/home/Dante/.vim/plugged/coc.nvim/syntax/synload.vim"
Searching for "/home/Dante/.vim/plugged/vim-obsession/syntax/synload.vim"
Searching for "/usr/share/vim/vimfiles/syntax/synload.vim"
Searching for "/usr/share/vim/vim91/syntax/synload.vim"
chdir(/usr/share/vim/vim91/syntax)
fchdir() to previous dir
line 20: sourcing "/usr/share/vim/vim91/syntax/synload.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 3: " Last Change:^I2023 Aug 10
line 4: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 5: 
line 6: " This file sets up for syntax highlighting.
line 7: " It is loaded from "syntax.vim" and "manual.vim".
line 8: " 1. Set the default highlight groups.
line 9: " 2. Install Syntax autocommands for all the available syntax files.
line 10: 
line 11: if !has("syntax")
line 12:   finish
line 13: endif
line 14: 
line 15: " let others know that syntax has been switched on
line 16: let syntax_on = 1
line 17: 
line 18: " Set the default highlighting colors.  Use a color scheme if specified.
line 19: if exists("colors_name")
line 20:   exe "colors " . colors_name
line 21: else
line 22:   runtime! syntax/syncolor.vim
Searching for "syntax/syncolor.vim" in "/home/Dante/.vim,/home/Dante/.vim/plugged/onedark.vim,/home/Dante/.vim/plugged/onehalf/vim,/home/Dante/.vim/plugged/gruvbox,/home/Dante/.vim/plugged/lightline.vim,/home/Dante/.vim/plugged/vim-tmux-navigator,/home/Dante/.vim/plugged/vimtex,/home/Dante/.vim/plugged/nerdtree,/home/Dante/.vim/plugged/fzf,/home/Dante/.vim/plugged/fzf.vim,/home/Dante/.vim/plugged/vim-wayland-clipboard,/home/Dante/.vim/plugged/coc.nvim,/home/Dante/.vim/plugged/vim-obsession,/usr/share/vim/vimfiles,/usr/share/vim/vim91,/usr/share/vim/vimfiles/after,/home/Dante/.vim/plugged/vimtex/after,/home/Dante/.vim/after"
Searching for "/home/Dante/.vim/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/onedark.vim/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/onehalf/vim/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/gruvbox/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/lightline.vim/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/vim-tmux-navigator/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/vimtex/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/nerdtree/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/fzf/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/fzf.vim/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/vim-wayland-clipboard/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/coc.nvim/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/vim-obsession/syntax/syncolor.vim"
Searching for "/usr/share/vim/vimfiles/syntax/syncolor.vim"
Searching for "/usr/share/vim/vim91/syntax/syncolor.vim"
chdir(/usr/share/vim/vim91/syntax)
fchdir() to previous dir
line 22: sourcing "/usr/share/vim/vim91/syntax/syncolor.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 3: " Last Change:^I2023 Aug 10
line 4: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 5: 
line 6: " This file sets up the default methods for highlighting.
line 7: " It is loaded from "synload.vim" and from Vim for ":syntax reset".
line 8: " Also used from init_highlight().
line 9: 
line 10: if !exists("syntax_cmd") || syntax_cmd == "on"
line 11:   " ":syntax on" works like in Vim 5.7: set colors but keep links
line 12:   command -nargs=* SynColor hi <args>
line 13:   command -nargs=* SynLink hi link <args>
line 14: else
line 15:   if syntax_cmd == "enable"
line 16:     " ":syntax enable" keeps any existing colors
line 17:     command -nargs=* SynColor hi def <args>
line 18:     command -nargs=* SynLink hi def link <args>
line 19:   elseif syntax_cmd == "reset"
line 20:     " ":syntax reset" resets all colors to the default
line 21:     command -nargs=* SynColor hi <args>
line 22:     command -nargs=* SynLink hi! link <args>
line 23:   else
line 24:     " User defined syncolor file has already set the colors.
line 25:     finish
line 26:   endif
line 27: endif
line 28: 
line 29: " Many terminals can only use six different colors (plus black and white).
line 30: " Therefore the number of colors used is kept low. It doesn't look nice with
line 31: " too many colors anyway.
line 32: " Careful with "cterm=bold", it changes the color to bright for some terminals.
line 33: " There are two sets of defaults: for a dark and a light background.
line 34: if &background == "dark"
line 35:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 35: hi Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 36:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 36: hi Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 37:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 37: hi Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 38:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 38: hi Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 39:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 39: hi Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 40:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 40: hi PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 41:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 41: hi Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 42:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 42: hi Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 43:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 43: hi Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 44:   SynColor Added^Iterm=NONE cterm=NONE ctermfg=Green ctermbg=NONE gui=NONE guifg=LimeGreen guibg=NONE
line 44: hi Added^Iterm=NONE cterm=NONE ctermfg=Green ctermbg=NONE gui=NONE guifg=LimeGreen guibg=NONE
line 45:   SynColor Changed^Iterm=NONE cterm=NONE ctermfg=Blue ctermbg=NONE gui=NONE guifg=DodgerBlue guibg=NONE
line 45: hi Changed^Iterm=NONE cterm=NONE ctermfg=Blue ctermbg=NONE gui=NONE guifg=DodgerBlue guibg=NONE
line 46:   SynColor Removed^Iterm=NONE cterm=NONE ctermfg=Red ctermbg=NONE gui=NONE guifg=Red guibg=NONE
line 46: hi Removed^Iterm=NONE cterm=NONE ctermfg=Red ctermbg=NONE gui=NONE guifg=Red guibg=NONE
line 47: else
line 48:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
line 49:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
line 50:   " #6a5acd is SlateBlue
line 51:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=#6a5acd guibg=NONE
line 52:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
line 53:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
line 54:   " #6a0dad is Purple
line 55:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=#6a0dad guibg=NONE
line 56:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
line 57:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
line 58:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 59:   SynColor Added^Iterm=NONE cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=NONE guifg=SeaGreen guibg=NONE
line 60:   SynColor Changed^Iterm=NONE cterm=NONE ctermfg=Blue ctermbg=NONE gui=NONE guifg=DodgerBlue guibg=NONE
line 61:   SynColor Removed^Iterm=NONE cterm=NONE ctermfg=Red ctermbg=NONE gui=NONE guifg=Red guibg=NONE
line 62: endif
line 63: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 63: hi Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 64: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 64: hi Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 65: 
line 66: " Common groups that link to default highlighting.
line 67: " You can specify other highlighting easily.
line 68: SynLink String^I^IConstant
line 68: hi link String^I^IConstant
line 69: SynLink Character^IConstant
line 69: hi link Character^IConstant
line 70: SynLink Number^I^IConstant
line 70: hi link Number^I^IConstant
line 71: SynLink Boolean^I^IConstant
line 71: hi link Boolean^I^IConstant
line 72: SynLink Float^I^INumber
line 72: hi link Float^I^INumber
line 73: SynLink Function^IIdentifier
line 73: hi link Function^IIdentifier
line 74: SynLink Conditional^IStatement
line 74: hi link Conditional^IStatement
line 75: SynLink Repeat^I^IStatement
line 75: hi link Repeat^I^IStatement
line 76: SynLink Label^I^IStatement
line 76: hi link Label^I^IStatement
line 77: SynLink Operator^IStatement
line 77: hi link Operator^IStatement
line 78: SynLink Keyword^I^IStatement
line 78: hi link Keyword^I^IStatement
line 79: SynLink Exception^IStatement
line 79: hi link Exception^IStatement
line 80: SynLink Include^I^IPreProc
line 80: hi link Include^I^IPreProc
line 81: SynLink Define^I^IPreProc
line 81: hi link Define^I^IPreProc
line 82: SynLink Macro^I^IPreProc
line 82: hi link Macro^I^IPreProc
line 83: SynLink PreCondit^IPreProc
line 83: hi link PreCondit^IPreProc
line 84: SynLink StorageClass^IType
line 84: hi link StorageClass^IType
line 85: SynLink Structure^IType
line 85: hi link Structure^IType
line 86: SynLink Typedef^I^IType
line 86: hi link Typedef^I^IType
line 87: SynLink Tag^I^ISpecial
line 87: hi link Tag^I^ISpecial
line 88: SynLink SpecialChar^ISpecial
line 88: hi link SpecialChar^ISpecial
line 89: SynLink Delimiter^ISpecial
line 89: hi link Delimiter^ISpecial
line 90: SynLink SpecialComment^ISpecial
line 90: hi link SpecialComment^ISpecial
line 91: SynLink Debug^I^ISpecial
line 91: hi link Debug^I^ISpecial
line 92: 
line 93: delcommand SynColor
line 94: delcommand SynLink
finished sourcing /usr/share/vim/vim91/syntax/syncolor.vim
continuing in /usr/share/vim/vim91/syntax/synload.vim
Searching for "/usr/share/vim/vimfiles/after/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/vimtex/after/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/after/syntax/syncolor.vim"
line 23: endif
line 24: 
line 25: " Line continuation is used here, remove 'C' from 'cpoptions'
line 26: let s:cpo_save = &cpo
line 27: set cpo&vim
line 28: 
line 29: " First remove all old syntax autocommands.
line 30: au! Syntax
line 31: 
line 32: au Syntax *^I^Icall s:SynSet()
line 33: 
line 34: fun! s:SynSet()
line 64: 
line 65: 
line 66: " Handle adding doxygen to other languages (C, C++, C#, IDL, java, php, DataScript)
line 67: au Syntax c,cpp,cs,idl,java,php,datascript if (exists('b:load_doxygen_syntax') && b:load_doxygen_syntax)^I|| (exists('g:load_doxygen_syntax') && g:load_doxygen_syntax)   | runtime! syntax/doxygen.vim | endif
line 72: 
line 73: 
line 74: " Source the user-specified syntax highlighting file
line 75: if exists("mysyntaxfile")
line 76:   let s:fname = expand(mysyntaxfile)
line 77:   if filereadable(s:fname)
line 78:     execute "source " . fnameescape(s:fname)
line 79:   endif
line 80: endif
line 81: 
line 82: " Restore 'cpoptions'
line 83: let &cpo = s:cpo_save
line 84: unlet s:cpo_save
finished sourcing /usr/share/vim/vim91/syntax/synload.vim
continuing in /usr/share/vim/vim91/syntax/syntax.vim
line 21: 
line 22: " Load the FileType autocommands if not done yet.
line 23: if exists("did_load_filetypes")
line 24:   let s:did_ft = 1
line 25: else
line 26:   filetype on
line 27:   let s:did_ft = 0
line 28: endif
line 29: 
line 30: " Set up the connection between FileType and Syntax autocommands.
line 31: " This makes the syntax automatically set when the file type is detected.
line 32: " Avoid an error when 'verbose' is set and <amatch> expansion fails.
line 33: augroup syntaxset
line 34:   au! FileType *^I0verbose exe "set syntax=" . expand("<amatch>")
line 35: augroup END
line 36: 
line 37: 
line 38: " Execute the syntax autocommands for the each buffer.
line 39: " If the filetype wasn't detected yet, do that now.
line 40: " Always do the syntaxset autocommands, for buffers where the 'filetype'
line 41: " already was set manually (e.g., help buffers).
line 42: doautoall syntaxset FileType
Executing FileType Autocommands for "*"
autocommand 0verbose exe "set syntax=" . expand("<amatch>")

Executing: 0verbose exe "set syntax=" . expand("<amatch>")
line 43: if !s:did_ft
line 44:   doautoall filetypedetect BufRead
line 45: endif
finished sourcing /usr/share/vim/vim91/syntax/syntax.vim
continuing in /home/Dante/.vimrc
line 251: syntax enable
line 251: so $VIMRUNTIME/syntax/syntax.vim
chdir(/usr/share/vim/vim91/syntax)
fchdir() to previous dir
line 251: sourcing "/usr/share/vim/vim91/syntax/syntax.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 3: " Last Change:^I2023 Aug 10
line 4: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 5: 
line 6: " This file is used for ":syntax on".
line 7: " It installs the autocommands and starts highlighting for all buffers.
line 8: 
line 9: if !has("syntax")
line 10:   finish
line 11: endif
line 12: 
line 13: " If Syntax highlighting appears to be on already, turn it off first, so that
line 14: " any leftovers are cleared.
line 15: if exists("syntax_on") || exists("syntax_manual")
line 16:   so <sfile>:p:h/nosyntax.vim
chdir(/usr/share/vim/vim91/syntax)
fchdir() to previous dir
line 16: sourcing "/usr/share/vim/vim91/syntax/nosyntax.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 3: " Last Change:^I2023 Aug 10
line 4: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 5: 
line 6: " This file is used for ":syntax off".
line 7: " It removes the autocommands and stops highlighting for all buffers.
line 8: 
line 9: if !has("syntax")
line 10:   finish
line 11: endif
line 12: 
line 13: " Remove all autocommands for the Syntax event.  This also avoids that
line 14: " "syntax=foo" in a modeline triggers the SynSet() function of synload.vim.
line 15: au! Syntax
line 16: 
line 17: " remove all syntax autocommands and remove the syntax for each buffer
line 18: augroup syntaxset
line 19:   au!
line 20:   au BufEnter * syn clear
line 21:   au BufEnter * if exists("b:current_syntax") | unlet b:current_syntax | endif
line 22:   doautoall syntaxset BufEnter *
Executing BufEnter Autocommands for "*"
autocommand syn clear

Executing: syn clear
autocommand if exists("b:current_syntax") | unlet b:current_syntax | endif

Executing: if exists("b:current_syntax") | unlet b:current_syntax | endif
Executing:  unlet b:current_syntax | endif
Executing:  endif
line 23:   au!
line 24: augroup END
line 25: 
line 26: if exists("syntax_on")
line 27:   unlet syntax_on
line 28: endif
line 29: if exists("syntax_manual")
line 30:   unlet syntax_manual
line 31: endif
finished sourcing /usr/share/vim/vim91/syntax/nosyntax.vim
continuing in /usr/share/vim/vim91/syntax/syntax.vim
line 17: endif
line 18: 
line 19: " Load the Syntax autocommands and set the default methods for highlighting.
line 20: runtime syntax/synload.vim
Searching for "syntax/synload.vim" in "/home/Dante/.vim,/home/Dante/.vim/plugged/onedark.vim,/home/Dante/.vim/plugged/onehalf/vim,/home/Dante/.vim/plugged/gruvbox,/home/Dante/.vim/plugged/lightline.vim,/home/Dante/.vim/plugged/vim-tmux-navigator,/home/Dante/.vim/plugged/vimtex,/home/Dante/.vim/plugged/nerdtree,/home/Dante/.vim/plugged/fzf,/home/Dante/.vim/plugged/fzf.vim,/home/Dante/.vim/plugged/vim-wayland-clipboard,/home/Dante/.vim/plugged/coc.nvim,/home/Dante/.vim/plugged/vim-obsession,/usr/share/vim/vimfiles,/usr/share/vim/vim91,/usr/share/vim/vimfiles/after,/home/Dante/.vim/plugged/vimtex/after,/home/Dante/.vim/after"
Searching for "/home/Dante/.vim/syntax/synload.vim"
Searching for "/home/Dante/.vim/plugged/onedark.vim/syntax/synload.vim"
Searching for "/home/Dante/.vim/plugged/onehalf/vim/syntax/synload.vim"
Searching for "/home/Dante/.vim/plugged/gruvbox/syntax/synload.vim"
Searching for "/home/Dante/.vim/plugged/lightline.vim/syntax/synload.vim"
Searching for "/home/Dante/.vim/plugged/vim-tmux-navigator/syntax/synload.vim"
Searching for "/home/Dante/.vim/plugged/vimtex/syntax/synload.vim"
Searching for "/home/Dante/.vim/plugged/nerdtree/syntax/synload.vim"
Searching for "/home/Dante/.vim/plugged/fzf/syntax/synload.vim"
Searching for "/home/Dante/.vim/plugged/fzf.vim/syntax/synload.vim"
Searching for "/home/Dante/.vim/plugged/vim-wayland-clipboard/syntax/synload.vim"
Searching for "/home/Dante/.vim/plugged/coc.nvim/syntax/synload.vim"
Searching for "/home/Dante/.vim/plugged/vim-obsession/syntax/synload.vim"
Searching for "/usr/share/vim/vimfiles/syntax/synload.vim"
Searching for "/usr/share/vim/vim91/syntax/synload.vim"
chdir(/usr/share/vim/vim91/syntax)
fchdir() to previous dir
line 20: sourcing "/usr/share/vim/vim91/syntax/synload.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 3: " Last Change:^I2023 Aug 10
line 4: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 5: 
line 6: " This file sets up for syntax highlighting.
line 7: " It is loaded from "syntax.vim" and "manual.vim".
line 8: " 1. Set the default highlight groups.
line 9: " 2. Install Syntax autocommands for all the available syntax files.
line 10: 
line 11: if !has("syntax")
line 12:   finish
line 13: endif
line 14: 
line 15: " let others know that syntax has been switched on
line 16: let syntax_on = 1
line 17: 
line 18: " Set the default highlighting colors.  Use a color scheme if specified.
line 19: if exists("colors_name")
line 20:   exe "colors " . colors_name
line 21: else
line 22:   runtime! syntax/syncolor.vim
Searching for "syntax/syncolor.vim" in "/home/Dante/.vim,/home/Dante/.vim/plugged/onedark.vim,/home/Dante/.vim/plugged/onehalf/vim,/home/Dante/.vim/plugged/gruvbox,/home/Dante/.vim/plugged/lightline.vim,/home/Dante/.vim/plugged/vim-tmux-navigator,/home/Dante/.vim/plugged/vimtex,/home/Dante/.vim/plugged/nerdtree,/home/Dante/.vim/plugged/fzf,/home/Dante/.vim/plugged/fzf.vim,/home/Dante/.vim/plugged/vim-wayland-clipboard,/home/Dante/.vim/plugged/coc.nvim,/home/Dante/.vim/plugged/vim-obsession,/usr/share/vim/vimfiles,/usr/share/vim/vim91,/usr/share/vim/vimfiles/after,/home/Dante/.vim/plugged/vimtex/after,/home/Dante/.vim/after"
Searching for "/home/Dante/.vim/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/onedark.vim/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/onehalf/vim/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/gruvbox/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/lightline.vim/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/vim-tmux-navigator/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/vimtex/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/nerdtree/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/fzf/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/fzf.vim/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/vim-wayland-clipboard/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/coc.nvim/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/vim-obsession/syntax/syncolor.vim"
Searching for "/usr/share/vim/vimfiles/syntax/syncolor.vim"
Searching for "/usr/share/vim/vim91/syntax/syncolor.vim"
chdir(/usr/share/vim/vim91/syntax)
fchdir() to previous dir
line 22: sourcing "/usr/share/vim/vim91/syntax/syncolor.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 3: " Last Change:^I2023 Aug 10
line 4: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 5: 
line 6: " This file sets up the default methods for highlighting.
line 7: " It is loaded from "synload.vim" and from Vim for ":syntax reset".
line 8: " Also used from init_highlight().
line 9: 
line 10: if !exists("syntax_cmd") || syntax_cmd == "on"
line 11:   " ":syntax on" works like in Vim 5.7: set colors but keep links
line 12:   command -nargs=* SynColor hi <args>
line 13:   command -nargs=* SynLink hi link <args>
line 14: else
line 15:   if syntax_cmd == "enable"
line 16:     " ":syntax enable" keeps any existing colors
line 17:     command -nargs=* SynColor hi def <args>
line 18:     command -nargs=* SynLink hi def link <args>
line 19:   elseif syntax_cmd == "reset"
line 20:     " ":syntax reset" resets all colors to the default
line 21:     command -nargs=* SynColor hi <args>
line 22:     command -nargs=* SynLink hi! link <args>
line 23:   else
line 24:     " User defined syncolor file has already set the colors.
line 25:     finish
line 26:   endif
line 27: endif
line 28: 
line 29: " Many terminals can only use six different colors (plus black and white).
line 30: " Therefore the number of colors used is kept low. It doesn't look nice with
line 31: " too many colors anyway.
line 32: " Careful with "cterm=bold", it changes the color to bright for some terminals.
line 33: " There are two sets of defaults: for a dark and a light background.
line 34: if &background == "dark"
line 35:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 35: hi def Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 36:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 36: hi def Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 37:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 37: hi def Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 38:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 38: hi def Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 39:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 39: hi def Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 40:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 40: hi def PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 41:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 41: hi def Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 42:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 42: hi def Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 43:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 43: hi def Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 44:   SynColor Added^Iterm=NONE cterm=NONE ctermfg=Green ctermbg=NONE gui=NONE guifg=LimeGreen guibg=NONE
line 44: hi def Added^Iterm=NONE cterm=NONE ctermfg=Green ctermbg=NONE gui=NONE guifg=LimeGreen guibg=NONE
line 45:   SynColor Changed^Iterm=NONE cterm=NONE ctermfg=Blue ctermbg=NONE gui=NONE guifg=DodgerBlue guibg=NONE
line 45: hi def Changed^Iterm=NONE cterm=NONE ctermfg=Blue ctermbg=NONE gui=NONE guifg=DodgerBlue guibg=NONE
line 46:   SynColor Removed^Iterm=NONE cterm=NONE ctermfg=Red ctermbg=NONE gui=NONE guifg=Red guibg=NONE
line 46: hi def Removed^Iterm=NONE cterm=NONE ctermfg=Red ctermbg=NONE gui=NONE guifg=Red guibg=NONE
line 47: else
line 48:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
line 49:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
line 50:   " #6a5acd is SlateBlue
line 51:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=#6a5acd guibg=NONE
line 52:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
line 53:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
line 54:   " #6a0dad is Purple
line 55:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=#6a0dad guibg=NONE
line 56:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
line 57:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
line 58:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 59:   SynColor Added^Iterm=NONE cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=NONE guifg=SeaGreen guibg=NONE
line 60:   SynColor Changed^Iterm=NONE cterm=NONE ctermfg=Blue ctermbg=NONE gui=NONE guifg=DodgerBlue guibg=NONE
line 61:   SynColor Removed^Iterm=NONE cterm=NONE ctermfg=Red ctermbg=NONE gui=NONE guifg=Red guibg=NONE
line 62: endif
line 63: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 63: hi def Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 64: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 64: hi def Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 65: 
line 66: " Common groups that link to default highlighting.
line 67: " You can specify other highlighting easily.
line 68: SynLink String^I^IConstant
line 68: hi def link String^I^IConstant
line 69: SynLink Character^IConstant
line 69: hi def link Character^IConstant
line 70: SynLink Number^I^IConstant
line 70: hi def link Number^I^IConstant
line 71: SynLink Boolean^I^IConstant
line 71: hi def link Boolean^I^IConstant
line 72: SynLink Float^I^INumber
line 72: hi def link Float^I^INumber
line 73: SynLink Function^IIdentifier
line 73: hi def link Function^IIdentifier
line 74: SynLink Conditional^IStatement
line 74: hi def link Conditional^IStatement
line 75: SynLink Repeat^I^IStatement
line 75: hi def link Repeat^I^IStatement
line 76: SynLink Label^I^IStatement
line 76: hi def link Label^I^IStatement
line 77: SynLink Operator^IStatement
line 77: hi def link Operator^IStatement
line 78: SynLink Keyword^I^IStatement
line 78: hi def link Keyword^I^IStatement
line 79: SynLink Exception^IStatement
line 79: hi def link Exception^IStatement
line 80: SynLink Include^I^IPreProc
line 80: hi def link Include^I^IPreProc
line 81: SynLink Define^I^IPreProc
line 81: hi def link Define^I^IPreProc
line 82: SynLink Macro^I^IPreProc
line 82: hi def link Macro^I^IPreProc
line 83: SynLink PreCondit^IPreProc
line 83: hi def link PreCondit^IPreProc
line 84: SynLink StorageClass^IType
line 84: hi def link StorageClass^IType
line 85: SynLink Structure^IType
line 85: hi def link Structure^IType
line 86: SynLink Typedef^I^IType
line 86: hi def link Typedef^I^IType
line 87: SynLink Tag^I^ISpecial
line 87: hi def link Tag^I^ISpecial
line 88: SynLink SpecialChar^ISpecial
line 88: hi def link SpecialChar^ISpecial
line 89: SynLink Delimiter^ISpecial
line 89: hi def link Delimiter^ISpecial
line 90: SynLink SpecialComment^ISpecial
line 90: hi def link SpecialComment^ISpecial
line 91: SynLink Debug^I^ISpecial
line 91: hi def link Debug^I^ISpecial
line 92: 
line 93: delcommand SynColor
line 94: delcommand SynLink
finished sourcing /usr/share/vim/vim91/syntax/syncolor.vim
continuing in /usr/share/vim/vim91/syntax/synload.vim
Searching for "/usr/share/vim/vimfiles/after/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/vimtex/after/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/after/syntax/syncolor.vim"
line 23: endif
line 24: 
line 25: " Line continuation is used here, remove 'C' from 'cpoptions'
line 26: let s:cpo_save = &cpo
line 27: set cpo&vim
line 28: 
line 29: " First remove all old syntax autocommands.
line 30: au! Syntax
line 31: 
line 32: au Syntax *^I^Icall s:SynSet()
line 33: 
line 34: fun! s:SynSet()
line 64: 
line 65: 
line 66: " Handle adding doxygen to other languages (C, C++, C#, IDL, java, php, DataScript)
line 67: au Syntax c,cpp,cs,idl,java,php,datascript if (exists('b:load_doxygen_syntax') && b:load_doxygen_syntax)^I|| (exists('g:load_doxygen_syntax') && g:load_doxygen_syntax)   | runtime! syntax/doxygen.vim | endif
line 72: 
line 73: 
line 74: " Source the user-specified syntax highlighting file
line 75: if exists("mysyntaxfile")
line 76:   let s:fname = expand(mysyntaxfile)
line 77:   if filereadable(s:fname)
line 78:     execute "source " . fnameescape(s:fname)
line 79:   endif
line 80: endif
line 81: 
line 82: " Restore 'cpoptions'
line 83: let &cpo = s:cpo_save
line 84: unlet s:cpo_save
finished sourcing /usr/share/vim/vim91/syntax/synload.vim
continuing in /usr/share/vim/vim91/syntax/syntax.vim
line 21: 
line 22: " Load the FileType autocommands if not done yet.
line 23: if exists("did_load_filetypes")
line 24:   let s:did_ft = 1
line 25: else
line 26:   filetype on
line 27:   let s:did_ft = 0
line 28: endif
line 29: 
line 30: " Set up the connection between FileType and Syntax autocommands.
line 31: " This makes the syntax automatically set when the file type is detected.
line 32: " Avoid an error when 'verbose' is set and <amatch> expansion fails.
line 33: augroup syntaxset
line 34:   au! FileType *^I0verbose exe "set syntax=" . expand("<amatch>")
line 35: augroup END
line 36: 
line 37: 
line 38: " Execute the syntax autocommands for the each buffer.
line 39: " If the filetype wasn't detected yet, do that now.
line 40: " Always do the syntaxset autocommands, for buffers where the 'filetype'
line 41: " already was set manually (e.g., help buffers).
line 42: doautoall syntaxset FileType
Executing FileType Autocommands for "*"
autocommand 0verbose exe "set syntax=" . expand("<amatch>")

Executing: 0verbose exe "set syntax=" . expand("<amatch>")
line 43: if !s:did_ft
line 44:   doautoall filetypedetect BufRead
line 45: endif
finished sourcing /usr/share/vim/vim91/syntax/syntax.vim
continuing in /home/Dante/.vimrc
line 252: set t_Co=256
line 253: 
line 254: 
line 255: if exists('+termguicolors')
line 256:   let &t_8f = "\<Esc>[38;2;%lu;%lu;%lum"
line 257:   let &t_8b = "\<Esc>[48;2;%lu;%lu;%lum"
line 258:   set termguicolors
line 259: endif
line 260: 
line 261: "Color Scheme
line 262: "if you switch color themes check the themes github to see if they have
line 263: "lightline support
line 264: let g:lightline = { 'colorscheme': 'onehalfdark',}
line 267: let g:fzf_colors = { 'fg':         ['fg', 'Normal'], 'bg':         ['bg', 'Normal'], 'preview-bg': ['bg', 'NormalFloat'], 'hl':         ['fg', 'Comment'], 'fg+':        ['fg', 'CursorLine', 'CursorColumn', 'Normal'], 'bg+':        ['bg', 'CursorLine', 'CursorColumn'], 'hl+':        ['fg', 'Statement'], 'info':       ['fg', 'PreProc'], 'border':     ['fg', 'Ignore'], 'prompt':     ['fg', 'Conditional'], 'pointer':    ['fg', 'Exception'], 'marker':     ['fg', 'Keyword'], 'spinner':    ['fg', 'Label'], 'header':     ['fg', 'Comment'] }
line 282: colorscheme onehalfdark
Searching for "colors/lists/default.vim" in "/home/Dante/.vim,/home/Dante/.vim/plugged/onedark.vim,/home/Dante/.vim/plugged/onehalf/vim,/home/Dante/.vim/plugged/gruvbox,/home/Dante/.vim/plugged/lightline.vim,/home/Dante/.vim/plugged/vim-tmux-navigator,/home/Dante/.vim/plugged/vimtex,/home/Dante/.vim/plugged/nerdtree,/home/Dante/.vim/plugged/fzf,/home/Dante/.vim/plugged/fzf.vim,/home/Dante/.vim/plugged/vim-wayland-clipboard,/home/Dante/.vim/plugged/coc.nvim,/home/Dante/.vim/plugged/vim-obsession,/usr/share/vim/vimfiles,/usr/share/vim/vim91,/usr/share/vim/vimfiles/after,/home/Dante/.vim/plugged/vimtex/after,/home/Dante/.vim/after"
Searching for "/home/Dante/.vim/colors/lists/default.vim"
Searching for "/home/Dante/.vim/plugged/onedark.vim/colors/lists/default.vim"
Searching for "/home/Dante/.vim/plugged/onehalf/vim/colors/lists/default.vim"
Searching for "/home/Dante/.vim/plugged/gruvbox/colors/lists/default.vim"
Searching for "/home/Dante/.vim/plugged/lightline.vim/colors/lists/default.vim"
Searching for "/home/Dante/.vim/plugged/vim-tmux-navigator/colors/lists/default.vim"
Searching for "/home/Dante/.vim/plugged/vimtex/colors/lists/default.vim"
Searching for "/home/Dante/.vim/plugged/nerdtree/colors/lists/default.vim"
Searching for "/home/Dante/.vim/plugged/fzf/colors/lists/default.vim"
Searching for "/home/Dante/.vim/plugged/fzf.vim/colors/lists/default.vim"
Searching for "/home/Dante/.vim/plugged/vim-wayland-clipboard/colors/lists/default.vim"
Searching for "/home/Dante/.vim/plugged/coc.nvim/colors/lists/default.vim"
Searching for "/home/Dante/.vim/plugged/vim-obsession/colors/lists/default.vim"
Searching for "/usr/share/vim/vimfiles/colors/lists/default.vim"
Searching for "/usr/share/vim/vim91/colors/lists/default.vim"
chdir(/usr/share/vim/vim91/colors/lists)
fchdir() to previous dir
line 282: sourcing "/usr/share/vim/vim91/colors/lists/default.vim"
line 1: " Maintainer:  Drew Vogel <dvogel@sidejump.org>
line 2: " Last Change: 2024 Mar 20
line 3: "
line 4: " Replaced rgb.txt as the source of de facto standard color names. This is
line 5: " sourced each time the colorscheme command is run. It is also sourced each
line 6: " time the highlight command fails to recognize a gui color. You can override
line 7: " these colors by introducing a new colors/lists/default.vim file earlier in
line 8: " the runtimepath.
line 9: " Note: the color names should be in lower case, because Vim will lookup the
line 10: " a color by its lower case name.
line 11: 
line 12: " make sure line continuation works
line 13: let s:keepcpo = &cpo
line 14: set cpo&vim
line 15: 
line 16: function! s:Cleanup()
line 20: 
line 21: function! s:AddColors(cnames) abort
line 40: 
line 41: if exists('s:default_cnames')
line 42:   call s:AddColors(s:default_cnames)
calling <SNR>16_AddColors({'medium blue': '#0000cd', 'indianred'...mon3': '#cd7054', 'salmon4': '#8b4c39'})

line 1:   call extend(v:colornames, a:cnames, 'keep')
line 2: 
line 3:   " all keys should be in lower case, convert keys that are not yet
line 4:   let len_after = len(v:colornames)
line 5:   if len_after == len(a:cnames)
line 6:     " after extend(): v:colornames has all the keys of default_cnames
line 7:     " checked: v:colornames also has no extra keys
line 8:     " => keys are the same, and keys(default_cnames) are known to be ok
line 9:     return
<SNR>16_AddColors returning #0

continuing in /usr/share/vim/vim91/colors/lists/default.vim

line 43:   call s:Cleanup()
calling <SNR>16_Cleanup()

line 1:   let &cpo = s:keepcpo
line 2:   unlet s:keepcpo
<SNR>16_Cleanup returning #0

continuing in /usr/share/vim/vim91/colors/lists/default.vim

line 44:   finish
finished sourcing /usr/share/vim/vim91/colors/lists/default.vim
continuing in /home/Dante/.vimrc
Searching for "/usr/share/vim/vimfiles/after/colors/lists/default.vim"
Searching for "/home/Dante/.vim/plugged/vimtex/after/colors/lists/default.vim"
Searching for "/home/Dante/.vim/after/colors/lists/default.vim"
Searching for "colors/onehalfdark.vim" in "/home/Dante/.vim,/home/Dante/.vim/plugged/onedark.vim,/home/Dante/.vim/plugged/onehalf/vim,/home/Dante/.vim/plugged/gruvbox,/home/Dante/.vim/plugged/lightline.vim,/home/Dante/.vim/plugged/vim-tmux-navigator,/home/Dante/.vim/plugged/vimtex,/home/Dante/.vim/plugged/nerdtree,/home/Dante/.vim/plugged/fzf,/home/Dante/.vim/plugged/fzf.vim,/home/Dante/.vim/plugged/vim-wayland-clipboard,/home/Dante/.vim/plugged/coc.nvim,/home/Dante/.vim/plugged/vim-obsession,/usr/share/vim/vimfiles,/usr/share/vim/vim91,/usr/share/vim/vimfiles/after,/home/Dante/.vim/plugged/vimtex/after,/home/Dante/.vim/after"
Searching for "/home/Dante/.vim/colors/onehalfdark.vim"
Searching for "/home/Dante/.vim/plugged/onedark.vim/colors/onehalfdark.vim"
Searching for "/home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim"
chdir(/home/Dante/.vim/plugged/onehalf/vim/colors)
fchdir() to previous dir
line 282: sourcing "/home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim"
line 1: " ==============================================================================
line 2: "   Name:        One Half Dark
line 3: "   Author:      Son A. Pham <sp@sonpham.me>
line 4: "   Url:         https://github.com/sonph/onehalf
line 5: "   License:     The MIT License (MIT)
line 6: "
line 7: "   A dark vim color scheme based on Atom's One. See github.com/sonph/onehalf
line 8: "   for installation instructions, a light color scheme, versions for other
line 9: "   editors/terminals, and a matching theme for vim-airline.
line 10: " ==============================================================================
line 11: 
line 12: set background=dark
line 13: highlight clear
Searching for "syntax/syncolor.vim" in "/home/Dante/.vim,/home/Dante/.vim/plugged/onedark.vim,/home/Dante/.vim/plugged/onehalf/vim,/home/Dante/.vim/plugged/gruvbox,/home/Dante/.vim/plugged/lightline.vim,/home/Dante/.vim/plugged/vim-tmux-navigator,/home/Dante/.vim/plugged/vimtex,/home/Dante/.vim/plugged/nerdtree,/home/Dante/.vim/plugged/fzf,/home/Dante/.vim/plugged/fzf.vim,/home/Dante/.vim/plugged/vim-wayland-clipboard,/home/Dante/.vim/plugged/coc.nvim,/home/Dante/.vim/plugged/vim-obsession,/usr/share/vim/vimfiles,/usr/share/vim/vim91,/usr/share/vim/vimfiles/after,/home/Dante/.vim/plugged/vimtex/after,/home/Dante/.vim/after"
Searching for "/home/Dante/.vim/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/onedark.vim/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/onehalf/vim/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/gruvbox/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/lightline.vim/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/vim-tmux-navigator/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/vimtex/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/nerdtree/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/fzf/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/fzf.vim/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/vim-wayland-clipboard/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/coc.nvim/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/vim-obsession/syntax/syncolor.vim"
Searching for "/usr/share/vim/vimfiles/syntax/syncolor.vim"
Searching for "/usr/share/vim/vim91/syntax/syncolor.vim"
chdir(/usr/share/vim/vim91/syntax)
fchdir() to previous dir
line 13: sourcing "/usr/share/vim/vim91/syntax/syncolor.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 3: " Last Change:^I2023 Aug 10
line 4: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 5: 
line 6: " This file sets up the default methods for highlighting.
line 7: " It is loaded from "synload.vim" and from Vim for ":syntax reset".
line 8: " Also used from init_highlight().
line 9: 
line 10: if !exists("syntax_cmd") || syntax_cmd == "on"
line 11:   " ":syntax on" works like in Vim 5.7: set colors but keep links
line 12:   command -nargs=* SynColor hi <args>
line 13:   command -nargs=* SynLink hi link <args>
line 14: else
line 15:   if syntax_cmd == "enable"
line 16:     " ":syntax enable" keeps any existing colors
line 17:     command -nargs=* SynColor hi def <args>
line 18:     command -nargs=* SynLink hi def link <args>
line 19:   elseif syntax_cmd == "reset"
line 20:     " ":syntax reset" resets all colors to the default
line 21:     command -nargs=* SynColor hi <args>
line 22:     command -nargs=* SynLink hi! link <args>
line 23:   else
line 24:     " User defined syncolor file has already set the colors.
line 25:     finish
line 26:   endif
line 27: endif
line 28: 
line 29: " Many terminals can only use six different colors (plus black and white).
line 30: " Therefore the number of colors used is kept low. It doesn't look nice with
line 31: " too many colors anyway.
line 32: " Careful with "cterm=bold", it changes the color to bright for some terminals.
line 33: " There are two sets of defaults: for a dark and a light background.
line 34: if &background == "dark"
line 35:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 35: hi Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 36:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 36: hi Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 37:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 37: hi Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 38:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 38: hi Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 39:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 39: hi Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 40:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 40: hi PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 41:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 41: hi Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 42:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 42: hi Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 43:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 43: hi Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 44:   SynColor Added^Iterm=NONE cterm=NONE ctermfg=Green ctermbg=NONE gui=NONE guifg=LimeGreen guibg=NONE
line 44: hi Added^Iterm=NONE cterm=NONE ctermfg=Green ctermbg=NONE gui=NONE guifg=LimeGreen guibg=NONE
line 45:   SynColor Changed^Iterm=NONE cterm=NONE ctermfg=Blue ctermbg=NONE gui=NONE guifg=DodgerBlue guibg=NONE
line 45: hi Changed^Iterm=NONE cterm=NONE ctermfg=Blue ctermbg=NONE gui=NONE guifg=DodgerBlue guibg=NONE
line 46:   SynColor Removed^Iterm=NONE cterm=NONE ctermfg=Red ctermbg=NONE gui=NONE guifg=Red guibg=NONE
line 46: hi Removed^Iterm=NONE cterm=NONE ctermfg=Red ctermbg=NONE gui=NONE guifg=Red guibg=NONE
line 47: else
line 48:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
line 49:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
line 50:   " #6a5acd is SlateBlue
line 51:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=#6a5acd guibg=NONE
line 52:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
line 53:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
line 54:   " #6a0dad is Purple
line 55:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=#6a0dad guibg=NONE
line 56:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
line 57:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
line 58:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 59:   SynColor Added^Iterm=NONE cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=NONE guifg=SeaGreen guibg=NONE
line 60:   SynColor Changed^Iterm=NONE cterm=NONE ctermfg=Blue ctermbg=NONE gui=NONE guifg=DodgerBlue guibg=NONE
line 61:   SynColor Removed^Iterm=NONE cterm=NONE ctermfg=Red ctermbg=NONE gui=NONE guifg=Red guibg=NONE
line 62: endif
line 63: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 63: hi Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 64: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 64: hi Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 65: 
line 66: " Common groups that link to default highlighting.
line 67: " You can specify other highlighting easily.
line 68: SynLink String^I^IConstant
line 68: hi link String^I^IConstant
line 69: SynLink Character^IConstant
line 69: hi link Character^IConstant
line 70: SynLink Number^I^IConstant
line 70: hi link Number^I^IConstant
line 71: SynLink Boolean^I^IConstant
line 71: hi link Boolean^I^IConstant
line 72: SynLink Float^I^INumber
line 72: hi link Float^I^INumber
line 73: SynLink Function^IIdentifier
line 73: hi link Function^IIdentifier
line 74: SynLink Conditional^IStatement
line 74: hi link Conditional^IStatement
line 75: SynLink Repeat^I^IStatement
line 75: hi link Repeat^I^IStatement
line 76: SynLink Label^I^IStatement
line 76: hi link Label^I^IStatement
line 77: SynLink Operator^IStatement
line 77: hi link Operator^IStatement
line 78: SynLink Keyword^I^IStatement
line 78: hi link Keyword^I^IStatement
line 79: SynLink Exception^IStatement
line 79: hi link Exception^IStatement
line 80: SynLink Include^I^IPreProc
line 80: hi link Include^I^IPreProc
line 81: SynLink Define^I^IPreProc
line 81: hi link Define^I^IPreProc
line 82: SynLink Macro^I^IPreProc
line 82: hi link Macro^I^IPreProc
line 83: SynLink PreCondit^IPreProc
line 83: hi link PreCondit^IPreProc
line 84: SynLink StorageClass^IType
line 84: hi link StorageClass^IType
line 85: SynLink Structure^IType
line 85: hi link Structure^IType
line 86: SynLink Typedef^I^IType
line 86: hi link Typedef^I^IType
line 87: SynLink Tag^I^ISpecial
line 87: hi link Tag^I^ISpecial
line 88: SynLink SpecialChar^ISpecial
line 88: hi link SpecialChar^ISpecial
line 89: SynLink Delimiter^ISpecial
line 89: hi link Delimiter^ISpecial
line 90: SynLink SpecialComment^ISpecial
line 90: hi link SpecialComment^ISpecial
line 91: SynLink Debug^I^ISpecial
line 91: hi link Debug^I^ISpecial
line 92: 
line 93: delcommand SynColor
line 94: delcommand SynLink
finished sourcing /usr/share/vim/vim91/syntax/syncolor.vim
continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim
Searching for "/usr/share/vim/vimfiles/after/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/vimtex/after/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/after/syntax/syncolor.vim"
line 14: syntax reset
line 14: runtime! syntax/syncolor.vim
Searching for "syntax/syncolor.vim" in "/home/Dante/.vim,/home/Dante/.vim/plugged/onedark.vim,/home/Dante/.vim/plugged/onehalf/vim,/home/Dante/.vim/plugged/gruvbox,/home/Dante/.vim/plugged/lightline.vim,/home/Dante/.vim/plugged/vim-tmux-navigator,/home/Dante/.vim/plugged/vimtex,/home/Dante/.vim/plugged/nerdtree,/home/Dante/.vim/plugged/fzf,/home/Dante/.vim/plugged/fzf.vim,/home/Dante/.vim/plugged/vim-wayland-clipboard,/home/Dante/.vim/plugged/coc.nvim,/home/Dante/.vim/plugged/vim-obsession,/usr/share/vim/vimfiles,/usr/share/vim/vim91,/usr/share/vim/vimfiles/after,/home/Dante/.vim/plugged/vimtex/after,/home/Dante/.vim/after"
Searching for "/home/Dante/.vim/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/onedark.vim/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/onehalf/vim/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/gruvbox/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/lightline.vim/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/vim-tmux-navigator/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/vimtex/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/nerdtree/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/fzf/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/fzf.vim/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/vim-wayland-clipboard/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/coc.nvim/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/vim-obsession/syntax/syncolor.vim"
Searching for "/usr/share/vim/vimfiles/syntax/syncolor.vim"
Searching for "/usr/share/vim/vim91/syntax/syncolor.vim"
chdir(/usr/share/vim/vim91/syntax)
fchdir() to previous dir
line 14: sourcing "/usr/share/vim/vim91/syntax/syncolor.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 3: " Last Change:^I2023 Aug 10
line 4: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 5: 
line 6: " This file sets up the default methods for highlighting.
line 7: " It is loaded from "synload.vim" and from Vim for ":syntax reset".
line 8: " Also used from init_highlight().
line 9: 
line 10: if !exists("syntax_cmd") || syntax_cmd == "on"
line 11:   " ":syntax on" works like in Vim 5.7: set colors but keep links
line 12:   command -nargs=* SynColor hi <args>
line 13:   command -nargs=* SynLink hi link <args>
line 14: else
line 15:   if syntax_cmd == "enable"
line 16:     " ":syntax enable" keeps any existing colors
line 17:     command -nargs=* SynColor hi def <args>
line 18:     command -nargs=* SynLink hi def link <args>
line 19:   elseif syntax_cmd == "reset"
line 20:     " ":syntax reset" resets all colors to the default
line 21:     command -nargs=* SynColor hi <args>
line 22:     command -nargs=* SynLink hi! link <args>
line 23:   else
line 24:     " User defined syncolor file has already set the colors.
line 25:     finish
line 26:   endif
line 27: endif
line 28: 
line 29: " Many terminals can only use six different colors (plus black and white).
line 30: " Therefore the number of colors used is kept low. It doesn't look nice with
line 31: " too many colors anyway.
line 32: " Careful with "cterm=bold", it changes the color to bright for some terminals.
line 33: " There are two sets of defaults: for a dark and a light background.
line 34: if &background == "dark"
line 35:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 35: hi Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 36:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 36: hi Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 37:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 37: hi Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 38:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 38: hi Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 39:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 39: hi Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 40:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 40: hi PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 41:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 41: hi Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 42:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 42: hi Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 43:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 43: hi Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 44:   SynColor Added^Iterm=NONE cterm=NONE ctermfg=Green ctermbg=NONE gui=NONE guifg=LimeGreen guibg=NONE
line 44: hi Added^Iterm=NONE cterm=NONE ctermfg=Green ctermbg=NONE gui=NONE guifg=LimeGreen guibg=NONE
line 45:   SynColor Changed^Iterm=NONE cterm=NONE ctermfg=Blue ctermbg=NONE gui=NONE guifg=DodgerBlue guibg=NONE
line 45: hi Changed^Iterm=NONE cterm=NONE ctermfg=Blue ctermbg=NONE gui=NONE guifg=DodgerBlue guibg=NONE
line 46:   SynColor Removed^Iterm=NONE cterm=NONE ctermfg=Red ctermbg=NONE gui=NONE guifg=Red guibg=NONE
line 46: hi Removed^Iterm=NONE cterm=NONE ctermfg=Red ctermbg=NONE gui=NONE guifg=Red guibg=NONE
line 47: else
line 48:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
line 49:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
line 50:   " #6a5acd is SlateBlue
line 51:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=#6a5acd guibg=NONE
line 52:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
line 53:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
line 54:   " #6a0dad is Purple
line 55:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=#6a0dad guibg=NONE
line 56:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
line 57:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
line 58:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 59:   SynColor Added^Iterm=NONE cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=NONE guifg=SeaGreen guibg=NONE
line 60:   SynColor Changed^Iterm=NONE cterm=NONE ctermfg=Blue ctermbg=NONE gui=NONE guifg=DodgerBlue guibg=NONE
line 61:   SynColor Removed^Iterm=NONE cterm=NONE ctermfg=Red ctermbg=NONE gui=NONE guifg=Red guibg=NONE
line 62: endif
line 63: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 63: hi Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 64: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 64: hi Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 65: 
line 66: " Common groups that link to default highlighting.
line 67: " You can specify other highlighting easily.
line 68: SynLink String^I^IConstant
line 68: hi! link String^I^IConstant
line 69: SynLink Character^IConstant
line 69: hi! link Character^IConstant
line 70: SynLink Number^I^IConstant
line 70: hi! link Number^I^IConstant
line 71: SynLink Boolean^I^IConstant
line 71: hi! link Boolean^I^IConstant
line 72: SynLink Float^I^INumber
line 72: hi! link Float^I^INumber
line 73: SynLink Function^IIdentifier
line 73: hi! link Function^IIdentifier
line 74: SynLink Conditional^IStatement
line 74: hi! link Conditional^IStatement
line 75: SynLink Repeat^I^IStatement
line 75: hi! link Repeat^I^IStatement
line 76: SynLink Label^I^IStatement
line 76: hi! link Label^I^IStatement
line 77: SynLink Operator^IStatement
line 77: hi! link Operator^IStatement
line 78: SynLink Keyword^I^IStatement
line 78: hi! link Keyword^I^IStatement
line 79: SynLink Exception^IStatement
line 79: hi! link Exception^IStatement
line 80: SynLink Include^I^IPreProc
line 80: hi! link Include^I^IPreProc
line 81: SynLink Define^I^IPreProc
line 81: hi! link Define^I^IPreProc
line 82: SynLink Macro^I^IPreProc
line 82: hi! link Macro^I^IPreProc
line 83: SynLink PreCondit^IPreProc
line 83: hi! link PreCondit^IPreProc
line 84: SynLink StorageClass^IType
line 84: hi! link StorageClass^IType
line 85: SynLink Structure^IType
line 85: hi! link Structure^IType
line 86: SynLink Typedef^I^IType
line 86: hi! link Typedef^I^IType
line 87: SynLink Tag^I^ISpecial
line 87: hi! link Tag^I^ISpecial
line 88: SynLink SpecialChar^ISpecial
line 88: hi! link SpecialChar^ISpecial
line 89: SynLink Delimiter^ISpecial
line 89: hi! link Delimiter^ISpecial
line 90: SynLink SpecialComment^ISpecial
line 90: hi! link SpecialComment^ISpecial
line 91: SynLink Debug^I^ISpecial
line 91: hi! link Debug^I^ISpecial
line 92: 
line 93: delcommand SynColor
line 94: delcommand SynLink
finished sourcing /usr/share/vim/vim91/syntax/syncolor.vim
continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim
Searching for "/usr/share/vim/vimfiles/after/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/plugged/vimtex/after/syntax/syncolor.vim"
Searching for "/home/Dante/.vim/after/syntax/syncolor.vim"
line 15: 
line 16: let g:colors_name="onehalfdark"
line 17: let colors_name="onehalfdark"
line 18: 
line 19: 
line 20: let s:black       = { "gui": "#282c34", "cterm": "236" }
line 21: let s:red         = { "gui": "#e06c75", "cterm": "168" }
line 22: let s:green       = { "gui": "#98c379", "cterm": "114" }
line 23: let s:yellow      = { "gui": "#e5c07b", "cterm": "180" }
line 24: let s:blue        = { "gui": "#61afef", "cterm": "75"  }
line 25: let s:purple      = { "gui": "#c678dd", "cterm": "176" }
line 26: let s:cyan        = { "gui": "#56b6c2", "cterm": "73"  }
line 27: let s:white       = { "gui": "#dcdfe4", "cterm": "188" }
line 28: 
line 29: let s:fg          = s:white
line 30: let s:bg          = s:black
line 31: 
line 32: let s:comment_fg  = { "gui": "#5c6370", "cterm": "241" }
line 33: let s:gutter_bg   = { "gui": "#282c34", "cterm": "236" }
line 34: let s:gutter_fg   = { "gui": "#919baa", "cterm": "247" }
line 35: let s:non_text    = { "gui": "#373C45", "cterm": "239" }
line 36: 
line 37: let s:cursor_line = { "gui": "#313640", "cterm": "237" }
line 38: let s:color_col   = { "gui": "#313640", "cterm": "237" }
line 39: 
line 40: let s:selection   = { "gui": "#474e5d", "cterm": "239" }
line 41: let s:vertsplit   = { "gui": "#313640", "cterm": "237" }
line 42: 
line 43: 
line 44: function! s:h(group, fg, bg, attr)
line 61: 
line 62: 
line 63: " User interface colors {
line 64: call s:h("Normal", s:fg, s:bg, "")
calling <SNR>19_h('Normal', {'gui': '#dcdfe4', 'cterm': '188'}, {'gui': '#282c34', 'cterm': '236'}, '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi Normal guifg=#dcdfe4 ctermfg=188
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 7: hi Normal guibg=#282c34 ctermbg=236
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi Normal gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 65: 
line 66: call s:h("Cursor", s:bg, s:blue, "")
calling <SNR>19_h('Cursor', {'gui': '#282c34', 'cterm': '236'}, {'gui': '#61afef', 'cterm': '75'}, '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi Cursor guifg=#282c34 ctermfg=236
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 7: hi Cursor guibg=#61afef ctermbg=75
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi Cursor gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 67: call s:h("CursorColumn", "", s:cursor_line, "")
calling <SNR>19_h('CursorColumn', '', {'gui': '#313640', 'cterm': '237'}, '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 4: hi CursorColumn guifg=NONE cterm=NONE
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 7: hi CursorColumn guibg=#313640 ctermbg=237
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi CursorColumn gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 68: call s:h("CursorLine", "", s:cursor_line, "")
calling <SNR>19_h('CursorLine', '', {'gui': '#313640', 'cterm': '237'}, '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 4: hi CursorLine guifg=NONE cterm=NONE
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 7: hi CursorLine guibg=#313640 ctermbg=237
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi CursorLine gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 69: 
line 70: " This has been modified in order to make the line number column easier on the
line 71: " eyes
line 72: " call s:h("LineNr", s:gutter_fg, s:gutter_bg, "")
line 73: call s:h("LineNr", s:fg, s:bg, "")
calling <SNR>19_h('LineNr', {'gui': '#dcdfe4', 'cterm': '188'}, {'gui': '#282c34', 'cterm': '236'}, '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi LineNr guifg=#dcdfe4 ctermfg=188
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 7: hi LineNr guibg=#282c34 ctermbg=236
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi LineNr gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 74: call s:h("CursorLineNr", s:fg, "", "")
calling <SNR>19_h('CursorLineNr', {'gui': '#dcdfe4', 'cterm': '188'}, '', '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi CursorLineNr guifg=#dcdfe4 ctermfg=188
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi CursorLineNr guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi CursorLineNr gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 75: 
line 76: call s:h("DiffAdd", s:green, "", "")
calling <SNR>19_h('DiffAdd', {'gui': '#98c379', 'cterm': '114'}, '', '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi DiffAdd guifg=#98c379 ctermfg=114
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi DiffAdd guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi DiffAdd gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 77: call s:h("DiffChange", s:yellow, "", "")
calling <SNR>19_h('DiffChange', {'gui': '#e5c07b', 'cterm': '180'}, '', '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi DiffChange guifg=#e5c07b ctermfg=180
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi DiffChange guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi DiffChange gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 78: call s:h("DiffDelete", s:red, "", "")
calling <SNR>19_h('DiffDelete', {'gui': '#e06c75', 'cterm': '168'}, '', '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi DiffDelete guifg=#e06c75 ctermfg=168
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi DiffDelete guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi DiffDelete gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 79: call s:h("DiffText", s:blue, "", "")
calling <SNR>19_h('DiffText', {'gui': '#61afef', 'cterm': '75'}, '', '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi DiffText guifg=#61afef ctermfg=75
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi DiffText guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi DiffText gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 80: 
line 81: call s:h("IncSearch", s:bg, s:yellow, "")
calling <SNR>19_h('IncSearch', {'gui': '#282c34', 'cterm': '236'}, {'gui': '#e5c07b', 'cterm': '180'}, '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi IncSearch guifg=#282c34 ctermfg=236
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 7: hi IncSearch guibg=#e5c07b ctermbg=180
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi IncSearch gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 82: call s:h("Search", s:bg, s:yellow, "")
calling <SNR>19_h('Search', {'gui': '#282c34', 'cterm': '236'}, {'gui': '#e5c07b', 'cterm': '180'}, '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi Search guifg=#282c34 ctermfg=236
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 7: hi Search guibg=#e5c07b ctermbg=180
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi Search gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 83: 
line 84: call s:h("ErrorMsg", s:fg, "", "")
calling <SNR>19_h('ErrorMsg', {'gui': '#dcdfe4', 'cterm': '188'}, '', '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi ErrorMsg guifg=#dcdfe4 ctermfg=188
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi ErrorMsg guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi ErrorMsg gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 85: call s:h("ModeMsg", s:fg, "", "")
calling <SNR>19_h('ModeMsg', {'gui': '#dcdfe4', 'cterm': '188'}, '', '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi ModeMsg guifg=#dcdfe4 ctermfg=188
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi ModeMsg guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi ModeMsg gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 86: call s:h("MoreMsg", s:fg, "", "")
calling <SNR>19_h('MoreMsg', {'gui': '#dcdfe4', 'cterm': '188'}, '', '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi MoreMsg guifg=#dcdfe4 ctermfg=188
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi MoreMsg guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi MoreMsg gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 87: call s:h("WarningMsg", s:red, "", "")
calling <SNR>19_h('WarningMsg', {'gui': '#e06c75', 'cterm': '168'}, '', '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi WarningMsg guifg=#e06c75 ctermfg=168
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi WarningMsg guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi WarningMsg gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 88: call s:h("Question", s:purple, "", "")
calling <SNR>19_h('Question', {'gui': '#c678dd', 'cterm': '176'}, '', '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi Question guifg=#c678dd ctermfg=176
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi Question guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi Question gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 89: 
line 90: call s:h("Pmenu", s:bg, s:fg, "")
calling <SNR>19_h('Pmenu', {'gui': '#282c34', 'cterm': '236'}, {'gui': '#dcdfe4', 'cterm': '188'}, '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi Pmenu guifg=#282c34 ctermfg=236
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 7: hi Pmenu guibg=#dcdfe4 ctermbg=188
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi Pmenu gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 91: call s:h("PmenuSel", s:fg, s:blue, "")
calling <SNR>19_h('PmenuSel', {'gui': '#dcdfe4', 'cterm': '188'}, {'gui': '#61afef', 'cterm': '75'}, '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi PmenuSel guifg=#dcdfe4 ctermfg=188
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 7: hi PmenuSel guibg=#61afef ctermbg=75
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi PmenuSel gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 92: call s:h("PmenuSbar", "", s:selection, "")
calling <SNR>19_h('PmenuSbar', '', {'gui': '#474e5d', 'cterm': '239'}, '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 4: hi PmenuSbar guifg=NONE cterm=NONE
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 7: hi PmenuSbar guibg=#474e5d ctermbg=239
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi PmenuSbar gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 93: call s:h("PmenuThumb", "", s:fg, "")
calling <SNR>19_h('PmenuThumb', '', {'gui': '#dcdfe4', 'cterm': '188'}, '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 4: hi PmenuThumb guifg=NONE cterm=NONE
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 7: hi PmenuThumb guibg=#dcdfe4 ctermbg=188
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi PmenuThumb gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 94: 
line 95: call s:h("SpellBad", s:red, "", "")
calling <SNR>19_h('SpellBad', {'gui': '#e06c75', 'cterm': '168'}, '', '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi SpellBad guifg=#e06c75 ctermfg=168
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi SpellBad guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi SpellBad gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 96: call s:h("SpellCap", s:yellow, "", "")
calling <SNR>19_h('SpellCap', {'gui': '#e5c07b', 'cterm': '180'}, '', '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi SpellCap guifg=#e5c07b ctermfg=180
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi SpellCap guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi SpellCap gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 97: call s:h("SpellLocal", s:yellow, "", "")
calling <SNR>19_h('SpellLocal', {'gui': '#e5c07b', 'cterm': '180'}, '', '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi SpellLocal guifg=#e5c07b ctermfg=180
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi SpellLocal guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi SpellLocal gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 98: call s:h("SpellRare", s:yellow, "", "")
calling <SNR>19_h('SpellRare', {'gui': '#e5c07b', 'cterm': '180'}, '', '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi SpellRare guifg=#e5c07b ctermfg=180
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi SpellRare guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi SpellRare gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 99: 
line 100: call s:h("StatusLine", s:blue, s:cursor_line, "")
calling <SNR>19_h('StatusLine', {'gui': '#61afef', 'cterm': '75'}, {'gui': '#313640', 'cterm': '237'}, '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi StatusLine guifg=#61afef ctermfg=75
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 7: hi StatusLine guibg=#313640 ctermbg=237
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi StatusLine gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 101: call s:h("StatusLineNC", s:comment_fg, s:cursor_line, "")
calling <SNR>19_h('StatusLineNC', {'gui': '#5c6370', 'cterm': '241'}, {'gui': '#313640', 'cterm': '237'}, '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi StatusLineNC guifg=#5c6370 ctermfg=241
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 7: hi StatusLineNC guibg=#313640 ctermbg=237
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi StatusLineNC gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 102: call s:h("TabLine", s:comment_fg, s:cursor_line, "")
calling <SNR>19_h('TabLine', {'gui': '#5c6370', 'cterm': '241'}, {'gui': '#313640', 'cterm': '237'}, '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi TabLine guifg=#5c6370 ctermfg=241
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 7: hi TabLine guibg=#313640 ctermbg=237
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi TabLine gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 103: call s:h("TabLineFill", s:comment_fg, s:cursor_line, "")
calling <SNR>19_h('TabLineFill', {'gui': '#5c6370', 'cterm': '241'}, {'gui': '#313640', 'cterm': '237'}, '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi TabLineFill guifg=#5c6370 ctermfg=241
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 7: hi TabLineFill guibg=#313640 ctermbg=237
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi TabLineFill gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 104: call s:h("TabLineSel", s:fg, s:bg, "")
calling <SNR>19_h('TabLineSel', {'gui': '#dcdfe4', 'cterm': '188'}, {'gui': '#282c34', 'cterm': '236'}, '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi TabLineSel guifg=#dcdfe4 ctermfg=188
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 7: hi TabLineSel guibg=#282c34 ctermbg=236
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi TabLineSel gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 105: 
line 106: call s:h("Visual", "", s:selection, "")
calling <SNR>19_h('Visual', '', {'gui': '#474e5d', 'cterm': '239'}, '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 4: hi Visual guifg=NONE cterm=NONE
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 7: hi Visual guibg=#474e5d ctermbg=239
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi Visual gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 107: call s:h("VisualNOS", "", s:selection, "")
calling <SNR>19_h('VisualNOS', '', {'gui': '#474e5d', 'cterm': '239'}, '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 4: hi VisualNOS guifg=NONE cterm=NONE
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 7: hi VisualNOS guibg=#474e5d ctermbg=239
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi VisualNOS gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 108: 
line 109: call s:h("ColorColumn", "", s:color_col, "")
calling <SNR>19_h('ColorColumn', '', {'gui': '#313640', 'cterm': '237'}, '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 4: hi ColorColumn guifg=NONE cterm=NONE
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 7: hi ColorColumn guibg=#313640 ctermbg=237
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi ColorColumn gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 110: call s:h("Conceal", s:fg, "", "")
calling <SNR>19_h('Conceal', {'gui': '#dcdfe4', 'cterm': '188'}, '', '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi Conceal guifg=#dcdfe4 ctermfg=188
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi Conceal guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi Conceal gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 111: call s:h("Directory", s:blue, "", "")
calling <SNR>19_h('Directory', {'gui': '#61afef', 'cterm': '75'}, '', '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi Directory guifg=#61afef ctermfg=75
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi Directory guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi Directory gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 112: call s:h("VertSplit", s:vertsplit, s:vertsplit, "")
calling <SNR>19_h('VertSplit', {'gui': '#313640', 'cterm': '237'}, {'gui': '#313640', 'cterm': '237'}, '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi VertSplit guifg=#313640 ctermfg=237
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 7: hi VertSplit guibg=#313640 ctermbg=237
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi VertSplit gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 113: call s:h("Folded", s:fg, "", "")
calling <SNR>19_h('Folded', {'gui': '#dcdfe4', 'cterm': '188'}, '', '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi Folded guifg=#dcdfe4 ctermfg=188
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi Folded guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi Folded gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 114: call s:h("FoldColumn", s:fg, "", "")
calling <SNR>19_h('FoldColumn', {'gui': '#dcdfe4', 'cterm': '188'}, '', '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi FoldColumn guifg=#dcdfe4 ctermfg=188
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi FoldColumn guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi FoldColumn gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 115: call s:h("SignColumn", s:fg, "", "")
calling <SNR>19_h('SignColumn', {'gui': '#dcdfe4', 'cterm': '188'}, '', '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi SignColumn guifg=#dcdfe4 ctermfg=188
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi SignColumn guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi SignColumn gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 116: 
line 117: call s:h("MatchParen", s:blue, "", "underline")
calling <SNR>19_h('MatchParen', {'gui': '#61afef', 'cterm': '75'}, '', 'underline')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi MatchParen guifg=#61afef ctermfg=75
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi MatchParen guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 12: hi MatchParen gui=underline cterm=underline
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 118: call s:h("SpecialKey", s:fg, "", "")
calling <SNR>19_h('SpecialKey', {'gui': '#dcdfe4', 'cterm': '188'}, '', '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi SpecialKey guifg=#dcdfe4 ctermfg=188
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi SpecialKey guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi SpecialKey gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 119: call s:h("Title", s:green, "", "")
calling <SNR>19_h('Title', {'gui': '#98c379', 'cterm': '114'}, '', '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi Title guifg=#98c379 ctermfg=114
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi Title guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi Title gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 120: call s:h("WildMenu", s:fg, "", "")
calling <SNR>19_h('WildMenu', {'gui': '#dcdfe4', 'cterm': '188'}, '', '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi WildMenu guifg=#dcdfe4 ctermfg=188
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi WildMenu guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi WildMenu gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 121: " }
line 122: 
line 123: 
line 124: " Syntax colors {
line 125: " Whitespace is defined in Neovim, not Vim.
line 126: " See :help hl-Whitespace and :help hl-SpecialKey
line 127: call s:h("Whitespace", s:non_text, "", "")
calling <SNR>19_h('Whitespace', {'gui': '#373C45', 'cterm': '239'}, '', '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi Whitespace guifg=#373C45 ctermfg=239
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi Whitespace guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi Whitespace gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 128: call s:h("NonText", s:non_text, "", "")
calling <SNR>19_h('NonText', {'gui': '#373C45', 'cterm': '239'}, '', '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi NonText guifg=#373C45 ctermfg=239
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi NonText guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi NonText gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 129: call s:h("Comment", s:comment_fg, "", "italic")
calling <SNR>19_h('Comment', {'gui': '#5c6370', 'cterm': '241'}, '', 'italic')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi Comment guifg=#5c6370 ctermfg=241
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi Comment guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 12: hi Comment gui=italic cterm=italic
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 130: call s:h("Constant", s:cyan, "", "")
calling <SNR>19_h('Constant', {'gui': '#56b6c2', 'cterm': '73'}, '', '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi Constant guifg=#56b6c2 ctermfg=73
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi Constant guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi Constant gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 131: call s:h("String", s:green, "", "")
calling <SNR>19_h('String', {'gui': '#98c379', 'cterm': '114'}, '', '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi String guifg=#98c379 ctermfg=114
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi String guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi String gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 132: call s:h("Character", s:green, "", "")
calling <SNR>19_h('Character', {'gui': '#98c379', 'cterm': '114'}, '', '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi Character guifg=#98c379 ctermfg=114
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi Character guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi Character gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 133: call s:h("Number", s:yellow, "", "")
calling <SNR>19_h('Number', {'gui': '#e5c07b', 'cterm': '180'}, '', '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi Number guifg=#e5c07b ctermfg=180
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi Number guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi Number gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 134: call s:h("Boolean", s:yellow, "", "")
calling <SNR>19_h('Boolean', {'gui': '#e5c07b', 'cterm': '180'}, '', '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi Boolean guifg=#e5c07b ctermfg=180
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi Boolean guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi Boolean gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 135: call s:h("Float", s:yellow, "", "")
calling <SNR>19_h('Float', {'gui': '#e5c07b', 'cterm': '180'}, '', '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi Float guifg=#e5c07b ctermfg=180
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi Float guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi Float gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 136: 
line 137: call s:h("Identifier", s:red, "", "")
calling <SNR>19_h('Identifier', {'gui': '#e06c75', 'cterm': '168'}, '', '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi Identifier guifg=#e06c75 ctermfg=168
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi Identifier guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi Identifier gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 138: call s:h("Function", s:blue, "", "")
calling <SNR>19_h('Function', {'gui': '#61afef', 'cterm': '75'}, '', '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi Function guifg=#61afef ctermfg=75
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi Function guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi Function gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 139: call s:h("Statement", s:purple, "", "")
calling <SNR>19_h('Statement', {'gui': '#c678dd', 'cterm': '176'}, '', '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi Statement guifg=#c678dd ctermfg=176
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi Statement guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi Statement gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 140: 
line 141: call s:h("Conditional", s:purple, "", "")
calling <SNR>19_h('Conditional', {'gui': '#c678dd', 'cterm': '176'}, '', '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi Conditional guifg=#c678dd ctermfg=176
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi Conditional guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi Conditional gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 142: call s:h("Repeat", s:purple, "", "")
calling <SNR>19_h('Repeat', {'gui': '#c678dd', 'cterm': '176'}, '', '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi Repeat guifg=#c678dd ctermfg=176
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi Repeat guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi Repeat gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 143: call s:h("Label", s:purple, "", "")
calling <SNR>19_h('Label', {'gui': '#c678dd', 'cterm': '176'}, '', '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi Label guifg=#c678dd ctermfg=176
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi Label guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi Label gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 144: call s:h("Operator", s:fg, "", "")
calling <SNR>19_h('Operator', {'gui': '#dcdfe4', 'cterm': '188'}, '', '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi Operator guifg=#dcdfe4 ctermfg=188
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi Operator guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi Operator gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 145: call s:h("Keyword", s:red, "", "")
calling <SNR>19_h('Keyword', {'gui': '#e06c75', 'cterm': '168'}, '', '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi Keyword guifg=#e06c75 ctermfg=168
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi Keyword guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi Keyword gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 146: call s:h("Exception", s:purple, "", "")
calling <SNR>19_h('Exception', {'gui': '#c678dd', 'cterm': '176'}, '', '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi Exception guifg=#c678dd ctermfg=176
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi Exception guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi Exception gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 147: 
line 148: call s:h("PreProc", s:yellow, "", "")
calling <SNR>19_h('PreProc', {'gui': '#e5c07b', 'cterm': '180'}, '', '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi PreProc guifg=#e5c07b ctermfg=180
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi PreProc guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi PreProc gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 149: call s:h("Include", s:purple, "", "")
calling <SNR>19_h('Include', {'gui': '#c678dd', 'cterm': '176'}, '', '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi Include guifg=#c678dd ctermfg=176
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi Include guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi Include gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 150: call s:h("Define", s:purple, "", "")
calling <SNR>19_h('Define', {'gui': '#c678dd', 'cterm': '176'}, '', '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi Define guifg=#c678dd ctermfg=176
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi Define guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi Define gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 151: call s:h("Macro", s:purple, "", "")
calling <SNR>19_h('Macro', {'gui': '#c678dd', 'cterm': '176'}, '', '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi Macro guifg=#c678dd ctermfg=176
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi Macro guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi Macro gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 152: call s:h("PreCondit", s:yellow, "", "")
calling <SNR>19_h('PreCondit', {'gui': '#e5c07b', 'cterm': '180'}, '', '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi PreCondit guifg=#e5c07b ctermfg=180
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi PreCondit guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi PreCondit gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 153: 
line 154: call s:h("Type", s:yellow, "", "")
calling <SNR>19_h('Type', {'gui': '#e5c07b', 'cterm': '180'}, '', '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi Type guifg=#e5c07b ctermfg=180
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi Type guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi Type gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 155: call s:h("StorageClass", s:yellow, "", "")
calling <SNR>19_h('StorageClass', {'gui': '#e5c07b', 'cterm': '180'}, '', '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi StorageClass guifg=#e5c07b ctermfg=180
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi StorageClass guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi StorageClass gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 156: call s:h("Structure", s:yellow, "", "")
calling <SNR>19_h('Structure', {'gui': '#e5c07b', 'cterm': '180'}, '', '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi Structure guifg=#e5c07b ctermfg=180
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi Structure guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi Structure gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 157: call s:h("Typedef", s:yellow, "", "")
calling <SNR>19_h('Typedef', {'gui': '#e5c07b', 'cterm': '180'}, '', '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi Typedef guifg=#e5c07b ctermfg=180
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi Typedef guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi Typedef gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 158: 
line 159: call s:h("Special", s:blue, "", "")
calling <SNR>19_h('Special', {'gui': '#61afef', 'cterm': '75'}, '', '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi Special guifg=#61afef ctermfg=75
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi Special guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi Special gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 160: call s:h("SpecialChar", s:fg, "", "")
calling <SNR>19_h('SpecialChar', {'gui': '#dcdfe4', 'cterm': '188'}, '', '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi SpecialChar guifg=#dcdfe4 ctermfg=188
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi SpecialChar guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi SpecialChar gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 161: call s:h("Tag", s:fg, "", "")
calling <SNR>19_h('Tag', {'gui': '#dcdfe4', 'cterm': '188'}, '', '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi Tag guifg=#dcdfe4 ctermfg=188
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi Tag guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi Tag gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 162: call s:h("Delimiter", s:fg, "", "")
calling <SNR>19_h('Delimiter', {'gui': '#dcdfe4', 'cterm': '188'}, '', '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi Delimiter guifg=#dcdfe4 ctermfg=188
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi Delimiter guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi Delimiter gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 163: call s:h("SpecialComment", s:fg, "", "")
calling <SNR>19_h('SpecialComment', {'gui': '#dcdfe4', 'cterm': '188'}, '', '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi SpecialComment guifg=#dcdfe4 ctermfg=188
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi SpecialComment guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi SpecialComment gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 164: call s:h("Debug", s:fg, "", "")
calling <SNR>19_h('Debug', {'gui': '#dcdfe4', 'cterm': '188'}, '', '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi Debug guifg=#dcdfe4 ctermfg=188
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi Debug guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi Debug gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 165: call s:h("Underlined", s:fg, "", "")
calling <SNR>19_h('Underlined', {'gui': '#dcdfe4', 'cterm': '188'}, '', '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi Underlined guifg=#dcdfe4 ctermfg=188
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi Underlined guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi Underlined gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 166: call s:h("Ignore", s:fg, "", "")
calling <SNR>19_h('Ignore', {'gui': '#dcdfe4', 'cterm': '188'}, '', '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi Ignore guifg=#dcdfe4 ctermfg=188
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi Ignore guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi Ignore gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 167: call s:h("Error", s:red, s:gutter_bg, "")
calling <SNR>19_h('Error', {'gui': '#e06c75', 'cterm': '168'}, {'gui': '#282c34', 'cterm': '236'}, '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi Error guifg=#e06c75 ctermfg=168
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 7: hi Error guibg=#282c34 ctermbg=236
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi Error gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 168: call s:h("Todo", s:purple, "", "")
calling <SNR>19_h('Todo', {'gui': '#c678dd', 'cterm': '176'}, '', '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi Todo guifg=#c678dd ctermfg=176
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi Todo guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi Todo gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 169: " }
line 170: 
line 171: 
line 172: " Plugins {
line 173: " GitGutter
line 174: call s:h("GitGutterAdd", s:green, s:gutter_bg, "")
calling <SNR>19_h('GitGutterAdd', {'gui': '#98c379', 'cterm': '114'}, {'gui': '#282c34', 'cterm': '236'}, '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi GitGutterAdd guifg=#98c379 ctermfg=114
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 7: hi GitGutterAdd guibg=#282c34 ctermbg=236
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi GitGutterAdd gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 175: call s:h("GitGutterDelete", s:red, s:gutter_bg, "")
calling <SNR>19_h('GitGutterDelete', {'gui': '#e06c75', 'cterm': '168'}, {'gui': '#282c34', 'cterm': '236'}, '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi GitGutterDelete guifg=#e06c75 ctermfg=168
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 7: hi GitGutterDelete guibg=#282c34 ctermbg=236
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi GitGutterDelete gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 176: call s:h("GitGutterChange", s:yellow, s:gutter_bg, "")
calling <SNR>19_h('GitGutterChange', {'gui': '#e5c07b', 'cterm': '180'}, {'gui': '#282c34', 'cterm': '236'}, '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi GitGutterChange guifg=#e5c07b ctermfg=180
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 7: hi GitGutterChange guibg=#282c34 ctermbg=236
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi GitGutterChange gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 177: call s:h("GitGutterChangeDelete", s:red, s:gutter_bg, "")
calling <SNR>19_h('GitGutterChangeDelete', {'gui': '#e06c75', 'cterm': '168'}, {'gui': '#282c34', 'cterm': '236'}, '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi GitGutterChangeDelete guifg=#e06c75 ctermfg=168
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 7: hi GitGutterChangeDelete guibg=#282c34 ctermbg=236
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi GitGutterChangeDelete gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 178: " Fugitive
line 179: call s:h("diffAdded", s:green, "", "")
calling <SNR>19_h('diffAdded', {'gui': '#98c379', 'cterm': '114'}, '', '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi diffAdded guifg=#98c379 ctermfg=114
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi diffAdded guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi diffAdded gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 180: call s:h("diffRemoved", s:red, "", "")
calling <SNR>19_h('diffRemoved', {'gui': '#e06c75', 'cterm': '168'}, '', '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi diffRemoved guifg=#e06c75 ctermfg=168
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi diffRemoved guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi diffRemoved gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 181: " }
line 182: 
line 183: 
line 184: " Git {
line 185: call s:h("gitcommitComment", s:comment_fg, "", "")
calling <SNR>19_h('gitcommitComment', {'gui': '#5c6370', 'cterm': '241'}, '', '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi gitcommitComment guifg=#5c6370 ctermfg=241
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi gitcommitComment guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi gitcommitComment gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 186: call s:h("gitcommitUnmerged", s:red, "", "")
calling <SNR>19_h('gitcommitUnmerged', {'gui': '#e06c75', 'cterm': '168'}, '', '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi gitcommitUnmerged guifg=#e06c75 ctermfg=168
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi gitcommitUnmerged guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi gitcommitUnmerged gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 187: call s:h("gitcommitOnBranch", s:fg, "", "")
calling <SNR>19_h('gitcommitOnBranch', {'gui': '#dcdfe4', 'cterm': '188'}, '', '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi gitcommitOnBranch guifg=#dcdfe4 ctermfg=188
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi gitcommitOnBranch guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi gitcommitOnBranch gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 188: call s:h("gitcommitBranch", s:purple, "", "")
calling <SNR>19_h('gitcommitBranch', {'gui': '#c678dd', 'cterm': '176'}, '', '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi gitcommitBranch guifg=#c678dd ctermfg=176
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi gitcommitBranch guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi gitcommitBranch gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 189: call s:h("gitcommitDiscardedType", s:red, "", "")
calling <SNR>19_h('gitcommitDiscardedType', {'gui': '#e06c75', 'cterm': '168'}, '', '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi gitcommitDiscardedType guifg=#e06c75 ctermfg=168
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi gitcommitDiscardedType guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi gitcommitDiscardedType gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 190: call s:h("gitcommitSelectedType", s:green, "", "")
calling <SNR>19_h('gitcommitSelectedType', {'gui': '#98c379', 'cterm': '114'}, '', '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi gitcommitSelectedType guifg=#98c379 ctermfg=114
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi gitcommitSelectedType guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi gitcommitSelectedType gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 191: call s:h("gitcommitHeader", s:fg, "", "")
calling <SNR>19_h('gitcommitHeader', {'gui': '#dcdfe4', 'cterm': '188'}, '', '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi gitcommitHeader guifg=#dcdfe4 ctermfg=188
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi gitcommitHeader guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi gitcommitHeader gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 192: call s:h("gitcommitUntrackedFile", s:cyan, "", "")
calling <SNR>19_h('gitcommitUntrackedFile', {'gui': '#56b6c2', 'cterm': '73'}, '', '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi gitcommitUntrackedFile guifg=#56b6c2 ctermfg=73
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi gitcommitUntrackedFile guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi gitcommitUntrackedFile gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 193: call s:h("gitcommitDiscardedFile", s:red, "", "")
calling <SNR>19_h('gitcommitDiscardedFile', {'gui': '#e06c75', 'cterm': '168'}, '', '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi gitcommitDiscardedFile guifg=#e06c75 ctermfg=168
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi gitcommitDiscardedFile guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi gitcommitDiscardedFile gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 194: call s:h("gitcommitSelectedFile", s:green, "", "")
calling <SNR>19_h('gitcommitSelectedFile', {'gui': '#98c379', 'cterm': '114'}, '', '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi gitcommitSelectedFile guifg=#98c379 ctermfg=114
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi gitcommitSelectedFile guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi gitcommitSelectedFile gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 195: call s:h("gitcommitUnmergedFile", s:yellow, "", "")
calling <SNR>19_h('gitcommitUnmergedFile', {'gui': '#e5c07b', 'cterm': '180'}, '', '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi gitcommitUnmergedFile guifg=#e5c07b ctermfg=180
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi gitcommitUnmergedFile guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi gitcommitUnmergedFile gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 196: call s:h("gitcommitFile", s:fg, "", "")
calling <SNR>19_h('gitcommitFile', {'gui': '#dcdfe4', 'cterm': '188'}, '', '')

line 1:   if type(a:fg) == type({})
line 2:     exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
line 2: hi gitcommitFile guifg=#dcdfe4 ctermfg=188
line 3:   else
line 4:     exec "hi " . a:group . " guifg=NONE cterm=NONE"
line 5:   endif
line 6:   if type(a:bg) == type({})
line 7:     exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
line 8:   else
line 9:     exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
line 9: hi gitcommitFile guibg=NONE ctermbg=NONE
line 10:   endif
line 11:   if a:attr != ""
line 12:     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
line 13:   else
line 14:     exec "hi " . a:group . " gui=NONE cterm=NONE"
line 14: hi gitcommitFile gui=NONE cterm=NONE
line 15:   endif
<SNR>19_h returning #0

continuing in /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim

line 197: hi link gitcommitNoBranch gitcommitBranch
line 198: hi link gitcommitUntracked gitcommitComment
line 199: hi link gitcommitDiscarded gitcommitComment
line 200: hi link gitcommitSelected gitcommitComment
line 201: hi link gitcommitDiscardedArrow gitcommitDiscardedFile
line 202: hi link gitcommitSelectedArrow gitcommitSelectedFile
line 203: hi link gitcommitUnmergedArrow gitcommitUnmergedFile
line 204: " }
line 205: 
line 206: " Fix colors in neovim terminal buffers {
line 207:   if has('nvim')
line 208:     let g:terminal_color_0 = s:black.gui
line 209:     let g:terminal_color_1 = s:red.gui
line 210:     let g:terminal_color_2 = s:green.gui
line 211:     let g:terminal_color_3 = s:yellow.gui
line 212:     let g:terminal_color_4 = s:blue.gui
line 213:     let g:terminal_color_5 = s:purple.gui
line 214:     let g:terminal_color_6 = s:cyan.gui
line 215:     let g:terminal_color_7 = s:white.gui
line 216:     let g:terminal_color_8 = s:black.gui
line 217:     let g:terminal_color_9 = s:red.gui
line 218:     let g:terminal_color_10 = s:green.gui
line 219:     let g:terminal_color_11 = s:yellow.gui
line 220:     let g:terminal_color_12 = s:blue.gui
line 221:     let g:terminal_color_13 = s:purple.gui
line 222:     let g:terminal_color_14 = s:cyan.gui
line 223:     let g:terminal_color_15 = s:white.gui
line 224:     let g:terminal_color_background = s:bg.gui
line 225:     let g:terminal_color_foreground = s:fg.gui
line 226:   endif
line 227: " }
finished sourcing /home/Dante/.vim/plugged/onehalf/vim/colors/onehalfdark.vim
continuing in /home/Dante/.vimrc
line 283: 
line 284: "Lightline Settings
line 285: set laststatus=2
line 286: set noshowmode
line 287: 
line 288: "Transparency
line 289: hi Normal guibg=NONE ctermbg=NONE
line 290: 
line 291: "Note: in the onehalfdark/vim/colors/onehalfdark.vim
line 292:     "set s:h("CursorLineNr, "", s:cursor_line, "", )
line 293:     "set s:h("LineNr, s:fg, "", "")
line 294: "highlight CursorLineNr 'cterm={"cterm": "188"}'
line 295: highlight LineNr ctermbg=NONE ctermfg=NONE cterm=NONE gui=NONE guifg=NONE guibg=NONE
line 296: 
line 297: "}}}
line 298: 
line 299: 
finished sourcing $HOME/.vimrc
Searching for "pack/*/start/*" in "/home/Dante/.vim,/usr/share/vim/vimfiles,/usr/share/vim/vim91,/usr/share/vim/vimfiles/after,/home/Dante/.vim/after"
Searching for "/home/Dante/.vim/pack/*/start/*"
Searching for "/usr/share/vim/vimfiles/pack/*/start/*"
Searching for "/usr/share/vim/vim91/pack/*/start/*"
Searching for "/usr/share/vim/vimfiles/after/pack/*/start/*"
Searching for "/home/Dante/.vim/after/pack/*/start/*"
not found in 'packpath': "pack/*/start/*"
Searching for "plugin/**/*.vim" in "/home/Dante/.vim,/home/Dante/.vim/plugged/onedark.vim,/home/Dante/.vim/plugged/onehalf/vim,/home/Dante/.vim/plugged/gruvbox,/home/Dante/.vim/plugged/lightline.vim,/home/Dante/.vim/plugged/vim-tmux-navigator,/home/Dante/.vim/plugged/vimtex,/home/Dante/.vim/plugged/nerdtree,/home/Dante/.vim/plugged/fzf,/home/Dante/.vim/plugged/fzf.vim,/home/Dante/.vim/plugged/vim-wayland-clipboard,/home/Dante/.vim/plugged/coc.nvim,/home/Dante/.vim/plugged/vim-obsession,/usr/share/vim/vimfiles,/usr/share/vim/vim91,/usr/share/vim/vimfiles/after,/home/Dante/.vim/plugged/vimtex/after,/home/Dante/.vim/after"
Searching for "/home/Dante/.vim/plugin/**/*.vim"
Searching for "/home/Dante/.vim/plugged/onedark.vim/plugin/**/*.vim"
Searching for "/home/Dante/.vim/plugged/onehalf/vim/plugin/**/*.vim"
Searching for "/home/Dante/.vim/plugged/gruvbox/plugin/**/*.vim"
Searching for "/home/Dante/.vim/plugged/lightline.vim/plugin/**/*.vim"
chdir(/home/Dante/.vim/plugged/lightline.vim/plugin)
fchdir() to previous dir
sourcing "/home/Dante/.vim/plugged/lightline.vim/plugin/lightline.vim"
line 1: " =============================================================================
line 2: " Filename: plugin/lightline.vim
line 3: " Author: itchyny
line 4: " License: MIT License
line 5: " Last Change: 2021/11/21 22:54:41.
line 6: " =============================================================================
line 7: 
line 8: if exists('g:loaded_lightline') || v:version < 703
line 9:   finish
line 10: endif
line 11: let g:loaded_lightline = 1
line 12: 
line 13: let s:save_cpo = &cpo
line 14: set cpo&vim
line 15: 
line 16: augroup lightline
line 17:   autocmd!
line 18:   autocmd WinEnter,BufEnter,SessionLoadPost,FileChangedShellPost * call lightline#update()
line 19:   if !has('patch-8.1.1715')
line 20:     autocmd FileType qf call lightline#update()
line 21:   endif
line 22:   autocmd SessionLoadPost * call lightline#highlight()
line 23:   autocmd ColorScheme * if !has('vim_starting') || expand('<amatch>') !=# 'macvim' | call lightline#update() | call lightline#highlight() | endif
line 25: augroup END
line 26: 
line 27: " This quickfix option was introduced at Vim 85850f3a5ef9, which is the commit
line 28: " just before 8.1.1715. Before this patch, autocmd FileType is required to
line 29: " overwrite the statusline of the quickfix and location windows.
line 30: let g:qf_disable_statusline = 1
line 31: 
line 32: let &cpo = s:save_cpo
line 33: unlet s:save_cpo
finished sourcing /home/Dante/.vim/plugged/lightline.vim/plugin/lightline.vim
Searching for "/home/Dante/.vim/plugged/vim-tmux-navigator/plugin/**/*.vim"
chdir(/home/Dante/.vim/plugged/vim-tmux-navigator/plugin)
fchdir() to previous dir
sourcing "/home/Dante/.vim/plugged/vim-tmux-navigator/plugin/tmux_navigator.vim"
line 1: " Maps <C-h/j/k/l> to switch vim splits in the given direction. If there are
line 2: " no more windows in that direction, forwards the operation to tmux.
line 3: " Additionally, <C-\> toggles between last active vim splits/tmux panes.
line 4: 
line 5: if exists("g:loaded_tmux_navigator") || &cp || v:version < 700
line 6:   finish
line 7: endif
line 8: let g:loaded_tmux_navigator = 1
line 9: 
line 10: function! s:VimNavigate(direction)
line 17: 
line 18: if !get(g:, 'tmux_navigator_no_mappings', 0)
line 19:   nnoremap <silent> <c-h> :<C-U>TmuxNavigateLeft<cr>
line 20:   nnoremap <silent> <c-j> :<C-U>TmuxNavigateDown<cr>
line 21:   nnoremap <silent> <c-k> :<C-U>TmuxNavigateUp<cr>
line 22:   nnoremap <silent> <c-l> :<C-U>TmuxNavigateRight<cr>
line 23:   nnoremap <silent> <c-\> :<C-U>TmuxNavigatePrevious<cr>
line 24: 
line 25:   if !get(g:, 'tmux_navigator_disable_netrw_workaround', 0)
line 26:     if !exists('g:Netrw_UserMaps')
line 27:       let g:Netrw_UserMaps = [['<C-l>', '<C-U>TmuxNavigateRight<cr>']]
line 28:     else
line 29:       echohl ErrorMsg | echo 'vim-tmux-navigator conflicts with netrw <C-l> mapping. See https://github.com/christoomey/vim-tmux-navigator#netrw or add `let g:tmux_navigator_disable_netrw_workaround = 1` to suppress this warning.' | echohl None
line 29:  echo 'vim-tmux-navigator conflicts with netrw <C-l> mapping. See https://github.com/christoomey/vim-tmux-navigator#netrw or add `let g:tmux_navigator_disable_netrw_workaround = 1` to suppress this warning.' | echohl None
line 29:  echohl None
line 30:     endif
line 31:   endif
line 32: endif
line 33: 
line 34: if empty($TMUX)
line 35:   command! TmuxNavigateLeft call s:VimNavigate('h')
line 36:   command! TmuxNavigateDown call s:VimNavigate('j')
line 37:   command! TmuxNavigateUp call s:VimNavigate('k')
line 38:   command! TmuxNavigateRight call s:VimNavigate('l')
line 39:   command! TmuxNavigatePrevious call s:VimNavigate('p')
line 40:   finish
line 41: endif
line 42: 
line 43: command! TmuxNavigateLeft call s:TmuxAwareNavigate('h')
line 44: command! TmuxNavigateDown call s:TmuxAwareNavigate('j')
line 45: command! TmuxNavigateUp call s:TmuxAwareNavigate('k')
line 46: command! TmuxNavigateRight call s:TmuxAwareNavigate('l')
line 47: command! TmuxNavigatePrevious call s:TmuxAwareNavigate('p')
line 48: 
line 49: if !exists("g:tmux_navigator_save_on_switch")
line 50:   let g:tmux_navigator_save_on_switch = 0
line 51: endif
line 52: 
line 53: if !exists("g:tmux_navigator_disable_when_zoomed")
line 54:   let g:tmux_navigator_disable_when_zoomed = 0
line 55: endif
line 56: 
line 57: if !exists("g:tmux_navigator_preserve_zoom")
line 58:   let g:tmux_navigator_preserve_zoom = 0
line 59: endif
line 60: 
line 61: if !exists("g:tmux_navigator_no_wrap")
line 62:   let g:tmux_navigator_no_wrap = 0
line 63: endif
line 64: 
line 65: let s:pane_position_from_direction = {'h': 'left', 'j': 'bottom', 'k': 'top', 'l': 'right'}
line 66: 
line 67: function! s:TmuxOrTmateExecutable()
line 70: 
line 71: function! s:TmuxVimPaneIsZoomed()
line 74: 
line 75: function! s:TmuxSocket()
line 79: 
line 80: function! s:TmuxCommand(args)
line 88: 
line 89: function! s:TmuxNavigatorProcessList()
line 92: command! TmuxNavigatorProcessList call s:TmuxNavigatorProcessList()
line 93: 
line 94: let s:tmux_is_last_pane = 0
line 95: augroup tmux_navigator
line 96:   au!
line 97:   autocmd WinEnter * let s:tmux_is_last_pane = 0
line 98: augroup END
line 99: 
line 100: function! s:NeedsVitalityRedraw()
line 103: 
line 104: function! s:ShouldForwardNavigationBackToTmux(tmux_last_pane, at_tab_page_edge)
line 110: 
line 111: function! s:TmuxAwareNavigate(direction)
finished sourcing /home/Dante/.vim/plugged/vim-tmux-navigator/plugin/tmux_navigator.vim
Searching for "/home/Dante/.vim/plugged/vimtex/plugin/**/*.vim"
chdir(/home/Dante/.vim/plugged/vimtex/plugin)
fchdir() to previous dir
sourcing "/home/Dante/.vim/plugged/vimtex/plugin/vimtex.vim"
line 1: " VimTeX - LaTeX plugin for Vim
line 2: "
line 3: " Maintainer: Karl Yngve Lervg
line 4: " Email:      karl.yngve@gmail.com
line 5: "
line 6: 
line 7: if !get(g:, 'vimtex_enabled', 1) | finish | endif
line 7:  finish | endif
line 7:  endif
line 8: if exists('g:loaded_vimtex') | finish | endif
line 8:  finish | endif
line 8:  endif
line 9: let g:loaded_vimtex = 1
line 10: 
line 11: 
line 12: command! -nargs=* VimtexInverseSearch call call('vimtex#view#inverse_search_cmd', s:parse_args(<q-args>))
line 14: 
line 15: 
line 16: function! s:parse_args(args) abort
finished sourcing /home/Dante/.vim/plugged/vimtex/plugin/vimtex.vim
Searching for "/home/Dante/.vim/plugged/nerdtree/plugin/**/*.vim"
chdir(/home/Dante/.vim/plugged/nerdtree/plugin)
fchdir() to previous dir
sourcing "/home/Dante/.vim/plugged/nerdtree/plugin/NERD_tree.vim"
line 1: " ============================================================================
line 2: " File:        NERD_tree.vim
line 3: " Maintainer:  Martin Grenfell <martin.grenfell at gmail dot com>
line 4: " License:     This program is free software. It comes without any warranty,
line 5: "              to the extent permitted by applicable law. You can redistribute
line 6: "              it and/or modify it under the terms of the Do What The Fuck You
line 7: "              Want To Public License, Version 2, as published by Sam Hocevar.
line 8: "              See http://sam.zoy.org/wtfpl/COPYING for more details.
line 9: "
line 10: " ============================================================================
line 11: "
line 12: " SECTION: Script init stuff {{{1
line 13: "============================================================
line 14: scriptencoding utf-8
line 15: 
line 16: if exists('loaded_nerd_tree')
line 17:     finish
line 18: endif
line 19: if v:version < 703
line 20:     echoerr "NERDTree: this plugin requires vim >= 7.3. DOWNLOAD IT! You'll thank me later!"
line 21:     finish
line 22: endif
line 23: let loaded_nerd_tree = 1
line 24: 
line 25: "for line continuation - i.e dont want C in &cpoptions
line 26: let s:old_cpo = &cpoptions
line 27: set cpoptions&vim
line 28: 
line 29: "SECTION: Initialize variable calls and other random constants {{{2
line 30: let g:NERDTreeAutoCenter            = get(g:, 'NERDTreeAutoCenter',            1)
line 31: let g:NERDTreeAutoCenterThreshold   = get(g:, 'NERDTreeAutoCenterThreshold',   3)
line 32: let g:NERDTreeCaseSensitiveFS       = get(g:, 'NERDTreeCaseSensitiveFS',       2)
line 33: let g:NERDTreeCaseSensitiveSort     = get(g:, 'NERDTreeCaseSensitiveSort',     0)
line 34: let g:NERDTreeNaturalSort           = get(g:, 'NERDTreeNaturalSort',           0)
line 35: let g:NERDTreeSortHiddenFirst       = get(g:, 'NERDTreeSortHiddenFirst',       1)
line 36: let g:NERDTreeUseTCD                = get(g:, 'NERDTreeUseTCD',                0)
line 37: let g:NERDTreeChDirMode             = get(g:, 'NERDTreeChDirMode',             0)
line 38: let g:NERDTreeCreatePrefix          = get(g:, 'NERDTreeCreatePrefix',          'silent')
line 39: let g:NERDTreeMinimalUI             = get(g:, 'NERDTreeMinimalUI',             0)
line 40: let g:NERDTreeMinimalMenu           = get(g:, 'NERDTreeMinimalMenu',           0)
line 41: let g:NERDTreeIgnore                = get(g:, 'NERDTreeIgnore',                ['\~$'])
line 42: let g:NERDTreeBookmarksFile         = get(g:, 'NERDTreeBookmarksFile',         expand('$HOME') . '/.NERDTreeBookmarks')
line 43: let g:NERDTreeBookmarksSort         = get(g:, 'NERDTreeBookmarksSort',         1)
line 44: let g:NERDTreeHighlightCursorline   = get(g:, 'NERDTreeHighlightCursorline',   1)
line 45: let g:NERDTreeHijackNetrw           = get(g:, 'NERDTreeHijackNetrw',           1)
line 46: let g:NERDTreeMarkBookmarks         = get(g:, 'NERDTreeMarkBookmarks',         1)
line 47: let g:NERDTreeMouseMode             = get(g:, 'NERDTreeMouseMode',             1)
line 48: let g:NERDTreeNotificationThreshold = get(g:, 'NERDTreeNotificationThreshold', 100)
line 49: let g:NERDTreeQuitOnOpen            = get(g:, 'NERDTreeQuitOnOpen',            0)
line 50: let g:NERDTreeRespectWildIgnore     = get(g:, 'NERDTreeRespectWildIgnore',     0)
line 51: let g:NERDTreeShowBookmarks         = get(g:, 'NERDTreeShowBookmarks',         0)
line 52: let g:NERDTreeShowFiles             = get(g:, 'NERDTreeShowFiles',             1)
line 53: let g:NERDTreeShowHidden            = get(g:, 'NERDTreeShowHidden',            0)
line 54: let g:NERDTreeShowLineNumbers       = get(g:, 'NERDTreeShowLineNumbers',       0)
line 55: let g:NERDTreeSortDirs              = get(g:, 'NERDTreeSortDirs',              1)
line 56: let g:NERDTreeFileLines             = get(g:, 'NERDTreeFileLines',             0)
line 57: 
line 58: 
line 59: if !nerdtree#runningWindows() && !nerdtree#runningCygwin()
Searching for "autoload/nerdtree.vim" in "/home/Dante/.vim,/home/Dante/.vim/plugged/onedark.vim,/home/Dante/.vim/plugged/onehalf/vim,/home/Dante/.vim/plugged/gruvbox,/home/Dante/.vim/plugged/lightline.vim,/home/Dante/.vim/plugged/vim-tmux-navigator,/home/Dante/.vim/plugged/vimtex,/home/Dante/.vim/plugged/nerdtree,/home/Dante/.vim/plugged/fzf,/home/Dante/.vim/plugged/fzf.vim,/home/Dante/.vim/plugged/vim-wayland-clipboard,/home/Dante/.vim/plugged/coc.nvim,/home/Dante/.vim/plugged/vim-obsession,/usr/share/vim/vimfiles,/usr/share/vim/vim91,/usr/share/vim/vimfiles/after,/home/Dante/.vim/plugged/vimtex/after,/home/Dante/.vim/after"
Searching for "/home/Dante/.vim/autoload/nerdtree.vim"
Searching for "/home/Dante/.vim/plugged/onedark.vim/autoload/nerdtree.vim"
Searching for "/home/Dante/.vim/plugged/onehalf/vim/autoload/nerdtree.vim"
Searching for "/home/Dante/.vim/plugged/gruvbox/autoload/nerdtree.vim"
Searching for "/home/Dante/.vim/plugged/lightline.vim/autoload/nerdtree.vim"
Searching for "/home/Dante/.vim/plugged/vim-tmux-navigator/autoload/nerdtree.vim"
Searching for "/home/Dante/.vim/plugged/vimtex/autoload/nerdtree.vim"
Searching for "/home/Dante/.vim/plugged/nerdtree/autoload/nerdtree.vim"
chdir(/home/Dante/.vim/plugged/nerdtree/autoload)
fchdir() to previous dir
line 59: sourcing "/home/Dante/.vim/plugged/nerdtree/autoload/nerdtree.vim"
line 1: if exists('g:loaded_nerdtree_autoload')
line 2:     finish
line 3: endif
line 4: let g:loaded_nerdtree_autoload = 1
line 5: 
line 6: let s:rootNERDTreePath = resolve(expand('<sfile>:p:h:h'))
line 7: 
line 8: "FUNCTION: nerdtree#version(...) {{{1
line 9: "  If any value is given as an argument, the entire line of text from the
line 10: "  change log is shown for the current version; otherwise, only the version
line 11: "  number is shown.
line 12: function! nerdtree#version(...) abort
line 29: 
line 30: " SECTION: General Functions {{{1
line 31: "============================================================
line 32: 
line 33: " FUNCTION: nerdtree#closeTreeOnOpen() {{{2
line 34: function! nerdtree#closeTreeOnOpen() abort
line 37: 
line 38: " FUNCTION: nerdtree#closeBookmarksOnOpen() {{{2
line 39: function! nerdtree#closeBookmarksOnOpen() abort
line 42: 
line 43: " FUNCTION: nerdtree#slash() {{{2
line 44: " Return the path separator used by the underlying file system.  Special
line 45: " consideration is taken for the use of the 'shellslash' option on Windows
line 46: " systems.
line 47: function! nerdtree#slash() abort
line 58: 
line 59: "FUNCTION: nerdtree#checkForBrowse(dir) {{{2
line 60: "inits a window tree in the current buffer if appropriate
line 61: function! nerdtree#checkForBrowse(dir) abort
line 72: 
line 73: "FUNCTION: s:reuseWin(dir) {{{2
line 74: "finds a NERDTree buffer with root of dir, and opens it.
line 75: function! s:reuseWin(dir) abort
line 94: 
line 95: " FUNCTION: nerdtree#completeBookmarks(A,L,P) {{{2
line 96: " completion function for the bookmark commands
line 97: function! nerdtree#completeBookmarks(A,L,P) abort
line 100: 
line 101: "FUNCTION: nerdtree#compareNodes(n1, n2) {{{2
line 102: function! nerdtree#compareNodes(n1, n2) abort
line 105: 
line 106: "FUNCTION: nerdtree#compareNodePaths(p1, p2) {{{2
line 107: function! nerdtree#compareNodePaths(p1, p2) abort
line 139: 
line 140: " FUNCTION: nerdtree#deprecated(func, [msg]) {{{2
line 141: " Issue a deprecation warning for a:func. If a second arg is given, use this
line 142: " as the deprecation message
line 143: function! nerdtree#deprecated(func, ...) abort
line 154: 
line 155: " FUNCTION: nerdtree#exec(cmd, ignoreAll) {{{2
line 156: " Same as :exec cmd but, if ignoreAll is TRUE, set eventignore=all for the duration
line 157: function! nerdtree#exec(cmd, ignoreAll) abort
line 168: 
line 169: " FUNCTION: nerdtree#has_opt(options, name) {{{2
line 170: function! nerdtree#has_opt(options, name) abort
line 173: 
line 174: " FUNCTION: nerdtree#loadClassFiles() {{{2
line 175: function! nerdtree#loadClassFiles() abort
line 191: 
line 192: " FUNCTION: nerdtree#postSourceActions() {{{2
line 193: function! nerdtree#postSourceActions() abort
line 200: 
line 201: "FUNCTION: nerdtree#runningWindows() {{{2
line 202: function! nerdtree#runningWindows() abort
line 205: 
line 206: "FUNCTION: nerdtree#runningCygwin() {{{2
line 207: function! nerdtree#runningCygwin() abort
line 210: 
line 211: "FUNCTION: nerdtree#runningMac() {{{2
line 212: function! nerdtree#runningMac() abort
line 215: 
line 216: " FUNCTION: nerdtree#osDefaultCaseSensitiveFS() {{{2
line 217: function! nerdtree#osDefaultCaseSensitiveFS() abort
line 220: 
line 221: " FUNCTION: nerdtree#caseSensitiveFS() {{{2
line 222: function! nerdtree#caseSensitiveFS() abort
line 227: 
line 228: "FUNCTION: nerdtree#pathEquals(lhs, rhs) {{{2
line 229: function! nerdtree#pathEquals(lhs, rhs) abort
line 236: 
line 237: "FUNCTION: nerdtree#onBufLeave() {{{2
line 238: " used for handling the nerdtree BufLeave/WinLeave events.
line 239: function! nerdtree#onBufLeave() abort
line 268: 
line 269: " SECTION: View Functions {{{1
line 270: "============================================================
line 271: 
line 272: "FUNCTION: nerdtree#echo  {{{2
line 273: "A wrapper for :echo. Appends 'NERDTree:' on the front of all messages
line 274: "
line 275: "Args:
line 276: "msg: the message to echo
line 277: function! nerdtree#echo(msg) abort
line 281: 
line 282: "FUNCTION: nerdtree#echoError {{{2
line 283: "Wrapper for nerdtree#echo, sets the message type to errormsg for this message
line 284: "Args:
line 285: "msg: the message to echo
line 286: function! nerdtree#echoError(msg) abort
line 291: 
line 292: "FUNCTION: nerdtree#echoWarning {{{2
line 293: "Wrapper for nerdtree#echo, sets the message type to warningmsg for this message
line 294: "Args:
line 295: "msg: the message to echo
line 296: function! nerdtree#echoWarning(msg) abort
line 301: 
line 302: "FUNCTION: nerdtree#renderView {{{2
line 303: function! nerdtree#renderView() abort
line 306: 
line 307: if nerdtree#runningWindows()
calling nerdtree#runningWindows()

line 1:     return has('win16') || has('win32') || has('win64')
nerdtree#runningWindows returning #0

continuing in /home/Dante/.vim/plugged/nerdtree/autoload/nerdtree.vim

line 308:     let s:osDefaultCaseSensitiveFS = 0
line 309: elseif nerdtree#runningMac()
calling nerdtree#runningMac()

line 1:     return has('gui_mac') || has('gui_macvim') || has('mac') || has('osx')
nerdtree#runningMac returning #0

continuing in /home/Dante/.vim/plugged/nerdtree/autoload/nerdtree.vim

line 310:     let s:osDefaultCaseSensitiveFS = 0
line 311: else
line 312:     let s:osDefaultCaseSensitiveFS = 1
line 313: endif
line 314: 
line 315: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/Dante/.vim/plugged/nerdtree/autoload/nerdtree.vim
continuing in /home/Dante/.vim/plugged/nerdtree/plugin/NERD_tree.vim
calling nerdtree#runningWindows()

line 1:     return has('win16') || has('win32') || has('win64')
nerdtree#runningWindows returning #0

continuing in /home/Dante/.vim/plugged/nerdtree/plugin/NERD_tree.vim

calling nerdtree#runningCygwin()

line 1:     return has('win32unix')
nerdtree#runningCygwin returning #0

continuing in /home/Dante/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 60:     let g:NERDTreeDirArrowExpandable  = get(g:, 'NERDTreeDirArrowExpandable',  '')
line 61:     let g:NERDTreeDirArrowCollapsible = get(g:, 'NERDTreeDirArrowCollapsible', '')
line 62: else
line 63:     let g:NERDTreeDirArrowExpandable  = get(g:, 'NERDTreeDirArrowExpandable',  '+')
line 64:     let g:NERDTreeDirArrowCollapsible = get(g:, 'NERDTreeDirArrowCollapsible', '~')
line 65: endif
line 66: 
line 67: let g:NERDTreeCascadeOpenSingleChildDir = get(g:, 'NERDTreeCascadeOpenSingleChildDir', 1)
line 68: let g:NERDTreeCascadeSingleChildDir     = get(g:, 'NERDTreeCascadeSingleChildDir',     1)
line 69: 
line 70: let g:NERDTreeSortOrder    = get(g:, 'NERDTreeSortOrder', ['\/$', '*', '\.swp$', '\.bak$', '\~$'])
line 71: let g:NERDTreeOldSortOrder = []
line 72: 
line 73: let g:NERDTreeGlyphReadOnly = get(g:, 'NERDTreeGlyphReadOnly', 'RO')
line 74: 
line 75: if has('conceal')
line 76:     let g:NERDTreeNodeDelimiter = get(g:, 'NERDTreeNodeDelimiter', "\x07")
line 77: elseif (g:NERDTreeDirArrowExpandable ==# "\u00a0" || g:NERDTreeDirArrowCollapsible ==# "\u00a0")
line 78:     let g:NERDTreeNodeDelimiter = get(g:, 'NERDTreeNodeDelimiter', "\u00b7")
line 79: else
line 80:     let g:NERDTreeNodeDelimiter = get(g:, 'NERDTreeNodeDelimiter', "\u00a0")
line 81: endif
line 82: 
line 83: "the exists() crap here is a hack to stop vim spazzing out when
line 84: "loading a session that was created with an open nerd tree. It spazzes
line 85: "because it doesnt store b:NERDTree(its a b: var, and its a hash)
line 86: let g:NERDTreeStatusline = get(g:, 'NERDTreeStatusline', "%{exists('b:NERDTree')?b:NERDTree.root.path.str():''}")
line 87: 
line 88: let g:NERDTreeWinPos  = get(g:, 'NERDTreeWinPos', 'left')
line 89: let g:NERDTreeWinSize = get(g:, 'NERDTreeWinSize', 31)
line 90: 
line 91: "init the shell commands that will be used to copy nodes, and remove dir trees
line 92: "Note: the space after the command is important
line 93: if nerdtree#runningWindows()
calling nerdtree#runningWindows()

line 1:     return has('win16') || has('win32') || has('win64')
nerdtree#runningWindows returning #0

continuing in /home/Dante/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 94:     let g:NERDTreeRemoveDirCmd = get(g:, 'NERDTreeRemoveDirCmd', 'rmdir /s /q ')
line 95:     let g:NERDTreeCopyDirCmd   = get(g:, 'NERDTreeCopyDirCmd',   'xcopy /s /e /i /y /q ')
line 96:     let g:NERDTreeCopyFileCmd  = get(g:, 'NERDTreeCopyFileCmd',  'copy /y ')
line 97: else
line 98:     let g:NERDTreeRemoveDirCmd = get(g:, 'NERDTreeRemoveDirCmd', 'rm -rf ')
line 99:     let g:NERDTreeCopyCmd      = get(g:, 'NERDTreeCopyCmd',      'cp -r ')
line 100: endif
line 101: 
line 102: "SECTION: Init variable calls for key mappings {{{2
line 103: let g:NERDTreeMapCustomOpen      = get(g:, 'NERDTreeMapCustomOpen',      '<CR>')
line 104: let g:NERDTreeMapJumpBookmarks   = get(g:, 'NERDTreeMapJumpBookmarks',   'gb')
line 105: let g:NERDTreeMapActivateNode    = get(g:, 'NERDTreeMapActivateNode',    'o')
line 106: let g:NERDTreeMapChangeRoot      = get(g:, 'NERDTreeMapChangeRoot',      'C')
line 107: let g:NERDTreeMapChdir           = get(g:, 'NERDTreeMapChdir',           'cd')
line 108: let g:NERDTreeMapCloseChildren   = get(g:, 'NERDTreeMapCloseChildren',   'X')
line 109: let g:NERDTreeMapCloseDir        = get(g:, 'NERDTreeMapCloseDir',        'x')
line 110: let g:NERDTreeMapDeleteBookmark  = get(g:, 'NERDTreeMapDeleteBookmark',  'D')
line 111: let g:NERDTreeMapMenu            = get(g:, 'NERDTreeMapMenu',            'm')
line 112: let g:NERDTreeMapHelp            = get(g:, 'NERDTreeMapHelp',            '?')
line 113: let g:NERDTreeMapJumpFirstChild  = get(g:, 'NERDTreeMapJumpFirstChild',  'K')
line 114: let g:NERDTreeMapJumpLastChild   = get(g:, 'NERDTreeMapJumpLastChild',   'J')
line 115: let g:NERDTreeMapJumpNextSibling = get(g:, 'NERDTreeMapJumpNextSibling', '<C-j>')
line 116: let g:NERDTreeMapJumpParent      = get(g:, 'NERDTreeMapJumpParent',      'p')
line 117: let g:NERDTreeMapJumpPrevSibling = get(g:, 'NERDTreeMapJumpPrevSibling', '<C-k>')
line 118: let g:NERDTreeMapJumpRoot        = get(g:, 'NERDTreeMapJumpRoot',        'P')
line 119: let g:NERDTreeMapOpenExpl        = get(g:, 'NERDTreeMapOpenExpl',        'e')
line 120: let g:NERDTreeMapOpenInTab       = get(g:, 'NERDTreeMapOpenInTab',       't')
line 121: let g:NERDTreeMapOpenInTabSilent = get(g:, 'NERDTreeMapOpenInTabSilent', 'T')
line 122: let g:NERDTreeMapOpenRecursively = get(g:, 'NERDTreeMapOpenRecursively', 'O')
line 123: let g:NERDTreeMapOpenSplit       = get(g:, 'NERDTreeMapOpenSplit',       'i')
line 124: let g:NERDTreeMapOpenVSplit      = get(g:, 'NERDTreeMapOpenVSplit',      's')
line 125: let g:NERDTreeMapPreview         = get(g:, 'NERDTreeMapPreview',         'g'.NERDTreeMapActivateNode)
line 126: let g:NERDTreeMapPreviewSplit    = get(g:, 'NERDTreeMapPreviewSplit',    'g'.NERDTreeMapOpenSplit)
line 127: let g:NERDTreeMapPreviewVSplit   = get(g:, 'NERDTreeMapPreviewVSplit',   'g'.NERDTreeMapOpenVSplit)
line 128: let g:NERDTreeMapQuit            = get(g:, 'NERDTreeMapQuit',            'q')
line 129: let g:NERDTreeMapRefresh         = get(g:, 'NERDTreeMapRefresh',         'r')
line 130: let g:NERDTreeMapRefreshRoot     = get(g:, 'NERDTreeMapRefreshRoot',     'R')
line 131: let g:NERDTreeMapToggleBookmarks = get(g:, 'NERDTreeMapToggleBookmarks', 'B')
line 132: let g:NERDTreeMapToggleFiles     = get(g:, 'NERDTreeMapToggleFiles',     'F')
line 133: let g:NERDTreeMapToggleFilters   = get(g:, 'NERDTreeMapToggleFilters',   'f')
line 134: let g:NERDTreeMapToggleHidden    = get(g:, 'NERDTreeMapToggleHidden',    'I')
line 135: let g:NERDTreeMapToggleFileLines = get(g:, 'NERDTreeMapToggleFileLines', 'FL')
line 136: let g:NERDTreeMapToggleZoom      = get(g:, 'NERDTreeMapToggleZoom',      'A')
line 137: let g:NERDTreeMapUpdir           = get(g:, 'NERDTreeMapUpdir',           'u')
line 138: let g:NERDTreeMapUpdirKeepOpen   = get(g:, 'NERDTreeMapUpdirKeepOpen',   'U')
line 139: let g:NERDTreeMapCWD             = get(g:, 'NERDTreeMapCWD',             'CD')
line 140: let g:NERDTreeMenuDown           = get(g:, 'NERDTreeMenuDown',           'j')
line 141: let g:NERDTreeMenuUp             = get(g:, 'NERDTreeMenuUp',             'k')
line 142: 
line 143: "SECTION: Load class files{{{2
line 144: call nerdtree#loadClassFiles()
calling nerdtree#loadClassFiles()

line 1:     runtime lib/nerdtree/path.vim
Searching for "lib/nerdtree/path.vim" in "/home/Dante/.vim,/home/Dante/.vim/plugged/onedark.vim,/home/Dante/.vim/plugged/onehalf/vim,/home/Dante/.vim/plugged/gruvbox,/home/Dante/.vim/plugged/lightline.vim,/home/Dante/.vim/plugged/vim-tmux-navigator,/home/Dante/.vim/plugged/vimtex,/home/Dante/.vim/plugged/nerdtree,/home/Dante/.vim/plugged/fzf,/home/Dante/.vim/plugged/fzf.vim,/home/Dante/.vim/plugged/vim-wayland-clipboard,/home/Dante/.vim/plugged/coc.nvim,/home/Dante/.vim/plugged/vim-obsession,/usr/share/vim/vimfiles,/usr/share/vim/vim91,/usr/share/vim/vimfiles/after,/home/Dante/.vim/plugged/vimtex/after,/home/Dante/.vim/after"
Searching for "/home/Dante/.vim/lib/nerdtree/path.vim"
Searching for "/home/Dante/.vim/plugged/onedark.vim/lib/nerdtree/path.vim"
Searching for "/home/Dante/.vim/plugged/onehalf/vim/lib/nerdtree/path.vim"
Searching for "/home/Dante/.vim/plugged/gruvbox/lib/nerdtree/path.vim"
Searching for "/home/Dante/.vim/plugged/lightline.vim/lib/nerdtree/path.vim"
Searching for "/home/Dante/.vim/plugged/vim-tmux-navigator/lib/nerdtree/path.vim"
Searching for "/home/Dante/.vim/plugged/vimtex/lib/nerdtree/path.vim"
Searching for "/home/Dante/.vim/plugged/nerdtree/lib/nerdtree/path.vim"
chdir(/home/Dante/.vim/plugged/nerdtree/lib/nerdtree)
fchdir() to previous dir
line 1: sourcing "/home/Dante/.vim/plugged/nerdtree/lib/nerdtree/path.vim"
line 1: " ============================================================================
line 2: " CLASS: Path
line 3: "
line 4: " The Path class provides an abstracted representation of a file system
line 5: " pathname.  Various operations on pathnames are provided and a number of
line 6: " representations of a given path name can be accessed here.
line 7: " ============================================================================
line 8: 
line 9: 
line 10: let s:Path = {}
line 11: let g:NERDTreePath = s:Path
line 12: 
line 13: " FUNCTION: Path.AbsolutePathFor(pathStr) {{{1
line 14: function! s:Path.AbsolutePathFor(pathStr)
line 37: 
line 38: " FUNCTION: Path.bookmarkNames() {{{1
line 39: function! s:Path.bookmarkNames()
line 45: 
line 46: " FUNCTION: Path.cacheDisplayString() {{{1
line 47: function! s:Path.cacheDisplayString() abort
line 91: 
line 92: " FUNCTION: Path.addDelimiter() {{{1
line 93: function! s:Path.addDelimiter(line)
line 100: 
line 101: " FUNCTION: Path.changeToDir() {{{1
line 102: function! s:Path.changeToDir()
line 120: 
line 121: " FUNCTION: Path.Create(fullpath) {{{1
line 122: "
line 123: " Factory method.
line 124: "
line 125: " Creates a path object with the given path. The path is also created on the
line 126: " filesystem. If the path already exists, a NERDTree.Path.Exists exception is
line 127: " thrown. If any other errors occur, a NERDTree.Path exception is thrown.
line 128: "
line 129: " Args:
line 130: " fullpath: the full filesystem path to the file/dir to create
line 131: function! s:Path.Create(fullpath)
line 157: 
line 158: " FUNCTION: Path.copy(dest) {{{1
line 159: "
line 160: " Copies the file/dir represented by this Path to the given location
line 161: "
line 162: " Args:
line 163: " dest: the location to copy this dir/file to
line 164: function! s:Path.copy(dest)
line 183: 
line 184: " FUNCTION: Path.CopyingSupported() {{{1
line 185: "
line 186: " returns 1 if copying is supported for this OS
line 187: function! s:Path.CopyingSupported()
line 190: 
line 191: " FUNCTION: Path.copyingWillOverwrite(dest) {{{1
line 192: "
line 193: " returns 1 if copy this path to the given location will cause files to
line 194: " overwritten
line 195: "
line 196: " Args:
line 197: " dest: the location this path will be copied to
line 198: function! s:Path.copyingWillOverwrite(dest)
line 210: 
line 211: " FUNCTION: Path.createParentDirectories(path) {{{1
line 212: "
line 213: " create parent directories for this path if needed
line 214: " without throwing any errors if those directories already exist
line 215: "
line 216: " Args:
line 217: " path: full path of the node whose parent directories may need to be created
line 218: function! s:Path.createParentDirectories(path)
line 224: 
line 225: " FUNCTION: Path.delete() {{{1
line 226: "
line 227: " Deletes the file or directory represented by this path.
line 228: "
line 229: " Throws NERDTree.Path.Deletion exceptions
line 230: function! s:Path.delete()
line 258: 
line 259: " FUNCTION: Path.displayString() {{{1
line 260: "
line 261: " Returns a string that specifies how the path should be represented as a
line 262: " string
line 263: function! s:Path.displayString()
line 270: 
line 271: " FUNCTION: Path.edit() {{{1
line 272: function! s:Path.edit()
line 278: 
line 279: " FUNCTION: Path.extractDriveLetter(fullpath) {{{1
line 280: "
line 281: " If running windows, cache the drive letter for this path
line 282: function! s:Path.extractDriveLetter(fullpath)
line 296: 
line 297: " FUNCTION: Path.exists() {{{1
line 298: " return 1 if this path points to a location that is readable or is a directory
line 299: function! s:Path.exists()
line 303: 
line 304: " FUNCTION: Path._escChars() {{{1
line 305: function! s:Path._escChars()
line 312: 
line 313: " FUNCTION: Path.getDir() {{{1
line 314: "
line 315: " Returns this path if it is a directory, else this paths parent.
line 316: "
line 317: " Return:
line 318: " a Path object
line 319: function! s:Path.getDir()
line 326: 
line 327: " FUNCTION: Path.getParent() {{{1
line 328: "
line 329: " Returns a new path object for this paths parent
line 330: "
line 331: " Return:
line 332: " a new Path object
line 333: function! s:Path.getParent()
line 342: 
line 343: " FUNCTION: Path.getLastPathComponent(dirSlash) {{{1
line 344: "
line 345: " Gets the last part of this path.
line 346: "
line 347: " Args:
line 348: " dirSlash: if 1 then a trailing slash will be added to the returned value for
line 349: " directory nodes.
line 350: function! s:Path.getLastPathComponent(dirSlash)
line 360: 
line 361: " FUNCTION: Path.getSortOrderIndex() {{{1
line 362: " returns the index of the pattern in g:NERDTreeSortOrder that this path matches
line 363: function! s:Path.getSortOrderIndex()
line 375: 
line 376: " FUNCTION: Path._splitChunks(path) {{{1
line 377: " returns a list of path chunks
line 378: function! s:Path._splitChunks(path)
line 390: 
line 391: " FUNCTION: Path.getSortKey() {{{1
line 392: " returns a key used in compare function for sorting
line 393: function! s:Path.getSortKey()
line 428: 
line 429: " FUNCTION: Path.isHiddenUnder(path) {{{1
line 430: function! s:Path.isHiddenUnder(path)
line 448: 
line 449: " FUNCTION: Path.isUnixHiddenFile() {{{1
line 450: " check for unix hidden files
line 451: function! s:Path.isUnixHiddenFile()
line 454: 
line 455: " FUNCTION: Path.isUnixHiddenPath() {{{1
line 456: " check for unix path with hidden components
line 457: function! s:Path.isUnixHiddenPath()
line 469: 
line 470: " FUNCTION: Path.ignore(nerdtree) {{{1
line 471: " returns true if this path should be ignored
line 472: function! s:Path.ignore(nerdtree)
line 500: 
line 501: " FUNCTION: Path._ignorePatternMatches(pattern) {{{1
line 502: " returns true if this path matches the given ignore pattern
line 503: function! s:Path._ignorePatternMatches(pattern)
line 522: 
line 523: " FUNCTION: Path.isAncestor(path) {{{1
line 524: " return 1 if this path is somewhere above the given path in the filesystem.
line 525: "
line 526: " a:path should be a dir
line 527: function! s:Path.isAncestor(child)
line 530: 
line 531: " FUNCTION: Path.isUnder(path) {{{1
line 532: " return 1 if this path is somewhere under the given path in the filesystem.
line 533: function! s:Path.isUnder(parent)
line 558: 
line 559: " FUNCTION: Path.JoinPathStrings(...) {{{1
line 560: function! s:Path.JoinPathStrings(...)
line 567: 
line 568: " FUNCTION: Path.equals() {{{1
line 569: "
line 570: " Determines whether 2 path objects are "equal".
line 571: " They are equal if the paths they represent are the same
line 572: "
line 573: " Args:
line 574: " path: the other path obj to compare this with
line 575: function! s:Path.equals(path)
line 578: 
line 579: " FUNCTION: Path.New(pathStr) {{{1
line 580: function! s:Path.New(pathStr)
line 590: 
line 591: " FUNCTION: Path.Resolve() {{{1
line 592: " Invoke the vim resolve() function and return the result
line 593: " This is necessary because in some versions of vim resolve() removes trailing
line 594: " slashes while in other versions it doesn't.  This always removes the trailing
line 595: " slash
line 596: function! s:Path.Resolve(path)
line 600: 
line 601: " FUNCTION: Path.readInfoFromDisk(fullpath) {{{1
line 602: "
line 603: "
line 604: " Throws NERDTree.Path.InvalidArguments exception.
line 605: function! s:Path.readInfoFromDisk(fullpath)
line 654: 
line 655: " FUNCTION: Path.refresh(nerdtree) {{{1
line 656: function! s:Path.refresh(nerdtree)
line 661: 
line 662: " FUNCTION: Path.refreshFlags(nerdtree) {{{1
line 663: function! s:Path.refreshFlags(nerdtree)
line 667: 
line 668: " FUNCTION: Path.rename() {{{1
line 669: "
line 670: " Renames this node on the filesystem
line 671: function! s:Path.rename(newPath)
line 690: 
line 691: " FUNCTION: Path.str() {{{1
line 692: " Return a string representation of this Path object.
line 693: "
line 694: " Args:
line 695: " This function takes a single dictionary (optional) with keys and values that
line 696: " specify how the returned pathname should be formatted.
line 697: "
line 698: " The dictionary may have the following keys:
line 699: "  'format'
line 700: "  'escape'
line 701: "  'truncateTo'
line 702: "
line 703: " The 'format' key may have a value of:
line 704: "  'Cd' - a string to be used with ":cd" and similar commands
line 705: "  'Edit' - a string to be used with ":edit" and similar commands
line 706: "  'UI' - a string to be displayed in the NERDTree user interface
line 707: "
line 708: " The 'escape' key, if specified, will cause the output to be escaped with
line 709: " Vim's internal "shellescape()" function.
line 710: "
line 711: " The 'truncateTo' key shortens the length of the path to that given by the
line 712: " value associated with 'truncateTo'. A '<' is prepended.
line 713: function! s:Path.str(...)
line 748: 
line 749: " FUNCTION: Path._strForUI() {{{1
line 750: function! s:Path._strForUI()
line 757: 
line 758: " FUNCTION: Path._strForCd() {{{1
line 759: " Return a string representation of this Path that is suitable for use as an
line 760: " argument to Vim's internal ":cd" command.
line 761: function! s:Path._strForCd()
line 764: 
line 765: " FUNCTION: Path._strForEdit() {{{1
line 766: " Return a string representation of this Path that is suitable for use as an
line 767: " argument to Vim's internal ":edit" command.
line 768: function! s:Path._strForEdit()
line 787: 
line 788: " FUNCTION: Path._strForGlob() {{{1
line 789: function! s:Path._strForGlob()
line 804: 
line 805: " FUNCTION: Path._str() {{{1
line 806: " Return the absolute pathname associated with this Path object.  The pathname
line 807: " returned is appropriate for the underlying file system.
line 808: function! s:Path._str()
line 818: 
line 819: " FUNCTION: Path.strTrunk() {{{1
line 820: " Gets the path without the last segment on the end.
line 821: function! s:Path.strTrunk()
line 824: 
line 825: " FUNCTION: Path.tabnr() {{{1
line 826: " return the number of the first tab that is displaying this file
line 827: "
line 828: " return 0 if no tab was found
line 829: function! s:Path.tabnr()
line 840: 
line 841: " FUNCTION: Path.WinToUnixPath(pathstr){{{1
line 842: " Takes in a windows path and returns the unix equiv
line 843: "
line 844: " A class level method
line 845: "
line 846: " Args:
line 847: " pathstr: the windows path to convert
line 848: function! s:Path.WinToUnixPath(pathstr)
line 866: 
line 867: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/Dante/.vim/plugged/nerdtree/lib/nerdtree/path.vim
continuing in nerdtree#loadClassFiles
line 2:     runtime lib/nerdtree/menu_controller.vim
Searching for "lib/nerdtree/menu_controller.vim" in "/home/Dante/.vim,/home/Dante/.vim/plugged/onedark.vim,/home/Dante/.vim/plugged/onehalf/vim,/home/Dante/.vim/plugged/gruvbox,/home/Dante/.vim/plugged/lightline.vim,/home/Dante/.vim/plugged/vim-tmux-navigator,/home/Dante/.vim/plugged/vimtex,/home/Dante/.vim/plugged/nerdtree,/home/Dante/.vim/plugged/fzf,/home/Dante/.vim/plugged/fzf.vim,/home/Dante/.vim/plugged/vim-wayland-clipboard,/home/Dante/.vim/plugged/coc.nvim,/home/Dante/.vim/plugged/vim-obsession,/usr/share/vim/vimfiles,/usr/share/vim/vim91,/usr/share/vim/vimfiles/after,/home/Dante/.vim/plugged/vimtex/after,/home/Dante/.vim/after"
Searching for "/home/Dante/.vim/lib/nerdtree/menu_controller.vim"
Searching for "/home/Dante/.vim/plugged/onedark.vim/lib/nerdtree/menu_controller.vim"
Searching for "/home/Dante/.vim/plugged/onehalf/vim/lib/nerdtree/menu_controller.vim"
Searching for "/home/Dante/.vim/plugged/gruvbox/lib/nerdtree/menu_controller.vim"
Searching for "/home/Dante/.vim/plugged/lightline.vim/lib/nerdtree/menu_controller.vim"
Searching for "/home/Dante/.vim/plugged/vim-tmux-navigator/lib/nerdtree/menu_controller.vim"
Searching for "/home/Dante/.vim/plugged/vimtex/lib/nerdtree/menu_controller.vim"
Searching for "/home/Dante/.vim/plugged/nerdtree/lib/nerdtree/menu_controller.vim"
chdir(/home/Dante/.vim/plugged/nerdtree/lib/nerdtree)
fchdir() to previous dir
line 2: sourcing "/home/Dante/.vim/plugged/nerdtree/lib/nerdtree/menu_controller.vim"
line 1: "CLASS: MenuController
line 2: "============================================================
line 3: let s:MenuController = {}
line 4: let g:NERDTreeMenuController = s:MenuController
line 5: 
line 6: "FUNCTION: MenuController.New(menuItems) {{{1
line 7: "create a new menu controller that operates on the given menu items
line 8: function! s:MenuController.New(menuItems)
line 17: 
line 18: " FUNCTION: s:MenuController.isMinimal() {{{1
line 19: function! s:MenuController.isMinimal()
line 22: 
line 23: " FUNCTION: MenuController.showMenu() {{{1
line 24: " Enter the main loop of the NERDTree menu, prompting the user to select
line 25: " a menu item.
line 26: function! s:MenuController.showMenu()
line 58: 
line 59: "FUNCTION: MenuController._echoPrompt() {{{1
line 60: function! s:MenuController._echoPrompt()
line 84: 
line 85: "FUNCTION: MenuController._current(key) {{{1
line 86: "get the MenuItem that is currently selected
line 87: function! s:MenuController._current()
line 90: 
line 91: "FUNCTION: MenuController._handleKeypress(key) {{{1
line 92: "change the selection (if appropriate) and return 1 if the user has made
line 93: "their choice, 0 otherwise
line 94: function! s:MenuController._handleKeypress(key)
line 116: 
line 117: "FUNCTION: MenuController._allIndexesFor(shortcut) {{{1
line 118: "get indexes to all menu items with the given shortcut
line 119: function! s:MenuController._allIndexesFor(shortcut)
line 130: 
line 131: "FUNCTION: MenuController._nextIndexFor(shortcut) {{{1
line 132: "get the index to the next menu item with the given shortcut, starts from the
line 133: "current cursor location and wraps around to the top again if need be
line 134: function! s:MenuController._nextIndexFor(shortcut)
line 149: 
line 150: "FUNCTION: MenuController._setCmdheight() {{{1
line 151: "sets &cmdheight to whatever is needed to display the menu
line 152: function! s:MenuController._setCmdheight()
line 159: 
line 160: "FUNCTION: MenuController._saveOptions() {{{1
line 161: "set any vim options that are required to make the menu work (saving their old
line 162: "values)
line 163: function! s:MenuController._saveOptions()
line 169: 
line 170: "FUNCTION: MenuController._restoreOptions() {{{1
line 171: "restore the options we saved in _saveOptions()
line 172: function! s:MenuController._restoreOptions()
line 176: 
line 177: "FUNCTION: MenuController._cursorDown() {{{1
line 178: "move the cursor to the next menu item, skipping separators
line 179: function! s:MenuController._cursorDown()
line 193: 
line 194: "FUNCTION: MenuController._cursorUp() {{{1
line 195: "move the cursor to the previous menu item, skipping separators
line 196: function! s:MenuController._cursorUp()
line 210: 
line 211: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/Dante/.vim/plugged/nerdtree/lib/nerdtree/menu_controller.vim
continuing in nerdtree#loadClassFiles
line 3:     runtime lib/nerdtree/menu_item.vim
Searching for "lib/nerdtree/menu_item.vim" in "/home/Dante/.vim,/home/Dante/.vim/plugged/onedark.vim,/home/Dante/.vim/plugged/onehalf/vim,/home/Dante/.vim/plugged/gruvbox,/home/Dante/.vim/plugged/lightline.vim,/home/Dante/.vim/plugged/vim-tmux-navigator,/home/Dante/.vim/plugged/vimtex,/home/Dante/.vim/plugged/nerdtree,/home/Dante/.vim/plugged/fzf,/home/Dante/.vim/plugged/fzf.vim,/home/Dante/.vim/plugged/vim-wayland-clipboard,/home/Dante/.vim/plugged/coc.nvim,/home/Dante/.vim/plugged/vim-obsession,/usr/share/vim/vimfiles,/usr/share/vim/vim91,/usr/share/vim/vimfiles/after,/home/Dante/.vim/plugged/vimtex/after,/home/Dante/.vim/after"
Searching for "/home/Dante/.vim/lib/nerdtree/menu_item.vim"
Searching for "/home/Dante/.vim/plugged/onedark.vim/lib/nerdtree/menu_item.vim"
Searching for "/home/Dante/.vim/plugged/onehalf/vim/lib/nerdtree/menu_item.vim"
Searching for "/home/Dante/.vim/plugged/gruvbox/lib/nerdtree/menu_item.vim"
Searching for "/home/Dante/.vim/plugged/lightline.vim/lib/nerdtree/menu_item.vim"
Searching for "/home/Dante/.vim/plugged/vim-tmux-navigator/lib/nerdtree/menu_item.vim"
Searching for "/home/Dante/.vim/plugged/vimtex/lib/nerdtree/menu_item.vim"
Searching for "/home/Dante/.vim/plugged/nerdtree/lib/nerdtree/menu_item.vim"
chdir(/home/Dante/.vim/plugged/nerdtree/lib/nerdtree)
fchdir() to previous dir
line 3: sourcing "/home/Dante/.vim/plugged/nerdtree/lib/nerdtree/menu_item.vim"
line 1: "CLASS: MenuItem
line 2: "============================================================
line 3: let s:MenuItem = {}
line 4: let g:NERDTreeMenuItem = s:MenuItem
line 5: 
line 6: "FUNCTION: MenuItem.All() {{{1
line 7: "get all top level menu items
line 8: function! s:MenuItem.All()
line 14: 
line 15: "FUNCTION: MenuItem.AllEnabled() {{{1
line 16: "get all top level menu items that are currently enabled
line 17: function! s:MenuItem.AllEnabled()
line 26: 
line 27: "FUNCTION: MenuItem.Create(options) {{{1
line 28: "make a new menu item and add it to the global list
line 29: function! s:MenuItem.Create(options)
line 54: 
line 55: "FUNCTION: MenuItem.CreateSeparator(options) {{{1
line 56: "make a new separator menu item and add it to the global list
line 57: function! s:MenuItem.CreateSeparator(options)
line 65: 
line 66: "FUNCTION: MenuItem.CreateSubmenu(options) {{{1
line 67: "make a new submenu and add it to global list
line 68: function! s:MenuItem.CreateSubmenu(options)
line 74: 
line 75: "FUNCTION: MenuItem.enabled() {{{1
line 76: "return 1 if this menu item should be displayed
line 77: "
line 78: "delegates off to the isActiveCallback, and defaults to 1 if no callback was
line 79: "specified
line 80: function! s:MenuItem.enabled()
line 86: 
line 87: "FUNCTION: MenuItem.execute() {{{1
line 88: "perform the action behind this menu item, if this menuitem has children then
line 89: "display a new menu for them, otherwise deletegate off to the menuitem's
line 90: "callback
line 91: function! s:MenuItem.execute()
line 105: 
line 106: "FUNCTION: MenuItem.isSeparator() {{{1
line 107: "return 1 if this menuitem is a separator
line 108: function! s:MenuItem.isSeparator()
line 111: 
line 112: "FUNCTION: MenuItem.isSubmenu() {{{1
line 113: "return 1 if this menuitem is a submenu
line 114: function! s:MenuItem.isSubmenu()
line 117: 
line 118: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/Dante/.vim/plugged/nerdtree/lib/nerdtree/menu_item.vim
continuing in nerdtree#loadClassFiles
line 4:     runtime lib/nerdtree/key_map.vim
Searching for "lib/nerdtree/key_map.vim" in "/home/Dante/.vim,/home/Dante/.vim/plugged/onedark.vim,/home/Dante/.vim/plugged/onehalf/vim,/home/Dante/.vim/plugged/gruvbox,/home/Dante/.vim/plugged/lightline.vim,/home/Dante/.vim/plugged/vim-tmux-navigator,/home/Dante/.vim/plugged/vimtex,/home/Dante/.vim/plugged/nerdtree,/home/Dante/.vim/plugged/fzf,/home/Dante/.vim/plugged/fzf.vim,/home/Dante/.vim/plugged/vim-wayland-clipboard,/home/Dante/.vim/plugged/coc.nvim,/home/Dante/.vim/plugged/vim-obsession,/usr/share/vim/vimfiles,/usr/share/vim/vim91,/usr/share/vim/vimfiles/after,/home/Dante/.vim/plugged/vimtex/after,/home/Dante/.vim/after"
Searching for "/home/Dante/.vim/lib/nerdtree/key_map.vim"
Searching for "/home/Dante/.vim/plugged/onedark.vim/lib/nerdtree/key_map.vim"
Searching for "/home/Dante/.vim/plugged/onehalf/vim/lib/nerdtree/key_map.vim"
Searching for "/home/Dante/.vim/plugged/gruvbox/lib/nerdtree/key_map.vim"
Searching for "/home/Dante/.vim/plugged/lightline.vim/lib/nerdtree/key_map.vim"
Searching for "/home/Dante/.vim/plugged/vim-tmux-navigator/lib/nerdtree/key_map.vim"
Searching for "/home/Dante/.vim/plugged/vimtex/lib/nerdtree/key_map.vim"
Searching for "/home/Dante/.vim/plugged/nerdtree/lib/nerdtree/key_map.vim"
chdir(/home/Dante/.vim/plugged/nerdtree/lib/nerdtree)
fchdir() to previous dir
line 4: sourcing "/home/Dante/.vim/plugged/nerdtree/lib/nerdtree/key_map.vim"
line 1: "CLASS: KeyMap
line 2: "============================================================
line 3: let s:KeyMap = {}
line 4: let g:NERDTreeKeyMap = s:KeyMap
line 5: let s:keyMaps = {}
line 6: 
line 7: "FUNCTION: KeyMap.All() {{{1
line 8: function! s:KeyMap.All()
line 14: 
line 15: "FUNCTION: KeyMap.Compare(keyMap1, keyMap2) {{{1
line 16: function! s:KeyMap.Compare(keyMap1, keyMap2)
line 28: 
line 29: "FUNCTION: KeyMap.FindFor(key, scope) {{{1
line 30: function! s:KeyMap.FindFor(key, scope)
line 33: 
line 34: "FUNCTION: KeyMap.BindAll() {{{1
line 35: function! s:KeyMap.BindAll()
line 40: 
line 41: "FUNCTION: KeyMap.bind() {{{1
line 42: function! s:KeyMap.bind()
line 60: 
line 61: "FUNCTION: KeyMap.Remove(key, scope) {{{1
line 62: function! s:KeyMap.Remove(key, scope)
line 65: 
line 66: "FUNCTION: KeyMap.invoke() {{{1
line 67: "Call the KeyMaps callback function
line 68: function! s:KeyMap.invoke(...)
line 76: 
line 77: "FUNCTION: KeyMap.Invoke() {{{1
line 78: "Find a keymapping for a:key and the current scope invoke it.
line 79: "
line 80: "Scope is determined as follows:
line 81: "   * if the cursor is on a dir node then DirNode
line 82: "   * if the cursor is on a file node then FileNode
line 83: "   * if the cursor is on a bookmark then Bookmark
line 84: "
line 85: "If a keymap has the scope of 'all' then it will be called if no other keymap
line 86: "is found for a:key and the scope.
line 87: function! s:KeyMap.Invoke(key)
line 140: 
line 141: "FUNCTION: KeyMap.Create(options) {{{1
line 142: function! s:KeyMap.Create(options)
line 158: 
line 159: "FUNCTION: KeyMap.Add(keymap) {{{1
line 160: function! s:KeyMap.Add(keymap)
line 163: 
line 164: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/Dante/.vim/plugged/nerdtree/lib/nerdtree/key_map.vim
continuing in nerdtree#loadClassFiles
line 5:     runtime lib/nerdtree/bookmark.vim
Searching for "lib/nerdtree/bookmark.vim" in "/home/Dante/.vim,/home/Dante/.vim/plugged/onedark.vim,/home/Dante/.vim/plugged/onehalf/vim,/home/Dante/.vim/plugged/gruvbox,/home/Dante/.vim/plugged/lightline.vim,/home/Dante/.vim/plugged/vim-tmux-navigator,/home/Dante/.vim/plugged/vimtex,/home/Dante/.vim/plugged/nerdtree,/home/Dante/.vim/plugged/fzf,/home/Dante/.vim/plugged/fzf.vim,/home/Dante/.vim/plugged/vim-wayland-clipboard,/home/Dante/.vim/plugged/coc.nvim,/home/Dante/.vim/plugged/vim-obsession,/usr/share/vim/vimfiles,/usr/share/vim/vim91,/usr/share/vim/vimfiles/after,/home/Dante/.vim/plugged/vimtex/after,/home/Dante/.vim/after"
Searching for "/home/Dante/.vim/lib/nerdtree/bookmark.vim"
Searching for "/home/Dante/.vim/plugged/onedark.vim/lib/nerdtree/bookmark.vim"
Searching for "/home/Dante/.vim/plugged/onehalf/vim/lib/nerdtree/bookmark.vim"
Searching for "/home/Dante/.vim/plugged/gruvbox/lib/nerdtree/bookmark.vim"
Searching for "/home/Dante/.vim/plugged/lightline.vim/lib/nerdtree/bookmark.vim"
Searching for "/home/Dante/.vim/plugged/vim-tmux-navigator/lib/nerdtree/bookmark.vim"
Searching for "/home/Dante/.vim/plugged/vimtex/lib/nerdtree/bookmark.vim"
Searching for "/home/Dante/.vim/plugged/nerdtree/lib/nerdtree/bookmark.vim"
chdir(/home/Dante/.vim/plugged/nerdtree/lib/nerdtree)
fchdir() to previous dir
line 5: sourcing "/home/Dante/.vim/plugged/nerdtree/lib/nerdtree/bookmark.vim"
line 1: " ============================================================================
line 2: " CLASS: Bookmark
line 3: "
line 4: " The Bookmark class serves two purposes:
line 5: "   (1) It is the top-level prototype for new, concrete Bookmark objects.
line 6: "   (2) It provides an interface for client code to query and manipulate the
line 7: "       global list of Bookmark objects within the current Vim session.
line 8: " ============================================================================
line 9: 
line 10: 
line 11: let s:Bookmark = {}
line 12: let g:NERDTreeBookmark = s:Bookmark
line 13: 
line 14: " FUNCTION: Bookmark.activate(nerdtree) {{{1
line 15: function! s:Bookmark.activate(nerdtree, ...)
line 18: 
line 19: " FUNCTION: Bookmark.AddBookmark(name, path) {{{1
line 20: " Class method to add a new bookmark to the list, if a previous bookmark exists
line 21: " with the same name, just update the path for that bookmark
line 22: function! s:Bookmark.AddBookmark(name, path)
line 31: 
line 32: " FUNCTION: Bookmark.Bookmarks() {{{1
line 33: " Class method to get all bookmarks. Lazily initializes the bookmarks global
line 34: " variable
line 35: function! s:Bookmark.Bookmarks()
line 41: 
line 42: " FUNCTION: Bookmark.BookmarkExistsFor(name) {{{1
line 43: " class method that returns 1 if a bookmark with the given name is found, 0
line 44: " otherwise
line 45: function! s:Bookmark.BookmarkExistsFor(name)
line 53: 
line 54: " FUNCTION: Bookmark.BookmarkFor(name) {{{1
line 55: " Class method that returns the Bookmark object having the specified name.
line 56: " Throws NERDTree.BookmarkNotFoundError if no Bookmark is found.
line 57: function! s:Bookmark.BookmarkFor(name)
line 70: 
line 71: " FUNCTION: Bookmark.BookmarkNames() {{{1
line 72: " Class method to return an array of all bookmark names
line 73: function! s:Bookmark.BookmarkNames()
line 80: 
line 81: " FUNCTION: Bookmark.CacheBookmarks(silent) {{{1
line 82: " Class method to read all bookmarks from the bookmarks file initialize
line 83: " bookmark objects for each one.
line 84: "
line 85: " Args:
line 86: " silent - dont echo an error msg if invalid bookmarks are found
line 87: function! s:Bookmark.CacheBookmarks(silent)
line 119: 
line 120: " FUNCTION: Bookmark.CompareBookmarksByName(firstBookmark, secondBookmark) {{{1
line 121: " Class method that indicates the relative position of two bookmarks when
line 122: " placed in alphabetical order by name. Case-sensitivity is determined by an
line 123: " option. Supports the s:Bookmark.SortBookmarksList() method.
line 124: function! s:Bookmark.CompareBookmarksByName(firstBookmark, secondBookmark)
line 141: 
line 142: " FUNCTION: Bookmark.ClearAll() {{{1
line 143: " Class method to delete all bookmarks.
line 144: function! s:Bookmark.ClearAll()
line 150: 
line 151: " FUNCTION: Bookmark.delete() {{{1
line 152: " Delete this bookmark. If the node for this bookmark is under the current
line 153: " root, then recache bookmarks for its Path object
line 154: function! s:Bookmark.delete()
line 158: 
line 159: " FUNCTION: s:Edit() {{{1
line 160: " opens the NERDTreeBookmarks file for manual editing
line 161: function! s:Bookmark.Edit()
line 165: 
line 166: " FUNCTION: Bookmark.getNode(nerdtree, searchFromAbsoluteRoot) {{{1
line 167: " Returns the tree node object associated with this Bookmark.
line 168: " Throws NERDTree.BookmarkedNodeNotFoundError if the node is not found.
line 169: "
line 170: " Args:
line 171: " searchFromAbsoluteRoot: boolean flag, search from the highest cached node
line 172: "   if true and from the current tree root if false
line 173: function! s:Bookmark.getNode(nerdtree, searchFromAbsoluteRoot)
line 185: 
line 186: " FUNCTION: Bookmark.GetNodeForName(name, searchFromAbsoluteRoot, nerdtree) {{{1
line 187: " Class method that returns the tree node object for the Bookmark with the
line 188: " given name. Throws NERDTree.BookmarkNotFoundError if a Bookmark with the
line 189: " name does not exist. Throws NERDTree.BookmarkedNodeNotFoundError if a
line 190: " tree node for the named Bookmark could not be found.
line 191: function! s:Bookmark.GetNodeForName(name, searchFromAbsoluteRoot, nerdtree)
line 195: 
line 196: " FUNCTION: Bookmark.GetSelected() {{{1
line 197: " returns the Bookmark the cursor is over, or {}
line 198: function! s:Bookmark.GetSelected()
line 210: 
line 211: " FUNCTION: Bookmark.InvalidBookmarks() {{{1
line 212: " Class method to get all invalid bookmark strings read from the bookmarks
line 213: " file
line 214: function! s:Bookmark.InvalidBookmarks()
line 220: 
line 221: " FUNCTION: Bookmark.mustExist() {{{1
line 222: function! s:Bookmark.mustExist()
line 229: 
line 230: " FUNCTION: Bookmark.New(name, path) {{{1
line 231: " Create a new bookmark object with the given name and path object
line 232: function! s:Bookmark.New(name, path)
line 242: 
line 243: " FUNCTION: Bookmark.open(nerdtree, [options]) {{{1
line 244: "Args:
line 245: "
line 246: "nerdtree: the tree to load open the bookmark in
line 247: "
line 248: "A dictionary containing the following keys (all optional):
line 249: "  'where': Specifies whether the node should be opened in new split/tab or in
line 250: "           the previous window. Can be either 'v' (vertical split), 'h'
line 251: "           (horizontal split), 't' (new tab) or 'p' (previous window).
line 252: "  'reuse': if a window is displaying the file then jump the cursor there
line 253: "  'keepopen': dont close the tree window
line 254: "  'stay': open the file, but keep the cursor in the tree win
line 255: "
line 256: function! s:Bookmark.open(nerdtree, ...)
line 270: 
line 271: " FUNCTION: Bookmark.openInNewTab(options) {{{1
line 272: " Create a new bookmark object with the given name and path object
line 273: function! s:Bookmark.openInNewTab(options)
line 277: 
line 278: " FUNCTION: Bookmark.setPath(path) {{{1
line 279: " makes this bookmark point to the given path
line 280: function! s:Bookmark.setPath(path)
line 283: 
line 284: " FUNCTION: Bookmark.SortBookmarksList() {{{1
line 285: " Class method that sorts the global list of bookmarks alphabetically by name.
line 286: " Note that case-sensitivity is determined by a user option.
line 287: function! s:Bookmark.SortBookmarksList()
line 290: 
line 291: " FUNCTION: Bookmark.str() {{{1
line 292: " Get the string that should be rendered in the view for this bookmark
line 293: function! s:Bookmark.str()
line 308: 
line 309: " FUNCTION: Bookmark.toRoot(nerdtree) {{{1
line 310: " Set the root of the given NERDTree to the node for this Bookmark. If a node
line 311: " for this Bookmark does not exist, a new one is initialized.
line 312: function! s:Bookmark.toRoot(nerdtree)
line 323: 
line 324: " FUNCTION: Bookmark.ToRoot(name, nerdtree) {{{1
line 325: " Class method that makes the Bookmark with the given name the root of
line 326: " specified NERDTree.
line 327: function! s:Bookmark.ToRoot(name, nerdtree)
line 331: 
line 332: " FUNCTION: Bookmark.validate() {{{1
line 333: function! s:Bookmark.validate()
line 342: 
line 343: " FUNCTION: Bookmark.Write() {{{1
line 344: " Class method to write all bookmarks to the bookmarks file
line 345: function! s:Bookmark.Write()
line 364: 
line 365: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/Dante/.vim/plugged/nerdtree/lib/nerdtree/bookmark.vim
continuing in nerdtree#loadClassFiles
line 6:     runtime lib/nerdtree/tree_file_node.vim
Searching for "lib/nerdtree/tree_file_node.vim" in "/home/Dante/.vim,/home/Dante/.vim/plugged/onedark.vim,/home/Dante/.vim/plugged/onehalf/vim,/home/Dante/.vim/plugged/gruvbox,/home/Dante/.vim/plugged/lightline.vim,/home/Dante/.vim/plugged/vim-tmux-navigator,/home/Dante/.vim/plugged/vimtex,/home/Dante/.vim/plugged/nerdtree,/home/Dante/.vim/plugged/fzf,/home/Dante/.vim/plugged/fzf.vim,/home/Dante/.vim/plugged/vim-wayland-clipboard,/home/Dante/.vim/plugged/coc.nvim,/home/Dante/.vim/plugged/vim-obsession,/usr/share/vim/vimfiles,/usr/share/vim/vim91,/usr/share/vim/vimfiles/after,/home/Dante/.vim/plugged/vimtex/after,/home/Dante/.vim/after"
Searching for "/home/Dante/.vim/lib/nerdtree/tree_file_node.vim"
Searching for "/home/Dante/.vim/plugged/onedark.vim/lib/nerdtree/tree_file_node.vim"
Searching for "/home/Dante/.vim/plugged/onehalf/vim/lib/nerdtree/tree_file_node.vim"
Searching for "/home/Dante/.vim/plugged/gruvbox/lib/nerdtree/tree_file_node.vim"
Searching for "/home/Dante/.vim/plugged/lightline.vim/lib/nerdtree/tree_file_node.vim"
Searching for "/home/Dante/.vim/plugged/vim-tmux-navigator/lib/nerdtree/tree_file_node.vim"
Searching for "/home/Dante/.vim/plugged/vimtex/lib/nerdtree/tree_file_node.vim"
Searching for "/home/Dante/.vim/plugged/nerdtree/lib/nerdtree/tree_file_node.vim"
chdir(/home/Dante/.vim/plugged/nerdtree/lib/nerdtree)
fchdir() to previous dir
line 6: sourcing "/home/Dante/.vim/plugged/nerdtree/lib/nerdtree/tree_file_node.vim"
line 1: " ============================================================================
line 2: " CLASS: TreeFileNode
line 3: "
line 4: " This class is the parent of the TreeDirNode class and is the 'Component'
line 5: " part of the composite design pattern between the NERDTree node classes.
line 6: " ============================================================================
line 7: 
line 8: 
line 9: let s:TreeFileNode = {}
line 10: let g:NERDTreeFileNode = s:TreeFileNode
line 11: 
line 12: " FUNCTION: TreeFileNode.activate(...) {{{1
line 13: function! s:TreeFileNode.activate(...)
line 16: 
line 17: " FUNCTION: TreeFileNode.bookmark(name) {{{1
line 18: " bookmark this node with a:name
line 19: function! s:TreeFileNode.bookmark(name)
line 38: 
line 39: " FUNCTION: TreeFileNode.cacheParent() {{{1
line 40: " initializes self.parent if it isnt already
line 41: function! s:TreeFileNode.cacheParent()
line 50: 
line 51: " FUNCTION: TreeFileNode.clearBookmarks() {{{1
line 52: function! s:TreeFileNode.clearBookmarks()
line 60: 
line 61: " FUNCTION: TreeFileNode.copy(dest) {{{1
line 62: function! s:TreeFileNode.copy(dest)
line 73: 
line 74: " FUNCTION: TreeFileNode.delete {{{1
line 75: " Removes this node from the tree and calls the Delete method for its path obj
line 76: function! s:TreeFileNode.delete()
line 80: 
line 81: " FUNCTION: TreeFileNode.displayString() {{{1
line 82: "
line 83: " Returns a string that specifies how the node should be represented as a
line 84: " string
line 85: "
line 86: " Return:
line 87: " a string that can be used in the view to represent this node
line 88: function! s:TreeFileNode.displayString()
line 91: 
line 92: " FUNCTION: TreeFileNode.equals(treenode) {{{1
line 93: "
line 94: " Compares this treenode to the input treenode and returns 1 if they are the
line 95: " same node.
line 96: "
line 97: " Use this method instead of ==  because sometimes when the treenodes contain
line 98: " many children, vim seg faults when doing ==
line 99: "
line 100: " Args:
line 101: " treenode: the other treenode to compare to
line 102: function! s:TreeFileNode.equals(treenode)
line 105: 
line 106: " FUNCTION: TreeFileNode.findNode(path) {{{1
line 107: " Returns self if this node.path.Equals the given path.
line 108: " Returns {} if not equal.
line 109: "
line 110: " Args:
line 111: " path: the path object to compare against
line 112: function! s:TreeFileNode.findNode(path)
line 118: 
line 119: " FUNCTION: TreeFileNode.findSibling(direction) {{{1
line 120: " Find the next or previous sibling of this node.
line 121: "
line 122: " Args:
line 123: " direction: 0 for previous, 1 for next
line 124: "
line 125: " Return:
line 126: " The next/previous TreeFileNode object or an empty dictionary if not found.
line 127: function! s:TreeFileNode.findSibling(direction)
line 155: 
line 156: " FUNCTION: TreeFileNode.getNerdtree(){{{1
line 157: function! s:TreeFileNode.getNerdtree()
line 160: 
line 161: " FUNCTION: TreeFileNode.GetRootForTab(){{{1
line 162: " get the root node for this tab
line 163: function! s:TreeFileNode.GetRootForTab()
line 169: 
line 170: " FUNCTION: TreeFileNode.GetSelected() {{{1
line 171: " If the cursor is currently positioned on a tree node, return the node.
line 172: " Otherwise, return the empty dictionary.
line 173: function! s:TreeFileNode.GetSelected()
line 187: 
line 188: " FUNCTION: TreeFileNode.isVisible() {{{1
line 189: " returns 1 if this node should be visible according to the tree filters and
line 190: " hidden file filters (and their on/off status)
line 191: function! s:TreeFileNode.isVisible()
line 194: 
line 195: " FUNCTION: TreeFileNode.isRoot() {{{1
line 196: function! s:TreeFileNode.isRoot()
line 203: 
line 204: " FUNCTION: TreeFileNode.New(path, nerdtree) {{{1
line 205: " Returns a new TreeNode object with the given path and parent
line 206: "
line 207: " Args:
line 208: " path: file/dir that the node represents
line 209: " nerdtree: the tree the node belongs to
line 210: function! s:TreeFileNode.New(path, nerdtree)
line 221: 
line 222: " FUNCTION: TreeFileNode.open() {{{1
line 223: function! s:TreeFileNode.open(...)
line 228: 
line 229: " FUNCTION: TreeFileNode.openSplit() {{{1
line 230: " Open this node in a new window
line 231: function! s:TreeFileNode.openSplit()
line 235: 
line 236: " FUNCTION: TreeFileNode.openVSplit() {{{1
line 237: " Open this node in a new vertical window
line 238: function! s:TreeFileNode.openVSplit()
line 242: 
line 243: " FUNCTION: TreeFileNode.openInNewTab(options) {{{1
line 244: function! s:TreeFileNode.openInNewTab(options)
line 248: 
line 249: " FUNCTION: TreeFileNode.openExplorer()
line 250: function! s:TreeFileNode.openExplorer()
line 254: 
line 255: " FUNCTION: TreeFileNode.putCursorHere(isJump, recurseUpward){{{1
line 256: " Places the cursor on the line number this node is rendered on
line 257: "
line 258: " Args:
line 259: " isJump: 1 if this cursor movement should be counted as a jump by vim
line 260: " recurseUpward: try to put the cursor on the parent if the this node isnt
line 261: " visible
line 262: function! s:TreeFileNode.putCursorHere(isJump, recurseUpward)
line 281: 
line 282: " FUNCTION: TreeFileNode.refresh() {{{1
line 283: function! s:TreeFileNode.refresh()
line 286: 
line 287: " FUNCTION: TreeFileNode.refreshFlags() {{{1
line 288: function! s:TreeFileNode.refreshFlags()
line 291: 
line 292: " FUNCTION: TreeFileNode.rename() {{{1
line 293: " Calls the rename method for this nodes path obj
line 294: function! s:TreeFileNode.rename(newName)
line 307: 
line 308: " FUNCTION: TreeFileNode.renderToString {{{1
line 309: " returns a string representation for this tree to be rendered in the view
line 310: function! s:TreeFileNode.renderToString()
line 313: 
line 314: " Args:
line 315: " depth: the current depth in the tree for this call
line 316: " drawText: 1 if we should actually draw the line for this node (if 0 then the
line 317: " child nodes are rendered only)
line 318: " for each depth in the tree
line 319: function! s:TreeFileNode._renderToString(depth, drawText)
line 348: 
line 349: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/Dante/.vim/plugged/nerdtree/lib/nerdtree/tree_file_node.vim
continuing in nerdtree#loadClassFiles
line 7:     runtime lib/nerdtree/tree_dir_node.vim
Searching for "lib/nerdtree/tree_dir_node.vim" in "/home/Dante/.vim,/home/Dante/.vim/plugged/onedark.vim,/home/Dante/.vim/plugged/onehalf/vim,/home/Dante/.vim/plugged/gruvbox,/home/Dante/.vim/plugged/lightline.vim,/home/Dante/.vim/plugged/vim-tmux-navigator,/home/Dante/.vim/plugged/vimtex,/home/Dante/.vim/plugged/nerdtree,/home/Dante/.vim/plugged/fzf,/home/Dante/.vim/plugged/fzf.vim,/home/Dante/.vim/plugged/vim-wayland-clipboard,/home/Dante/.vim/plugged/coc.nvim,/home/Dante/.vim/plugged/vim-obsession,/usr/share/vim/vimfiles,/usr/share/vim/vim91,/usr/share/vim/vimfiles/after,/home/Dante/.vim/plugged/vimtex/after,/home/Dante/.vim/after"
Searching for "/home/Dante/.vim/lib/nerdtree/tree_dir_node.vim"
Searching for "/home/Dante/.vim/plugged/onedark.vim/lib/nerdtree/tree_dir_node.vim"
Searching for "/home/Dante/.vim/plugged/onehalf/vim/lib/nerdtree/tree_dir_node.vim"
Searching for "/home/Dante/.vim/plugged/gruvbox/lib/nerdtree/tree_dir_node.vim"
Searching for "/home/Dante/.vim/plugged/lightline.vim/lib/nerdtree/tree_dir_node.vim"
Searching for "/home/Dante/.vim/plugged/vim-tmux-navigator/lib/nerdtree/tree_dir_node.vim"
Searching for "/home/Dante/.vim/plugged/vimtex/lib/nerdtree/tree_dir_node.vim"
Searching for "/home/Dante/.vim/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim"
chdir(/home/Dante/.vim/plugged/nerdtree/lib/nerdtree)
fchdir() to previous dir
line 7: sourcing "/home/Dante/.vim/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim"
line 1: " ============================================================================
line 2: " CLASS: TreeDirNode
line 3: "
line 4: " A subclass of NERDTreeFileNode.
line 5: "
line 6: " The 'composite' part of the file/dir composite.
line 7: " ============================================================================
line 8: 
line 9: 
line 10: let s:TreeDirNode = copy(g:NERDTreeFileNode)
line 11: let g:NERDTreeDirNode = s:TreeDirNode
line 12: 
line 13: " FUNCTION: TreeDirNode.AbsoluteTreeRoot(){{{1
line 14: " Class method that returns the highest cached ancestor of the current root.
line 15: function! s:TreeDirNode.AbsoluteTreeRoot()
line 22: 
line 23: " FUNCTION: TreeDirNode.activate([options]) {{{1
line 24: function! s:TreeDirNode.activate(...)
line 38: 
line 39: " FUNCTION: TreeDirNode.addChild(treenode, inOrder) {{{1
line 40: " Adds the given treenode to the list of children for this node
line 41: "
line 42: " Args:
line 43: " -treenode: the node to add
line 44: " -inOrder: 1 if the new node should be inserted in sorted order
line 45: function! s:TreeDirNode.addChild(treenode, inOrder)
line 53: 
line 54: " FUNCTION: TreeDirNode.close() {{{1
line 55: " Mark this TreeDirNode as closed.
line 56: function! s:TreeDirNode.close()
line 64: 
line 65: " FUNCTION: TreeDirNode.closeChildren() {{{1
line 66: " Recursively close any directory nodes that are descendants of this node.
line 67: function! s:TreeDirNode.closeChildren()
line 75: 
line 76: " FUNCTION: TreeDirNode.createChild(path, inOrder) {{{1
line 77: " Instantiates a new child node for this node with the given path. The new
line 78: " nodes parent is set to this node.
line 79: "
line 80: " Args:
line 81: " path: a Path object that this node will represent/contain
line 82: " inOrder: 1 if the new node should be inserted in sorted order
line 83: "
line 84: " Returns:
line 85: " the newly created node
line 86: function! s:TreeDirNode.createChild(path, inOrder)
line 91: 
line 92: " FUNCTION: TreeDirNode.displayString() {{{1
line 93: " Assemble and return a string that can represent this TreeDirNode object in
line 94: " the NERDTree window.
line 95: function! s:TreeDirNode.displayString()
line 113: 
line 114: " FUNCTION: TreeDirNode.findNode(path) {{{1
line 115: " Will find one of the children (recursively) that has the given path
line 116: "
line 117: " Args:
line 118: " path: a path object
line 119: unlet s:TreeDirNode.findNode
line 120: function! s:TreeDirNode.findNode(path)
line 144: 
line 145: " FUNCTION: TreeDirNode.getCascade() {{{1
line 146: " Return an array of dir nodes (starting from self) that can be cascade opened.
line 147: function! s:TreeDirNode.getCascade()
line 157: 
line 158: " FUNCTION: TreeDirNode.getCascadeRoot() {{{1
line 159: " Return the first directory node in the cascade in which this directory node
line 160: " is rendered.
line 161: function! s:TreeDirNode.getCascadeRoot()
line 183: 
line 184: " FUNCTION: TreeDirNode.getChildCount() {{{1
line 185: " Returns the number of children this node has
line 186: function! s:TreeDirNode.getChildCount()
line 189: 
line 190: " FUNCTION: TreeDirNode.getChild(path) {{{1
line 191: " Returns child node of this node that has the given path or {} if no such node
line 192: " exists.
line 193: "
line 194: " This function doesnt not recurse into child dir nodes
line 195: "
line 196: " Args:
line 197: " path: a path object
line 198: function! s:TreeDirNode.getChild(path)
line 211: 
line 212: " FUNCTION: TreeDirNode.getChildByIndex(indx, visible) {{{1
line 213: " returns the child at the given index
line 214: "
line 215: " Args:
line 216: " indx: the index to get the child from
line 217: " visible: 1 if only the visible children array should be used, 0 if all the
line 218: " children should be searched.
line 219: function! s:TreeDirNode.getChildByIndex(indx, visible)
line 226: 
line 227: " FUNCTION: TreeDirNode.getChildIndex(path) {{{1
line 228: " Returns the index of the child node of this node that has the given path or
line 229: " -1 if no such node exists.
line 230: "
line 231: " This function doesnt not recurse into child dir nodes
line 232: "
line 233: " Args:
line 234: " path: a path object
line 235: function! s:TreeDirNode.getChildIndex(path)
line 257: 
line 258: " FUNCTION: TreeDirNode.getDirChildren() {{{1
line 259: " Return a list of all child nodes from 'self.children' that are of type
line 260: " TreeDirNode. This function supports http://github.com/scrooloose/nerdtree-project-plugin.git.
line 261: function! s:TreeDirNode.getDirChildren()
line 264: 
line 265: " FUNCTION: TreeDirNode._glob(pattern, all) {{{1
line 266: " Return a list of strings naming the descendants of the directory in this
line 267: " TreeDirNode object that match the specified glob pattern.
line 268: "
line 269: " Args:
line 270: " pattern: (string) the glob pattern to apply
line 271: " all: (0 or 1) if 1, include '.' and '..' if they match 'pattern'; if 0,
line 272: "      always exclude them
line 273: "
line 274: " Note: If the pathnames in the result list are below the working directory,
line 275: " they are returned as pathnames relative to that directory. This is because
line 276: " this function, internally, attempts to obey 'wildignore' rules that use
line 277: " relative paths.
line 278: function! s:TreeDirNode._glob(pattern, all)
line 342: 
line 343: " FUNCTION: TreeDirNode.GetSelected() {{{1
line 344: " Returns the current node if it is a dir node, or else returns the current
line 345: " nodes parent
line 346: unlet s:TreeDirNode.GetSelected
line 347: function! s:TreeDirNode.GetSelected()
line 356: 
line 357: " FUNCTION: TreeDirNode.getVisibleChildCount() {{{1
line 358: " Returns the number of visible children this node has
line 359: function! s:TreeDirNode.getVisibleChildCount()
line 362: 
line 363: " FUNCTION: TreeDirNode.getVisibleChildren() {{{1
line 364: " Returns a list of children to display for this node, in the correct order
line 365: "
line 366: " Return:
line 367: " an array of treenodes
line 368: function! s:TreeDirNode.getVisibleChildren()
line 377: 
line 378: " FUNCTION: TreeDirNode.hasVisibleChildren() {{{1
line 379: " returns 1 if this node has any childre, 0 otherwise..
line 380: function! s:TreeDirNode.hasVisibleChildren()
line 383: 
line 384: " FUNCTION: TreeDirNode.isCascadable() {{{1
line 385: " true if this dir has only one visible child that is also a dir
line 386: " false if this dir is bookmarked or symlinked. Why? Two reasons:
line 387: "  1. If cascaded, we don't know which dir is bookmarked or is a symlink.
line 388: "  2. If the parent is a symlink or is bookmarked, you end up with unparsable
line 389: "     text, and NERDTree cannot get the path of any child node.
line 390: " Also, return false if this directory is the tree root, which should never be
line 391: " part of a cascade.
line 392: function! s:TreeDirNode.isCascadable()
line 414: 
line 415: " FUNCTION: TreeDirNode._initChildren() {{{1
line 416: " Removes all childen from this node and re-reads them
line 417: "
line 418: " Args:
line 419: " silent: 1 if the function should not echo any 'please wait' messages for
line 420: " large directories
line 421: "
line 422: " Return: the number of child nodes read
line 423: function! s:TreeDirNode._initChildren(silent)
line 456: 
line 457: " FUNCTION: TreeDirNode.New(path, nerdtree) {{{1
line 458: " Return a new TreeDirNode object with the given path and parent.
line 459: "
line 460: " Args:
line 461: " path: dir that the node represents
line 462: " nerdtree: the tree the node belongs to
line 463: function! s:TreeDirNode.New(path, nerdtree)
line 479: 
line 480: " FUNCTION: TreeDirNode.open([options]) {{{1
line 481: " Open this directory node in the current tree or elsewhere if special options
line 482: " are provided. Return 0 if options were processed. Otherwise, return the
line 483: " number of new cached nodes.
line 484: function! s:TreeDirNode.open(...)
line 514: 
line 515: " FUNCTION: TreeDirNode.openAlong([opts]) {{{1
line 516: " recursive open the dir if it has only one directory child.
line 517: "
line 518: " return the level of opened directories.
line 519: function! s:TreeDirNode.openAlong(...)
line 535: 
line 536: " FUNCTION: TreeDirNode.openExplorer() {{{1
line 537: " Open an explorer window for this node in the previous window. The explorer
line 538: " can be a NERDTree window or a netrw window.
line 539: function! s:TreeDirNode.openExplorer()
line 543: 
line 544: " FUNCTION: TreeDirNode.openInNewTab(options) {{{1
line 545: unlet s:TreeDirNode.openInNewTab
line 546: function! s:TreeDirNode.openInNewTab(options)
line 550: 
line 551: " FUNCTION: TreeDirNode._openInNewTab() {{{1
line 552: function! s:TreeDirNode._openInNewTab()
line 556: 
line 557: " FUNCTION: TreeDirNode.openRecursively() {{{1
line 558: " Open this directory node and any descendant directory nodes whose pathnames
line 559: " are not ignored.
line 560: function! s:TreeDirNode.openRecursively()
line 569: 
line 570: " FUNCTION: TreeDirNode.refresh() {{{1
line 571: function! s:TreeDirNode.refresh()
line 610: 
line 611: " FUNCTION: TreeDirNode.refreshFlags() {{{1
line 612: unlet s:TreeDirNode.refreshFlags
line 613: function! s:TreeDirNode.refreshFlags()
line 619: 
line 620: " FUNCTION: TreeDirNode.refreshDirFlags() {{{1
line 621: function! s:TreeDirNode.refreshDirFlags()
line 624: 
line 625: " FUNCTION: TreeDirNode.reveal(path) {{{1
line 626: " reveal the given path, i.e. cache and open all treenodes needed to display it
line 627: " in the UI
line 628: " Returns the revealed node
line 629: function! s:TreeDirNode.reveal(path, ...)
line 659: 
line 660: " FUNCTION: TreeDirNode.removeChild(treenode) {{{1
line 661: " Remove the given treenode from self.children.
line 662: " Throws NERDTree.ChildNotFoundError if the node is not found.
line 663: "
line 664: " Args:
line 665: " treenode: the node object to remove
line 666: function! s:TreeDirNode.removeChild(treenode)
line 676: 
line 677: " FUNCTION: TreeDirNode.sortChildren() {{{1
line 678: " Sort self.children by alphabetical order and directory priority.
line 679: function! s:TreeDirNode.sortChildren()
line 687: 
line 688: " FUNCTION: TreeDirNode.toggleOpen([options]) {{{1
line 689: " Opens this directory if it is closed and vice versa
line 690: function! s:TreeDirNode.toggleOpen(...)
line 702: 
line 703: " FUNCTION: TreeDirNode.transplantChild(newNode) {{{1
line 704: " Replaces the child of this with the given node (where the child node's full
line 705: " path matches a:newNode's fullpath). The search for the matching node is
line 706: " non-recursive
line 707: "
line 708: " Arg:
line 709: " newNode: the node to graft into the tree
line 710: function! s:TreeDirNode.transplantChild(newNode)
line 719: 
line 720: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/Dante/.vim/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim
continuing in nerdtree#loadClassFiles
line 8:     runtime lib/nerdtree/opener.vim
Searching for "lib/nerdtree/opener.vim" in "/home/Dante/.vim,/home/Dante/.vim/plugged/onedark.vim,/home/Dante/.vim/plugged/onehalf/vim,/home/Dante/.vim/plugged/gruvbox,/home/Dante/.vim/plugged/lightline.vim,/home/Dante/.vim/plugged/vim-tmux-navigator,/home/Dante/.vim/plugged/vimtex,/home/Dante/.vim/plugged/nerdtree,/home/Dante/.vim/plugged/fzf,/home/Dante/.vim/plugged/fzf.vim,/home/Dante/.vim/plugged/vim-wayland-clipboard,/home/Dante/.vim/plugged/coc.nvim,/home/Dante/.vim/plugged/vim-obsession,/usr/share/vim/vimfiles,/usr/share/vim/vim91,/usr/share/vim/vimfiles/after,/home/Dante/.vim/plugged/vimtex/after,/home/Dante/.vim/after"
Searching for "/home/Dante/.vim/lib/nerdtree/opener.vim"
Searching for "/home/Dante/.vim/plugged/onedark.vim/lib/nerdtree/opener.vim"
Searching for "/home/Dante/.vim/plugged/onehalf/vim/lib/nerdtree/opener.vim"
Searching for "/home/Dante/.vim/plugged/gruvbox/lib/nerdtree/opener.vim"
Searching for "/home/Dante/.vim/plugged/lightline.vim/lib/nerdtree/opener.vim"
Searching for "/home/Dante/.vim/plugged/vim-tmux-navigator/lib/nerdtree/opener.vim"
Searching for "/home/Dante/.vim/plugged/vimtex/lib/nerdtree/opener.vim"
Searching for "/home/Dante/.vim/plugged/nerdtree/lib/nerdtree/opener.vim"
chdir(/home/Dante/.vim/plugged/nerdtree/lib/nerdtree)
fchdir() to previous dir
line 8: sourcing "/home/Dante/.vim/plugged/nerdtree/lib/nerdtree/opener.vim"
line 1: " ============================================================================
line 2: " CLASS: Opener
line 3: "
line 4: " The Opener class defines an API for 'opening' operations.
line 5: " ============================================================================
line 6: 
line 7: 
line 8: let s:Opener = {}
line 9: let g:NERDTreeOpener = s:Opener
line 10: 
line 11: " FUNCTION: s:Opener._bufInWindows(bnum) {{{1
line 12: " [[STOLEN FROM VTREEEXPLORER.VIM]]
line 13: " Determine the number of windows open to this buffer number.
line 14: " Care of Yegappan Lakshman.  Thanks!
line 15: "
line 16: " Args:
line 17: " bnum: the subject buffers buffer number
line 18: function! s:Opener._bufInWindows(bnum)
line 34: 
line 35: " FUNCTION: Opener._checkToCloseTree(newtab) {{{1
line 36: " Check the class options to see if the tree should be closed now.
line 37: "
line 38: " Args:
line 39: " a:newtab - boolean. If set, only close the tree now if we are opening the
line 40: " target in a new tab. This is needed because we have to close tree before we
line 41: " leave the tab
line 42: function! s:Opener._checkToCloseTree(newtab)
line 51: 
line 52: " FUNCTION: s:Opener._firstUsableWindow() {{{1
line 53: " find the window number of the first normal window
line 54: function! s:Opener._firstUsableWindow()
line 68: 
line 69: " FUNCTION: Opener._gotoTargetWin() {{{1
line 70: function! s:Opener._gotoTargetWin()
line 95: 
line 96: " FUNCTION: s:Opener._isWindowUsable(winnumber) {{{1
line 97: " Returns 0 if opening a file from the tree in the given window requires it to
line 98: " be split, 1 otherwise
line 99: "
line 100: " Args:
line 101: " winnumber: the number of the window in question
line 102: function! s:Opener._isWindowUsable(winnumber)
line 126: 
line 127: " FUNCTION: Opener.New(path, opts) {{{1
line 128: " Instantiate a new NERDTreeOpener object.
line 129: " Args:
line 130: " a:path: the path object that is to be opened
line 131: " a:opts: a dictionary containing the following optional keys...
line 132: "   'where': specifies whether the node should be opened in new split, in
line 133: "            a new tab or, in the last window; takes values 'v', 'h', or 't'
line 134: "   'reuse': if file is already shown in a window, jump there; takes values
line 135: "            'all', 'currenttab', or empty
line 136: "   'keepopen': boolean (0 or 1); if true, the tree window will not be closed
line 137: "   'stay': boolean (0 or 1); if true, remain in tree window after opening
line 138: function! s:Opener.New(path, opts)
line 152: 
line 153: " FUNCTION: Opener._newSplit() {{{1
line 154: function! s:Opener._newSplit()
line 183: 
line 184: " FUNCTION: Opener._newVSplit() {{{1
line 185: function! s:Opener._newVSplit()
line 207: 
line 208: " FUNCTION: Opener.open(target) {{{1
line 209: function! s:Opener.open(target)
line 217: 
line 218: " FUNCTION: Opener._openFile() {{{1
line 219: function! s:Opener._openFile()
line 238: 
line 239: " FUNCTION: Opener._openDirectory(node) {{{1
line 240: function! s:Opener._openDirectory(node)
line 259: 
line 260: " FUNCTION: Opener._previousWindow() {{{1
line 261: function! s:Opener._previousWindow()
line 279: 
line 280: " FUNCTION: Opener._restoreCursorPos() {{{1
line 281: function! s:Opener._restoreCursorPos()
line 285: 
line 286: " FUNCTION: Opener._reuseWindow() {{{1
line 287: " put the cursor in the first window we find for this file
line 288: "
line 289: " return 1 if we were successful
line 290: function! s:Opener._reuseWindow()
line 319: 
line 320: " FUNCTION: Opener._saveCursorPos() {{{1
line 321: function! s:Opener._saveCursorPos()
line 325: 
line 326: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/Dante/.vim/plugged/nerdtree/lib/nerdtree/opener.vim
continuing in nerdtree#loadClassFiles
line 9:     runtime lib/nerdtree/creator.vim
Searching for "lib/nerdtree/creator.vim" in "/home/Dante/.vim,/home/Dante/.vim/plugged/onedark.vim,/home/Dante/.vim/plugged/onehalf/vim,/home/Dante/.vim/plugged/gruvbox,/home/Dante/.vim/plugged/lightline.vim,/home/Dante/.vim/plugged/vim-tmux-navigator,/home/Dante/.vim/plugged/vimtex,/home/Dante/.vim/plugged/nerdtree,/home/Dante/.vim/plugged/fzf,/home/Dante/.vim/plugged/fzf.vim,/home/Dante/.vim/plugged/vim-wayland-clipboard,/home/Dante/.vim/plugged/coc.nvim,/home/Dante/.vim/plugged/vim-obsession,/usr/share/vim/vimfiles,/usr/share/vim/vim91,/usr/share/vim/vimfiles/after,/home/Dante/.vim/plugged/vimtex/after,/home/Dante/.vim/after"
Searching for "/home/Dante/.vim/lib/nerdtree/creator.vim"
Searching for "/home/Dante/.vim/plugged/onedark.vim/lib/nerdtree/creator.vim"
Searching for "/home/Dante/.vim/plugged/onehalf/vim/lib/nerdtree/creator.vim"
Searching for "/home/Dante/.vim/plugged/gruvbox/lib/nerdtree/creator.vim"
Searching for "/home/Dante/.vim/plugged/lightline.vim/lib/nerdtree/creator.vim"
Searching for "/home/Dante/.vim/plugged/vim-tmux-navigator/lib/nerdtree/creator.vim"
Searching for "/home/Dante/.vim/plugged/vimtex/lib/nerdtree/creator.vim"
Searching for "/home/Dante/.vim/plugged/nerdtree/lib/nerdtree/creator.vim"
chdir(/home/Dante/.vim/plugged/nerdtree/lib/nerdtree)
fchdir() to previous dir
line 9: sourcing "/home/Dante/.vim/plugged/nerdtree/lib/nerdtree/creator.vim"
line 1: " ============================================================================
line 2: " CLASS: Creator
line 3: "
line 4: " This class is responsible for creating NERDTree instances.  The new NERDTree
line 5: " may be a tab tree, a window tree, or a mirrored tree.  In the process of
line 6: " creating a NERDTree, it sets up all of the window and buffer options and key
line 7: " mappings etc.
line 8: " ============================================================================
line 9: 
line 10: 
line 11: let s:Creator = {}
line 12: let g:NERDTreeCreator = s:Creator
line 13: 
line 14: " FUNCTION: s:Creator._bindMappings() {{{1
line 15: function! s:Creator._bindMappings()
line 28: 
line 29: " FUNCTION: s:Creator._broadcastInitEvent() {{{1
line 30: function! s:Creator._broadcastInitEvent()
line 35: 
line 36: " FUNCTION: s:Creator.BufNamePrefix() {{{1
line 37: function! s:Creator.BufNamePrefix()
line 40: 
line 41: " FUNCTION: s:Creator.CreateExploreTree(dir) {{{1
line 42: function! s:Creator.CreateExploreTree(dir)
line 63: 
line 64: " FUNCTION: s:Creator.CreateTabTree(a:name) {{{1
line 65: function! s:Creator.CreateTabTree(name)
line 69: 
line 70: " FUNCTION: s:Creator.createTabTree(a:name) {{{1
line 71: " name: the name of a bookmark or a directory
line 72: function! s:Creator.createTabTree(name)
line 98: 
line 99: " FUNCTION: s:Creator.CreateWindowTree(dir) {{{1
line 100: function! s:Creator.CreateWindowTree(dir)
line 104: 
line 105: " FUNCTION: s:Creator.createWindowTree(dir) {{{1
line 106: function! s:Creator.createWindowTree(dir)
line 131: 
line 132: " FUNCTION: s:Creator._createNERDTree(path) {{{1
line 133: function! s:Creator._createNERDTree(path, type)
line 143: 
line 144: " FUNCTION: s:Creator.CreateMirror() {{{1
line 145: function! s:Creator.CreateMirror()
line 149: 
line 150: " FUNCTION: s:Creator.createMirror() {{{1
line 151: function! s:Creator.createMirror()
line 203: 
line 204: " FUNCTION: s:Creator._createTreeWin() {{{1
line 205: " Initialize the NERDTree window.  Open the window, size it properly, set all
line 206: " local options, etc.
line 207: function! s:Creator._createTreeWin()
line 231: 
line 232: " FUNCTION: s:Creator._isBufHidden(nr) {{{1
line 233: function! s:Creator._isBufHidden(nr)
line 240: 
line 241: " FUNCTION: s:Creator.New() {{{1
line 242: function! s:Creator.New()
line 246: 
line 247: " FUNCTION: s:Creator._nextBufferName(type='') {{{1
line 248: " gets an optional buffer type of either 'tab' or 'win'.
line 249: " returns the buffer name for the next nerd tree of such type.
line 250: function! s:Creator._nextBufferName(...)
line 265: 
line 266: " FUNCTION: s:Creator._nextBufferNumber() {{{1
line 267: " the number to add to the nerd tree buffer name to make the buf name unique
line 268: function! s:Creator._nextBufferNumber()
line 277: 
line 278: " FUNCTION: s:Creator._pathForString(str) {{{1
line 279: " find a bookmark or adirectory for the given string
line 280: function! s:Creator._pathForString(str)
line 310: 
line 311: " Function: s:Creator._removeTreeBufForTab()   {{{1
line 312: function! s:Creator._removeTreeBufForTab()
line 327: 
line 328: " FUNCTION: s:Creator._setCommonBufOptions() {{{1
line 329: function! s:Creator._setCommonBufOptions()
line 365: 
line 366: " FUNCTION: s:Creator._setupStatusline() {{{1
line 367: function! s:Creator._setupStatusline()
line 372: 
line 373: " FUNCTION: s:Creator._tabpagevar(tabnr, var) {{{1
line 374: function! s:Creator._tabpagevar(tabnr, var)
line 393: 
line 394: " FUNCTION: s:Creator.ToggleTabTree(dir) {{{1
line 395: function! s:Creator.ToggleTabTree(dir)
line 399: 
line 400: " FUNCTION: s:Creator.toggleTabTree(dir) {{{1
line 401: " Toggles the NERD tree. I.e if the NERD tree is open, it is closed. If it is
line 402: " closed, it is restored or initialized. If dir is not empty, it will be set
line 403: " as the new root.
line 404: "
line 405: " Args:
line 406: " dir: the full path for the root node (is used if the NERD tree is being
line 407: " initialized, or to change the root to a new dir.)
line 408: function! s:Creator.toggleTabTree(dir)
line 425: 
line 426: " Function: s:Creator._uniq(list)   {{{1
line 427: " returns a:list without duplicates
line 428: function! s:Creator._uniq(list)
line 437: 
line 438: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/Dante/.vim/plugged/nerdtree/lib/nerdtree/creator.vim
continuing in nerdtree#loadClassFiles
line 10:     runtime lib/nerdtree/flag_set.vim
Searching for "lib/nerdtree/flag_set.vim" in "/home/Dante/.vim,/home/Dante/.vim/plugged/onedark.vim,/home/Dante/.vim/plugged/onehalf/vim,/home/Dante/.vim/plugged/gruvbox,/home/Dante/.vim/plugged/lightline.vim,/home/Dante/.vim/plugged/vim-tmux-navigator,/home/Dante/.vim/plugged/vimtex,/home/Dante/.vim/plugged/nerdtree,/home/Dante/.vim/plugged/fzf,/home/Dante/.vim/plugged/fzf.vim,/home/Dante/.vim/plugged/vim-wayland-clipboard,/home/Dante/.vim/plugged/coc.nvim,/home/Dante/.vim/plugged/vim-obsession,/usr/share/vim/vimfiles,/usr/share/vim/vim91,/usr/share/vim/vimfiles/after,/home/Dante/.vim/plugged/vimtex/after,/home/Dante/.vim/after"
Searching for "/home/Dante/.vim/lib/nerdtree/flag_set.vim"
Searching for "/home/Dante/.vim/plugged/onedark.vim/lib/nerdtree/flag_set.vim"
Searching for "/home/Dante/.vim/plugged/onehalf/vim/lib/nerdtree/flag_set.vim"
Searching for "/home/Dante/.vim/plugged/gruvbox/lib/nerdtree/flag_set.vim"
Searching for "/home/Dante/.vim/plugged/lightline.vim/lib/nerdtree/flag_set.vim"
Searching for "/home/Dante/.vim/plugged/vim-tmux-navigator/lib/nerdtree/flag_set.vim"
Searching for "/home/Dante/.vim/plugged/vimtex/lib/nerdtree/flag_set.vim"
Searching for "/home/Dante/.vim/plugged/nerdtree/lib/nerdtree/flag_set.vim"
chdir(/home/Dante/.vim/plugged/nerdtree/lib/nerdtree)
fchdir() to previous dir
line 10: sourcing "/home/Dante/.vim/plugged/nerdtree/lib/nerdtree/flag_set.vim"
line 1: "CLASS: FlagSet
line 2: "============================================================
line 3: let s:FlagSet = {}
line 4: let g:NERDTreeFlagSet = s:FlagSet
line 5: 
line 6: "FUNCTION: FlagSet.addFlag(scope, flag) {{{1
line 7: function! s:FlagSet.addFlag(scope, flag)
line 13: 
line 14: "FUNCTION: FlagSet.clearFlags(scope) {{{1
line 15: function! s:FlagSet.clearFlags(scope)
line 18: 
line 19: "FUNCTION: FlagSet._flagsForScope(scope) {{{1
line 20: function! s:FlagSet._flagsForScope(scope)
line 26: 
line 27: "FUNCTION: FlagSet.New() {{{1
line 28: function! s:FlagSet.New()
line 33: 
line 34: "FUNCTION: FlagSet.removeFlag(scope, flag) {{{1
line 35: function! s:FlagSet.removeFlag(scope, flag)
line 43: 
line 44: "FUNCTION: FlagSet.renderToString() {{{1
line 45: function! s:FlagSet.renderToString()
line 57: 
line 58: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/Dante/.vim/plugged/nerdtree/lib/nerdtree/flag_set.vim
continuing in nerdtree#loadClassFiles
line 11:     runtime lib/nerdtree/nerdtree.vim
Searching for "lib/nerdtree/nerdtree.vim" in "/home/Dante/.vim,/home/Dante/.vim/plugged/onedark.vim,/home/Dante/.vim/plugged/onehalf/vim,/home/Dante/.vim/plugged/gruvbox,/home/Dante/.vim/plugged/lightline.vim,/home/Dante/.vim/plugged/vim-tmux-navigator,/home/Dante/.vim/plugged/vimtex,/home/Dante/.vim/plugged/nerdtree,/home/Dante/.vim/plugged/fzf,/home/Dante/.vim/plugged/fzf.vim,/home/Dante/.vim/plugged/vim-wayland-clipboard,/home/Dante/.vim/plugged/coc.nvim,/home/Dante/.vim/plugged/vim-obsession,/usr/share/vim/vimfiles,/usr/share/vim/vim91,/usr/share/vim/vimfiles/after,/home/Dante/.vim/plugged/vimtex/after,/home/Dante/.vim/after"
Searching for "/home/Dante/.vim/lib/nerdtree/nerdtree.vim"
Searching for "/home/Dante/.vim/plugged/onedark.vim/lib/nerdtree/nerdtree.vim"
Searching for "/home/Dante/.vim/plugged/onehalf/vim/lib/nerdtree/nerdtree.vim"
Searching for "/home/Dante/.vim/plugged/gruvbox/lib/nerdtree/nerdtree.vim"
Searching for "/home/Dante/.vim/plugged/lightline.vim/lib/nerdtree/nerdtree.vim"
Searching for "/home/Dante/.vim/plugged/vim-tmux-navigator/lib/nerdtree/nerdtree.vim"
Searching for "/home/Dante/.vim/plugged/vimtex/lib/nerdtree/nerdtree.vim"
Searching for "/home/Dante/.vim/plugged/nerdtree/lib/nerdtree/nerdtree.vim"
chdir(/home/Dante/.vim/plugged/nerdtree/lib/nerdtree)
fchdir() to previous dir
line 11: sourcing "/home/Dante/.vim/plugged/nerdtree/lib/nerdtree/nerdtree.vim"
line 1: "CLASS: NERDTree
line 2: "============================================================
line 3: let s:NERDTree = {}
line 4: let g:NERDTree = s:NERDTree
line 5: 
line 6: "FUNCTION: s:NERDTree.AddPathFilter() {{{1
line 7: function! s:NERDTree.AddPathFilter(callback)
line 10: 
line 11: "FUNCTION: s:NERDTree.changeRoot(node) {{{1
line 12: function! s:NERDTree.changeRoot(node)
line 34: 
line 35: "FUNCTION: s:NERDTree.Close() {{{1
line 36: "Closes the tab tree window for this tab
line 37: function! s:NERDTree.Close()
line 67: 
line 68: "FUNCTION: s:NERDTree.CursorToBookmarkTable(){{{1
line 69: "Places the cursor at the top of the bookmarks table
line 70: function! s:NERDTree.CursorToBookmarkTable()
line 90: 
line 91: "FUNCTION: s:NERDTree.CursorToTreeWin(){{{1
line 92: "Places the cursor in the nerd tree window
line 93: function! s:NERDTree.CursorToTreeWin(...)
line 97: 
line 98: " Function: s:NERDTree.ExistsForBuffer()   {{{1
line 99: " Returns 1 if a nerd tree root exists in the current buffer
line 100: function! s:NERDTree.ExistsForBuf()
line 103: 
line 104: " Function: s:NERDTree.ExistsForTab()   {{{1
line 105: " Returns 1 if a nerd tree root exists in the current tab
line 106: function! s:NERDTree.ExistsForTab()
line 114: 
line 115: function! s:NERDTree.ForCurrentBuf()
line 122: 
line 123: "FUNCTION: s:NERDTree.ForCurrentTab() {{{1
line 124: function! s:NERDTree.ForCurrentTab()
line 132: 
line 133: "FUNCTION: s:NERDTree.getRoot() {{{1
line 134: function! s:NERDTree.getRoot()
line 137: 
line 138: "FUNCTION: s:NERDTree.GetWinNum() {{{1
line 139: "gets the nerd tree window number for this tab
line 140: function! s:NERDTree.GetWinNum()
line 154: 
line 155: "FUNCTION: s:NERDTree.IsOpen() {{{1
line 156: function! s:NERDTree.IsOpen()
line 159: 
line 160: "FUNCTION: s:NERDTree.isTabTree() {{{1
line 161: function! s:NERDTree.isTabTree()
line 164: 
line 165: "FUNCTION: s:NERDTree.isWinTree() {{{1
line 166: function! s:NERDTree.isWinTree()
line 169: 
line 170: "FUNCTION: s:NERDTree.MustBeOpen() {{{1
line 171: function! s:NERDTree.MustBeOpen()
line 176: 
line 177: "FUNCTION: s:NERDTree.New() {{{1
line 178: function! s:NERDTree.New(path, type)
line 185: 
line 186: "FUNCTION: s:NERDTree.PathFilters() {{{1
line 187: function! s:NERDTree.PathFilters()
line 193: 
line 194: "FUNCTION: s:NERDTree.previousBuf() {{{1
line 195: function! s:NERDTree.previousBuf()
line 198: 
line 199: function! s:NERDTree.setPreviousBuf(bnum)
line 202: 
line 203: "FUNCTION: s:NERDTree.render() {{{1
line 204: "A convenience function - since this is called often
line 205: function! s:NERDTree.render()
line 208: 
line 209: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/Dante/.vim/plugged/nerdtree/lib/nerdtree/nerdtree.vim
continuing in nerdtree#loadClassFiles
line 12:     runtime lib/nerdtree/ui.vim
Searching for "lib/nerdtree/ui.vim" in "/home/Dante/.vim,/home/Dante/.vim/plugged/onedark.vim,/home/Dante/.vim/plugged/onehalf/vim,/home/Dante/.vim/plugged/gruvbox,/home/Dante/.vim/plugged/lightline.vim,/home/Dante/.vim/plugged/vim-tmux-navigator,/home/Dante/.vim/plugged/vimtex,/home/Dante/.vim/plugged/nerdtree,/home/Dante/.vim/plugged/fzf,/home/Dante/.vim/plugged/fzf.vim,/home/Dante/.vim/plugged/vim-wayland-clipboard,/home/Dante/.vim/plugged/coc.nvim,/home/Dante/.vim/plugged/vim-obsession,/usr/share/vim/vimfiles,/usr/share/vim/vim91,/usr/share/vim/vimfiles/after,/home/Dante/.vim/plugged/vimtex/after,/home/Dante/.vim/after"
Searching for "/home/Dante/.vim/lib/nerdtree/ui.vim"
Searching for "/home/Dante/.vim/plugged/onedark.vim/lib/nerdtree/ui.vim"
Searching for "/home/Dante/.vim/plugged/onehalf/vim/lib/nerdtree/ui.vim"
Searching for "/home/Dante/.vim/plugged/gruvbox/lib/nerdtree/ui.vim"
Searching for "/home/Dante/.vim/plugged/lightline.vim/lib/nerdtree/ui.vim"
Searching for "/home/Dante/.vim/plugged/vim-tmux-navigator/lib/nerdtree/ui.vim"
Searching for "/home/Dante/.vim/plugged/vimtex/lib/nerdtree/ui.vim"
Searching for "/home/Dante/.vim/plugged/nerdtree/lib/nerdtree/ui.vim"
chdir(/home/Dante/.vim/plugged/nerdtree/lib/nerdtree)
fchdir() to previous dir
line 12: sourcing "/home/Dante/.vim/plugged/nerdtree/lib/nerdtree/ui.vim"
line 1: " ============================================================================
line 2: " CLASS: UI
line 3: " ============================================================================
line 4: 
line 5: 
line 6: let s:UI = {}
line 7: let g:NERDTreeUI = s:UI
line 8: 
line 9: " FUNCTION: s:UI.centerView() {{{1
line 10: " centers the nerd tree window around the cursor (provided the nerd tree
line 11: " options permit)
line 12: function! s:UI.centerView()
line 22: 
line 23: " FUNCTION: s:UI._dumpHelp  {{{1
line 24: " prints out the quick help
line 25: function! s:UI._dumpHelp()
line 141: 
line 142: 
line 143: " FUNCTION: s:UI.new(nerdtree) {{{1
line 144: function! s:UI.New(nerdtree)
line 156: 
line 157: " FUNCTION: s:UI.getPath(ln) {{{1
line 158: " Return the Path object for the node that is rendered on the given line
line 159: " number.  If the 'up a dir' line is selected, return the Path object for
line 160: " the parent of the root.  Return the empty dictionary if the given line
line 161: " does not reference a tree node.
line 162: function! s:UI.getPath(ln)
line 210: 
line 211: " FUNCTION: s:UI.getLineNum(node) {{{1
line 212: " Return the line number where the given node is rendered.  Return -1 if the
line 213: " given node is not visible.
line 214: function! s:UI.getLineNum(node)
line 259: 
line 260: " FUNCTION: s:UI.getRootLineNum(){{{1
line 261: " gets the line number of the root node
line 262: function! s:UI.getRootLineNum()
line 269: 
line 270: " FUNCTION: s:UI.getShowBookmarks() {{{1
line 271: function! s:UI.getShowBookmarks()
line 274: 
line 275: " FUNCTION: s:UI.getShowFiles() {{{1
line 276: function! s:UI.getShowFiles()
line 279: 
line 280: " FUNCTION: s:UI.getShowHelp() {{{1
line 281: function! s:UI.getShowHelp()
line 284: 
line 285: " FUNCTION: s:UI.getShowHidden() {{{1
line 286: function! s:UI.getShowHidden()
line 289: 
line 290: " FUNCTION: s:UI.getShowFileLines() {{{1
line 291: function! s:UI.getShowFileLines()
line 294: 
line 295: " FUNCTION: s:UI._indentLevelFor(line) {{{1
line 296: function! s:UI._indentLevelFor(line)
line 307: 
line 308: " FUNCTION: s:UI.IndentWid() {{{1
line 309: function! s:UI.IndentWid()
line 312: 
line 313: " FUNCTION: s:UI.isIgnoreFilterEnabled() {{{1
line 314: function! s:UI.isIgnoreFilterEnabled()
line 317: 
line 318: " FUNCTION: s:UI.isMinimal() {{{1
line 319: function! s:UI.isMinimal()
line 322: 
line 323: " FUNCTION: s:UI.MarkupReg() {{{1
line 324: function! s:UI.MarkupReg()
line 327: 
line 328: " FUNCTION: s:UI._renderBookmarks {{{1
line 329: function! s:UI._renderBookmarks()
line 348: 
line 349: " FUNCTION: s:UI.restoreScreenState() {{{1
line 350: "
line 351: " Sets the screen state back to what it was when nerdtree#saveScreenState was last
line 352: " called.
line 353: "
line 354: " Assumes the cursor is in the NERDTree window
line 355: function! s:UI.restoreScreenState()
line 368: 
line 369: " FUNCTION: s:UI.saveScreenState() {{{1
line 370: " Saves the current cursor position in the current buffer and the window
line 371: " scroll position
line 372: function! s:UI.saveScreenState()
line 384: 
line 385: " FUNCTION: s:UI.setShowHidden(val) {{{1
line 386: function! s:UI.setShowHidden(val)
line 389: 
line 390: " FUNCTION: s:UI._stripMarkup(line){{{1
line 391: " find the filename in the given line, and return it.
line 392: "
line 393: " Args:
line 394: " line: the subject line
line 395: function! s:UI._stripMarkup(line)
line 399: 
line 400: " FUNCTION: s:UI.render() {{{1
line 401: function! s:UI.render()
line 452: 
line 453: 
line 454: " FUNCTION: UI.renderViewSavingPosition {{{1
line 455: " Renders the tree and ensures the cursor stays on the current node or the
line 456: " current nodes parent if it is no longer available upon re-rendering
line 457: function! s:UI.renderViewSavingPosition()
line 472: 
line 473: " FUNCTION: s:UI.toggleHelp() {{{1
line 474: function! s:UI.toggleHelp()
line 477: 
line 478: " FUNCTION: s:UI.toggleIgnoreFilter() {{{1
line 479: " toggles the use of the NERDTreeIgnore option
line 480: function! s:UI.toggleIgnoreFilter()
line 485: 
line 486: " FUNCTION: s:UI.setShowBookmarks() {{{1
line 487: " Sets the visibility of the Bookmark table.
line 488: function! s:UI.setShowBookmarks(value)
line 506: 
line 507: " FUNCTION: s:UI.toggleShowBookmarks() {{{1
line 508: " Toggle the visibility of the Bookmark table.
line 509: function! s:UI.toggleShowBookmarks()
line 512: 
line 513: " FUNCTION: s:UI.toggleShowFiles() {{{1
line 514: " toggles the display of hidden files
line 515: function! s:UI.toggleShowFiles()
line 520: 
line 521: " FUNCTION: s:UI.toggleShowHidden() {{{1
line 522: " toggles the display of hidden files
line 523: function! s:UI.toggleShowHidden()
line 528: 
line 529: " FUNCTION: s:UI.toggleShowFileLines() {{{1
line 530: " toggles the display of file lines
line 531: function! s:UI.toggleShowFileLines()
line 537: 
line 538: " FUNCTION: s:UI.toggleZoom() {{{1
line 539: " zoom (maximize/minimize) the NERDTree window
line 540: function! s:UI.toggleZoom()
line 552: 
line 553: " FUNCTION: s:UI.UpDirLine() {{{1
line 554: function! s:UI.UpDirLine()
line 557: 
line 558: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/Dante/.vim/plugged/nerdtree/lib/nerdtree/ui.vim
continuing in nerdtree#loadClassFiles
line 13:     runtime lib/nerdtree/event.vim
Searching for "lib/nerdtree/event.vim" in "/home/Dante/.vim,/home/Dante/.vim/plugged/onedark.vim,/home/Dante/.vim/plugged/onehalf/vim,/home/Dante/.vim/plugged/gruvbox,/home/Dante/.vim/plugged/lightline.vim,/home/Dante/.vim/plugged/vim-tmux-navigator,/home/Dante/.vim/plugged/vimtex,/home/Dante/.vim/plugged/nerdtree,/home/Dante/.vim/plugged/fzf,/home/Dante/.vim/plugged/fzf.vim,/home/Dante/.vim/plugged/vim-wayland-clipboard,/home/Dante/.vim/plugged/coc.nvim,/home/Dante/.vim/plugged/vim-obsession,/usr/share/vim/vimfiles,/usr/share/vim/vim91,/usr/share/vim/vimfiles/after,/home/Dante/.vim/plugged/vimtex/after,/home/Dante/.vim/after"
Searching for "/home/Dante/.vim/lib/nerdtree/event.vim"
Searching for "/home/Dante/.vim/plugged/onedark.vim/lib/nerdtree/event.vim"
Searching for "/home/Dante/.vim/plugged/onehalf/vim/lib/nerdtree/event.vim"
Searching for "/home/Dante/.vim/plugged/gruvbox/lib/nerdtree/event.vim"
Searching for "/home/Dante/.vim/plugged/lightline.vim/lib/nerdtree/event.vim"
Searching for "/home/Dante/.vim/plugged/vim-tmux-navigator/lib/nerdtree/event.vim"
Searching for "/home/Dante/.vim/plugged/vimtex/lib/nerdtree/event.vim"
Searching for "/home/Dante/.vim/plugged/nerdtree/lib/nerdtree/event.vim"
chdir(/home/Dante/.vim/plugged/nerdtree/lib/nerdtree)
fchdir() to previous dir
line 13: sourcing "/home/Dante/.vim/plugged/nerdtree/lib/nerdtree/event.vim"
line 1: "CLASS: Event
line 2: "============================================================
line 3: let s:Event = {}
line 4: let g:NERDTreeEvent = s:Event
line 5: 
line 6: function! s:Event.New(nerdtree, subject, action, params) abort
finished sourcing /home/Dante/.vim/plugged/nerdtree/lib/nerdtree/event.vim
continuing in nerdtree#loadClassFiles
line 14:     runtime lib/nerdtree/notifier.vim
Searching for "lib/nerdtree/notifier.vim" in "/home/Dante/.vim,/home/Dante/.vim/plugged/onedark.vim,/home/Dante/.vim/plugged/onehalf/vim,/home/Dante/.vim/plugged/gruvbox,/home/Dante/.vim/plugged/lightline.vim,/home/Dante/.vim/plugged/vim-tmux-navigator,/home/Dante/.vim/plugged/vimtex,/home/Dante/.vim/plugged/nerdtree,/home/Dante/.vim/plugged/fzf,/home/Dante/.vim/plugged/fzf.vim,/home/Dante/.vim/plugged/vim-wayland-clipboard,/home/Dante/.vim/plugged/coc.nvim,/home/Dante/.vim/plugged/vim-obsession,/usr/share/vim/vimfiles,/usr/share/vim/vim91,/usr/share/vim/vimfiles/after,/home/Dante/.vim/plugged/vimtex/after,/home/Dante/.vim/after"
Searching for "/home/Dante/.vim/lib/nerdtree/notifier.vim"
Searching for "/home/Dante/.vim/plugged/onedark.vim/lib/nerdtree/notifier.vim"
Searching for "/home/Dante/.vim/plugged/onehalf/vim/lib/nerdtree/notifier.vim"
Searching for "/home/Dante/.vim/plugged/gruvbox/lib/nerdtree/notifier.vim"
Searching for "/home/Dante/.vim/plugged/lightline.vim/lib/nerdtree/notifier.vim"
Searching for "/home/Dante/.vim/plugged/vim-tmux-navigator/lib/nerdtree/notifier.vim"
Searching for "/home/Dante/.vim/plugged/vimtex/lib/nerdtree/notifier.vim"
Searching for "/home/Dante/.vim/plugged/nerdtree/lib/nerdtree/notifier.vim"
chdir(/home/Dante/.vim/plugged/nerdtree/lib/nerdtree)
fchdir() to previous dir
line 14: sourcing "/home/Dante/.vim/plugged/nerdtree/lib/nerdtree/notifier.vim"
line 1: "CLASS: Notifier
line 2: "============================================================
line 3: let s:Notifier = {}
line 4: 
line 5: function! s:Notifier.AddListener(event, funcname)
line 13: 
line 14: function! s:Notifier.NotifyListeners(event, path, nerdtree, params)
line 22: 
line 23: function! s:Notifier.GetListenersMap()
line 29: 
line 30: function! s:Notifier.GetListenersForEvent(name)
line 34: 
line 35: let g:NERDTreePathNotifier = deepcopy(s:Notifier)
finished sourcing /home/Dante/.vim/plugged/nerdtree/lib/nerdtree/notifier.vim
continuing in nerdtree#loadClassFiles
nerdtree#loadClassFiles returning #0

continuing in /home/Dante/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 145: 
line 146: " SECTION: Commands {{{1
line 147: "============================================================
line 148: call nerdtree#ui_glue#setupCommands()
Searching for "autoload/nerdtree/ui_glue.vim" in "/home/Dante/.vim,/home/Dante/.vim/plugged/onedark.vim,/home/Dante/.vim/plugged/onehalf/vim,/home/Dante/.vim/plugged/gruvbox,/home/Dante/.vim/plugged/lightline.vim,/home/Dante/.vim/plugged/vim-tmux-navigator,/home/Dante/.vim/plugged/vimtex,/home/Dante/.vim/plugged/nerdtree,/home/Dante/.vim/plugged/fzf,/home/Dante/.vim/plugged/fzf.vim,/home/Dante/.vim/plugged/vim-wayland-clipboard,/home/Dante/.vim/plugged/coc.nvim,/home/Dante/.vim/plugged/vim-obsession,/usr/share/vim/vimfiles,/usr/share/vim/vim91,/usr/share/vim/vimfiles/after,/home/Dante/.vim/plugged/vimtex/after,/home/Dante/.vim/after"
Searching for "/home/Dante/.vim/autoload/nerdtree/ui_glue.vim"
Searching for "/home/Dante/.vim/plugged/onedark.vim/autoload/nerdtree/ui_glue.vim"
Searching for "/home/Dante/.vim/plugged/onehalf/vim/autoload/nerdtree/ui_glue.vim"
Searching for "/home/Dante/.vim/plugged/gruvbox/autoload/nerdtree/ui_glue.vim"
Searching for "/home/Dante/.vim/plugged/lightline.vim/autoload/nerdtree/ui_glue.vim"
Searching for "/home/Dante/.vim/plugged/vim-tmux-navigator/autoload/nerdtree/ui_glue.vim"
Searching for "/home/Dante/.vim/plugged/vimtex/autoload/nerdtree/ui_glue.vim"
Searching for "/home/Dante/.vim/plugged/nerdtree/autoload/nerdtree/ui_glue.vim"
chdir(/home/Dante/.vim/plugged/nerdtree/autoload/nerdtree)
fchdir() to previous dir
line 148: sourcing "/home/Dante/.vim/plugged/nerdtree/autoload/nerdtree/ui_glue.vim"
line 1: if exists('g:loaded_nerdtree_ui_glue_autoload')
line 2:     finish
line 3: endif
line 4: let g:loaded_nerdtree_ui_glue_autoload = 1
line 5: 
line 6: " FUNCTION: nerdtree#ui_glue#createDefaultBindings() {{{1
line 7: function! nerdtree#ui_glue#createDefaultBindings() abort
line 85: 
line 86: 
line 87: "SECTION: Interface bindings {{{1
line 88: "============================================================
line 89: 
line 90: "FUNCTION: s:customOpenFile() {{{1
line 91: " Open file node with the 'custom' key, initially <CR>.
line 92: function! s:customOpenFile(node) abort
line 95: 
line 96: "FUNCTION: s:customOpenDir() {{{1
line 97: " Open directory node with the 'custom' key, initially <CR>.
line 98: function! s:customOpenDir(node) abort
line 101: 
line 102: "FUNCTION: s:customOpenBookmark() {{{1
line 103: " Open bookmark node with the 'custom' key, initially <CR>.
line 104: function! s:customOpenBookmark(node) abort
line 111: 
line 112: "FUNCTION: s:initCustomOpenArgs() {{{1
line 113: function! s:initCustomOpenArgs() abort
line 125: 
line 126: "FUNCTION: s:activateAll() {{{1
line 127: "handle the user activating the updir line
line 128: function! s:activateAll() abort
line 133: 
line 134: " FUNCTION: s:activateDirNode(directoryNode, options) {{{1
line 135: " Open a directory with optional options
line 136: function! s:activateDirNode(directoryNode, ...) abort
line 145: 
line 146: "FUNCTION: s:activateFileNode() {{{1
line 147: "handle the user activating a tree node
line 148: function! s:activateFileNode(node) abort
line 151: 
line 152: "FUNCTION: s:activateBookmark(bookmark) {{{1
line 153: "handle the user activating a bookmark
line 154: function! s:activateBookmark(bm) abort
line 157: 
line 158: " FUNCTION: nerdtree#ui_glue#bookmarkNode(name) {{{1
line 159: " Associate the current node with the given name
line 160: function! nerdtree#ui_glue#bookmarkNode(...) abort
line 177: 
line 178: " FUNCTION: s:chCwd(node) {{{1
line 179: function! s:chCwd(node) abort
line 186: 
line 187: " FUNCTION: s:chRoot(node) {{{1
line 188: " changes the current root to the selected one
line 189: function! s:chRoot(node) abort
line 192: 
line 193: " FUNCTION: s:nerdtree#ui_glue#chRootCwd() {{{1
line 194: " Change the NERDTree root to match the current working directory.
line 195: function! nerdtree#ui_glue#chRootCwd() abort
line 198: 
line 199: " FUNCTION: nnerdtree#ui_glue#clearBookmarks(bookmarks) {{{1
line 200: function! nerdtree#ui_glue#clearBookmarks(bookmarks) abort
line 215: 
line 216: " FUNCTION: s:closeChildren(node) {{{1
line 217: " closes all childnodes of the current node
line 218: function! s:closeChildren(node) abort
line 223: 
line 224: " FUNCTION: s:closeCurrentDir(node) {{{1
line 225: " Close the parent directory of the current node.
line 226: function! s:closeCurrentDir(node) abort
line 248: 
line 249: " FUNCTION: s:closeTreeWindow() {{{1
line 250: " close the tree window
line 251: function! s:closeTreeWindow() abort
line 262: 
line 263: " FUNCTION: s:deleteBookmark(bookmark) {{{1
line 264: " Prompt the user to confirm the deletion of the selected bookmark.
line 265: function! s:deleteBookmark(bookmark) abort
line 288: 
line 289: " FUNCTION: s:displayHelp() {{{1
line 290: " toggles the help display
line 291: function! s:displayHelp() abort
line 296: 
line 297: " FUNCTION: s:findAndRevealPath(pathStr) {{{1
line 298: function! s:findAndRevealPath(pathStr) abort
line 349: 
line 350: "FUNCTION: s:handleLeftClick() {{{1
line 351: "Checks if the click should open the current node
line 352: function! s:handleLeftClick() abort
line 385: 
line 386: " FUNCTION: s:handleMiddleMouse() {{{1
line 387: function! s:handleMiddleMouse() abort
line 406: 
line 407: " FUNCTION: nerdtree#ui_glue#invokeKeyMap(key) {{{1
line 408: "this is needed since I cant figure out how to invoke dict functions from a
line 409: "key map
line 410: function! nerdtree#ui_glue#invokeKeyMap(key) abort
line 413: 
line 414: " FUNCTION: s:jumpToFirstChild(node) {{{1
line 415: function! s:jumpToFirstChild(node) abort
line 418: 
line 419: " FUNCTION: s:jumpToLastChild(node) {{{1
line 420: function! s:jumpToLastChild(node) abort
line 423: 
line 424: " FUNCTION: s:jumpToChild(node, last) {{{1
line 425: " Jump to the first or last child node at the same file system level.
line 426: "
line 427: " Args:
line 428: " node: the node on which the cursor currently sits
line 429: " last: 1 (true) if jumping to last child, 0 (false) if jumping to first
line 430: function! s:jumpToChild(node, last) abort
line 445: 
line 446: " FUNCTION: s:jumpToParent(node) {{{1
line 447: " Move the cursor to the parent of the specified node.  For a cascade, move to
line 448: " the parent of the cascade's first node.  At the root node, do nothing.
line 449: function! s:jumpToParent(node) abort
line 464: 
line 465: " FUNCTION: s:jumpToRoot() {{{1
line 466: " moves the cursor to the root node
line 467: function! s:jumpToRoot() abort
line 471: 
line 472: " FUNCTION: s:jumpToNextSibling(node) {{{1
line 473: function! s:jumpToNextSibling(node) abort
line 476: 
line 477: " FUNCTION: s:jumpToPrevSibling(node) {{{1
line 478: function! s:jumpToPrevSibling(node) abort
line 481: 
line 482: " FUNCTION: s:jumpToSibling(node, forward) {{{1
line 483: " Move the cursor to the next or previous node at the same file system level.
line 484: "
line 485: " Args:
line 486: " node: the node on which the cursor currently sits
line 487: " forward: 0 to jump to previous sibling, 1 to jump to next sibling
line 488: function! s:jumpToSibling(node, forward) abort
line 499: 
line 500: " FUNCTION: s:jumpToBookmarks() {{{1
line 501: " moves the cursor to the bookmark table
line 502: function! s:jumpToBookmarks() abort
line 514: 
line 515: " FUNCTION: nerdtree#ui_glue#openBookmark(name) {{{1
line 516: " Open the Bookmark that has the specified name. This function provides the
line 517: " implementation for the :OpenBookmark command.
line 518: function! nerdtree#ui_glue#openBookmark(name) abort
line 532: 
line 533: " FUNCTION: s:openHSplit(target) {{{1
line 534: function! s:openHSplit(target) abort
line 537: 
line 538: " FUNCTION: s:openVSplit(target) {{{1
line 539: function! s:openVSplit(target) abort
line 542: 
line 543: "FUNCTION: s:openHSplitBookmark(bookmark) {{{1
line 544: "handle the user activating a bookmark
line 545: function! s:openHSplitBookmark(bm) abort
line 548: 
line 549: "FUNCTION: s:openVSplitBookmark(bookmark) {{{1
line 550: "handle the user activating a bookmark
line 551: function! s:openVSplitBookmark(bm) abort
line 554: 
line 555: " FUNCTION: s:previewHSplitBookmark(bookmark) {{{1
line 556: function! s:previewNodeHSplitBookmark(bookmark) abort
line 559: 
line 560: " FUNCTION: s:previewVSplitBookmark(bookmark) {{{1
line 561: function! s:previewNodeVSplitBookmark(bookmark) abort
line 564: 
line 565: " FUNCTION: s:openExplorer(node) {{{1
line 566: function! s:openExplorer(node) abort
line 569: 
line 570: " FUNCTION: s:openInNewTab(target) {{{1
line 571: function! s:openInNewTab(target) abort
line 575: 
line 576: " FUNCTION: s:openInNewTabSilent(target) {{{1
line 577: function! s:openInNewTabSilent(target) abort
line 581: 
line 582: " FUNCTION: s:openNodeRecursively(node) {{{1
line 583: function! s:openNodeRecursively(node) abort
line 589: 
line 590: " FUNCTION: s:previewBookmark(bookmark) {{{1
line 591: function! s:previewBookmark(bookmark) abort
line 598: 
line 599: "FUNCTION: s:previewNodeCurrent(node) {{{1
line 600: function! s:previewNodeCurrent(node) abort
line 603: 
line 604: "FUNCTION: s:previewNodeHSplit(node) {{{1
line 605: function! s:previewNodeHSplit(node) abort
line 608: 
line 609: "FUNCTION: s:previewNodeVSplit(node) {{{1
line 610: function! s:previewNodeVSplit(node) abort
line 613: 
line 614: " FUNCTION: nerdtree#ui_glue#revealBookmark(name) {{{1
line 615: " put the cursor on the node associate with the given name
line 616: function! nerdtree#ui_glue#revealBookmark(name) abort
line 624: 
line 625: " FUNCTION: s:refreshRoot() {{{1
line 626: " Reloads the current root. All nodes below this will be lost and the root dir
line 627: " will be reloaded.
line 628: function! s:refreshRoot() abort
line 642: 
line 643: " FUNCTION: s:refreshCurrent(node) {{{1
line 644: " refreshes the root for the current node
line 645: function! s:refreshCurrent(node) abort
line 656: 
line 657: " FUNCTION: nerdtree#ui_glue#setupCommands() {{{1
line 658: function! nerdtree#ui_glue#setupCommands() abort
line 670: 
line 671: " Function: s:SID()   {{{1
line 672: function! s:SID() abort
line 678: 
line 679: " FUNCTION: s:showMenu(node) {{{1
line 680: function! s:showMenu(node) abort
line 684: 
line 685: " FUNCTION: s:toggleIgnoreFilter() {{{1
line 686: function! s:toggleIgnoreFilter() abort
line 689: 
line 690: " FUNCTION: s:toggleShowBookmarks() {{{1
line 691: function! s:toggleShowBookmarks() abort
line 694: 
line 695: " FUNCTION: s:toggleShowFiles() {{{1
line 696: function! s:toggleShowFiles() abort
line 699: 
line 700: " FUNCTION: s:toggleShowHidden() {{{1
line 701: " toggles the display of hidden files
line 702: function! s:toggleShowHidden() abort
line 705: 
line 706: " FUNCTION: s:toggleShowFileLines() {{{1
line 707: " toggles the display of hidden files
line 708: function! s:toggleShowFileLines() abort
line 711: 
line 712: " FUNCTION: s:toggleZoom() {{{1
line 713: function! s:toggleZoom() abort
line 716: 
line 717: " FUNCTION: nerdtree#ui_glue#upDir(preserveState) {{{1
line 718: " Move the NERDTree up one level.
line 719: "
line 720: " Args:
line 721: " preserveState: if 1, the current root is left open when the new tree is
line 722: " rendered; if 0, the current root node is closed
line 723: function! nerdtree#ui_glue#upDir(preserveState) abort
line 745: 
line 746: " FUNCTION: s:upDirCurrentRootOpen() {{{1
line 747: function! s:upDirCurrentRootOpen() abort
line 750: 
line 751: " FUNCTION: s:upDirCurrentRootClosed() {{{1
line 752: function! s:upDirCurrentRootClosed() abort
line 755: 
line 756: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/Dante/.vim/plugged/nerdtree/autoload/nerdtree/ui_glue.vim
continuing in /home/Dante/.vim/plugged/nerdtree/plugin/NERD_tree.vim
calling nerdtree#ui_glue#setupCommands()

line 1:     command! -n=? -complete=dir -bar NERDTree :call g:NERDTreeCreator.CreateTabTree('<args>')
line 2:     command! -n=? -complete=dir -bar NERDTreeToggle :call g:NERDTreeCreator.ToggleTabTree('<args>')
line 3:     command! -n=? -complete=dir -bar NERDTreeExplore :call g:NERDTreeCreator.CreateExploreTree('<args>')
line 4:     command! -n=0 -bar NERDTreeClose :call g:NERDTree.Close()
line 5:     command! -n=1 -complete=customlist,nerdtree#completeBookmarks -bar NERDTreeFromBookmark call g:NERDTreeCreator.CreateTabTree('<args>')
line 6:     command! -n=0 -bar NERDTreeMirror call g:NERDTreeCreator.CreateMirror()
line 7:     command! -n=? -complete=file -bar NERDTreeFind call s:findAndRevealPath('<args>')
line 8:     command! -n=0 -bar NERDTreeRefreshRoot call s:refreshRoot()
line 9:     command! -n=0 -bar NERDTreeFocus call NERDTreeFocus()
line 10:     command! -n=0 -bar NERDTreeCWD call NERDTreeCWD()
nerdtree#ui_glue#setupCommands returning #0

continuing in /home/Dante/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 149: 
line 150: 
line 151: " SECTION: Auto commands {{{1
line 152: "============================================================
line 153: augroup NERDTree
line 154:     "Save the cursor position whenever we close the nerd tree
line 155:     exec 'autocmd BufLeave,WinLeave '. g:NERDTreeCreator.BufNamePrefix() .'* call nerdtree#onBufLeave()'
calling 186()

line 1:     return 'NERD_tree_'
186 returning 'NERD_tree_'

continuing in /home/Dante/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 155: autocmd BufLeave,WinLeave NERD_tree_* call nerdtree#onBufLeave()
line 156: 
line 157:     "disallow insert mode in the NERDTree
line 158:     exec 'autocmd BufEnter,WinEnter '. g:NERDTreeCreator.BufNamePrefix() .'* stopinsert'
calling 186()

line 1:     return 'NERD_tree_'
186 returning 'NERD_tree_'

continuing in /home/Dante/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 158: autocmd BufEnter,WinEnter NERD_tree_* stopinsert
line 159: augroup END
line 160: 
line 161: if g:NERDTreeHijackNetrw
line 162:     augroup NERDTreeHijackNetrw
line 163:         autocmd VimEnter * silent! autocmd! FileExplorer
line 164:         au BufEnter,VimEnter * call nerdtree#checkForBrowse(expand('<amatch>'))
line 165:     augroup END
line 166: endif
line 167: 
line 168: if g:NERDTreeChDirMode ==# 3
line 169:     augroup NERDTreeChDirOnTabSwitch
line 170:         autocmd TabEnter * if g:NERDTree.ExistsForTab()|call g:NERDTree.ForCurrentTab().getRoot().path.changeToDir()|endif
line 171:     augroup END
line 172: endif
line 173: 
line 174: " SECTION: Public API {{{1
line 175: "============================================================
line 176: function! NERDTreeAddMenuItem(options)
line 179: 
line 180: function! NERDTreeAddMenuSeparator(...)
line 184: 
line 185: function! NERDTreeAddSubmenu(options)
line 188: 
line 189: function! NERDTreeAddKeyMap(options)
line 192: 
line 193: function! NERDTreeRender()
line 196: 
line 197: function! NERDTreeFocus()
line 204: 
line 205: function! NERDTreeCWD()
line 229: 
line 230: function! NERDTreeAddPathFilter(callback)
line 233: 
line 234: " SECTION: Post Source Actions {{{1
line 235: call nerdtree#postSourceActions()
calling nerdtree#postSourceActions()

line 1:     call g:NERDTreeBookmark.CacheBookmarks(1)
calling 85(1)

line 1:     if filereadable(g:NERDTreeBookmarksFile)
line 2:         let g:NERDTreeBookmarks = []
line 3:         let g:NERDTreeInvalidBookmarks = []
line 4:         let bookmarkStrings = readfile(g:NERDTreeBookmarksFile)
line 5:         let invalidBookmarksFound = 0
line 6:         for i in bookmarkStrings
line 7: 
line 8:             "ignore blank lines
line 9:             if i !=# ''
line 10: 
line 11:                 let name = substitute(i, '^\(.\{-}\) .*$', '\1', '')
line 12:                 let path = substitute(i, '^.\{-} \(.*\)$', '\1', '')
line 13:                 let path = fnamemodify(path, ':p')
line 14: 
line 15:                 try
line 16:                     let bookmark = s:Bookmark.New(name, g:NERDTreePath.New(path))
line 17:                     call add(g:NERDTreeBookmarks, bookmark)
line 18:                 catch /^NERDTree.InvalidArgumentsError/
line 19:                     call add(g:NERDTreeInvalidBookmarks, i)
line 20:                     let invalidBookmarksFound += 1
line 21:                 endtry
line 22:             endif
line 23:         endfor
line 24:         if invalidBookmarksFound
line 25:             call s:Bookmark.Write()
line 26:             if !a:silent
line 27:                 call nerdtree#echo(invalidBookmarksFound . ' invalid bookmarks were read. See :help NERDTreeInvalidBookmarks for info.')
line 28:             endif
line 29:         endif
line 30:     endif
85 returning #0

continuing in nerdtree#postSourceActions

line 2:     call nerdtree#ui_glue#createDefaultBindings()
calling nerdtree#ui_glue#createDefaultBindings()

line 1:     let s = '<SNR>' . s:SID() . '_'
calling <SNR>39_SID()

line 1:     if !exists('s:sid')
line 2:         let s:sid = matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze_SID$')
line 3:     endif
line 4:     return s:sid
<SNR>39_SID returning '39'

continuing in nerdtree#ui_glue#createDefaultBindings

line 2: 
line 3:     call NERDTreeAddKeyMap({ 'key': '<MiddleMouse>', 'scope': 'all', 'callback': s . 'handleMiddleMouse' })
calling NERDTreeAddKeyMap({'key': '<MiddleMouse>', 'scope': 'all...callback': '<SNR>39_handleMiddleMouse'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling 77({'key': '<MiddleMouse>', 'scope': 'all...callback': '<SNR>39_handleMiddleMouse'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling 71('<MiddleMouse>', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
71 returning {}

continuing in 77

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling 78({'All': function('69'), 'BindAll': fun...leMiddleMouse', 'key': '<MiddleMouse>'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
78 returning #0

continuing in 77

77 returning #0

continuing in NERDTreeAddKeyMap

NERDTreeAddKeyMap returning #0

continuing in nerdtree#ui_glue#createDefaultBindings

line 4:     call NERDTreeAddKeyMap({ 'key': '<LeftRelease>', 'scope': 'all', 'callback': s.'handleLeftClick' })
calling NERDTreeAddKeyMap({'key': '<LeftRelease>', 'scope': 'all', 'callback': '<SNR>39_handleLeftClick'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling 77({'key': '<LeftRelease>', 'scope': 'all', 'callback': '<SNR>39_handleLeftClick'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling 71('<LeftRelease>', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
71 returning {}

continuing in 77

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling 78({'All': function('69'), 'BindAll': fun...ndleLeftClick', 'key': '<LeftRelease>'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
78 returning #0

continuing in 77

77 returning #0

continuing in NERDTreeAddKeyMap

NERDTreeAddKeyMap returning #0

continuing in nerdtree#ui_glue#createDefaultBindings

line 5:     call NERDTreeAddKeyMap({ 'key': '<2-LeftMouse>', 'scope': 'DirNode', 'callback': s.'activateDirNode' })
calling NERDTreeAddKeyMap({'key': '<2-LeftMouse>', 'scope': 'Dir... 'callback': '<SNR>39_activateDirNode'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling 77({'key': '<2-LeftMouse>', 'scope': 'Dir... 'callback': '<SNR>39_activateDirNode'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling 71('<2-LeftMouse>', 'DirNode')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
71 returning {}

continuing in 77

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling 78({'All': function('69'), 'BindAll': fun...tivateDirNode', 'key': '<2-LeftMouse>'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
78 returning #0

continuing in 77

77 returning #0

continuing in NERDTreeAddKeyMap

NERDTreeAddKeyMap returning #0

continuing in nerdtree#ui_glue#createDefaultBindings

line 6:     call NERDTreeAddKeyMap({ 'key': '<2-LeftMouse>', 'scope': 'FileNode', 'callback': s.'activateFileNode' })
calling NERDTreeAddKeyMap({'key': '<2-LeftMouse>', 'scope': 'Fil...'callback': '<SNR>39_activateFileNode'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling 77({'key': '<2-LeftMouse>', 'scope': 'Fil...'callback': '<SNR>39_activateFileNode'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling 71('<2-LeftMouse>', 'FileNode')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
71 returning {}

continuing in 77

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling 78({'All': function('69'), 'BindAll': fun...ivateFileNode', 'key': '<2-LeftMouse>'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
78 returning #0

continuing in 77

77 returning #0

continuing in NERDTreeAddKeyMap

NERDTreeAddKeyMap returning #0

continuing in nerdtree#ui_glue#createDefaultBindings

line 7:     call NERDTreeAddKeyMap({ 'key': '<2-LeftMouse>', 'scope': 'Bookmark', 'callback': s.'activateBookmark' })
calling NERDTreeAddKeyMap({'key': '<2-LeftMouse>', 'scope': 'Boo...'callback': '<SNR>39_activateBookmark'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling 77({'key': '<2-LeftMouse>', 'scope': 'Boo...'callback': '<SNR>39_activateBookmark'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling 71('<2-LeftMouse>', 'Bookmark')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
71 returning {}

continuing in 77

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling 78({'All': function('69'), 'BindAll': fun...ivateBookmark', 'key': '<2-LeftMouse>'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
78 returning #0

continuing in 77

77 returning #0

continuing in NERDTreeAddKeyMap

NERDTreeAddKeyMap returning #0

continuing in nerdtree#ui_glue#createDefaultBindings

line 8:     call NERDTreeAddKeyMap({ 'key': '<2-LeftMouse>', 'scope': 'all', 'callback': s.'activateAll' })
calling NERDTreeAddKeyMap({'key': '<2-LeftMouse>', 'scope': 'all', 'callback': '<SNR>39_activateAll'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling 77({'key': '<2-LeftMouse>', 'scope': 'all', 'callback': '<SNR>39_activateAll'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling 71('<2-LeftMouse>', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
71 returning {}

continuing in 77

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling 78({'All': function('69'), 'BindAll': fun...9_activateAll', 'key': '<2-LeftMouse>'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
78 returning #0

continuing in 77

77 returning #0

continuing in NERDTreeAddKeyMap

NERDTreeAddKeyMap returning #0

continuing in nerdtree#ui_glue#createDefaultBindings

line 9: 
line 10:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapCustomOpen, 'scope':'FileNode', 'callback': s.'customOpenFile'})
calling NERDTreeAddKeyMap({'key': '<CR>', 'scope': 'FileNode', 'callback': '<SNR>39_customOpenFile'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling 77({'key': '<CR>', 'scope': 'FileNode', 'callback': '<SNR>39_customOpenFile'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling 71('<CR>', 'FileNode')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
71 returning {}

continuing in 77

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling 78({'All': function('69'), 'BindAll': fun...<SNR>39_customOpenFile', 'key': '<CR>'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
78 returning #0

continuing in 77

77 returning #0

continuing in NERDTreeAddKeyMap

NERDTreeAddKeyMap returning #0

continuing in nerdtree#ui_glue#createDefaultBindings

line 11:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapCustomOpen, 'scope':'DirNode', 'callback': s.'customOpenDir'})
calling NERDTreeAddKeyMap({'key': '<CR>', 'scope': 'DirNode', 'callback': '<SNR>39_customOpenDir'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling 77({'key': '<CR>', 'scope': 'DirNode', 'callback': '<SNR>39_customOpenDir'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling 71('<CR>', 'DirNode')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
71 returning {}

continuing in 77

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling 78({'All': function('69'), 'BindAll': fun...'<SNR>39_customOpenDir', 'key': '<CR>'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
78 returning #0

continuing in 77

77 returning #0

continuing in NERDTreeAddKeyMap

NERDTreeAddKeyMap returning #0

continuing in nerdtree#ui_glue#createDefaultBindings

line 12:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapCustomOpen, 'scope':'Bookmark', 'callback': s.'customOpenBookmark'})
calling NERDTreeAddKeyMap({'key': '<CR>', 'scope': 'Bookmark', 'callback': '<SNR>39_customOpenBookmark'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling 77({'key': '<CR>', 'scope': 'Bookmark', 'callback': '<SNR>39_customOpenBookmark'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling 71('<CR>', 'Bookmark')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
71 returning {}

continuing in 77

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling 78({'All': function('69'), 'BindAll': fun...>39_customOpenBookmark', 'key': '<CR>'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
78 returning #0

continuing in 77

77 returning #0

continuing in NERDTreeAddKeyMap

NERDTreeAddKeyMap returning #0

continuing in nerdtree#ui_glue#createDefaultBindings

line 13:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapCustomOpen, 'scope':'all', 'callback': s.'activateAll' })
calling NERDTreeAddKeyMap({'key': '<CR>', 'scope': 'all', 'callback': '<SNR>39_activateAll'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling 77({'key': '<CR>', 'scope': 'all', 'callback': '<SNR>39_activateAll'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling 71('<CR>', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
71 returning {}

continuing in 77

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling 78({'All': function('69'), 'BindAll': fun...: '<SNR>39_activateAll', 'key': '<CR>'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
78 returning #0

continuing in 77

77 returning #0

continuing in NERDTreeAddKeyMap

NERDTreeAddKeyMap returning #0

continuing in nerdtree#ui_glue#createDefaultBindings

line 14: 
line 15:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapActivateNode, 'scope': 'DirNode', 'callback': s.'activateDirNode' })
calling NERDTreeAddKeyMap({'key': 'o', 'scope': 'DirNode', 'callback': '<SNR>39_activateDirNode'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling 77({'key': 'o', 'scope': 'DirNode', 'callback': '<SNR>39_activateDirNode'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling 71('o', 'DirNode')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
71 returning {}

continuing in 77

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling 78({'All': function('69'), 'BindAll': fun... '<SNR>39_activateDirNode', 'key': 'o'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
78 returning #0

continuing in 77

77 returning #0

continuing in NERDTreeAddKeyMap

NERDTreeAddKeyMap returning #0

continuing in nerdtree#ui_glue#createDefaultBindings

line 16:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapActivateNode, 'scope': 'FileNode', 'callback': s.'activateFileNode' })
calling NERDTreeAddKeyMap({'key': 'o', 'scope': 'FileNode', 'callback': '<SNR>39_activateFileNode'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling 77({'key': 'o', 'scope': 'FileNode', 'callback': '<SNR>39_activateFileNode'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling 71('o', 'FileNode')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
71 returning {}

continuing in 77

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling 78({'All': function('69'), 'BindAll': fun...'<SNR>39_activateFileNode', 'key': 'o'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
78 returning #0

continuing in 77

77 returning #0

continuing in NERDTreeAddKeyMap

NERDTreeAddKeyMap returning #0

continuing in nerdtree#ui_glue#createDefaultBindings

line 17:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapActivateNode, 'scope': 'Bookmark', 'callback': s.'activateBookmark' })
calling NERDTreeAddKeyMap({'key': 'o', 'scope': 'Bookmark', 'callback': '<SNR>39_activateBookmark'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling 77({'key': 'o', 'scope': 'Bookmark', 'callback': '<SNR>39_activateBookmark'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling 71('o', 'Bookmark')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
71 returning {}

continuing in 77

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling 78({'All': function('69'), 'BindAll': fun...'<SNR>39_activateBookmark', 'key': 'o'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
78 returning #0

continuing in 77

77 returning #0

continuing in NERDTreeAddKeyMap

NERDTreeAddKeyMap returning #0

continuing in nerdtree#ui_glue#createDefaultBindings

line 18:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreview, 'scope': 'Bookmark', 'callback': s.'previewBookmark' })
calling NERDTreeAddKeyMap({'key': 'go', 'scope': 'Bookmark', 'callback': '<SNR>39_previewBookmark'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling 77({'key': 'go', 'scope': 'Bookmark', 'callback': '<SNR>39_previewBookmark'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling 71('go', 'Bookmark')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
71 returning {}

continuing in 77

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling 78({'All': function('69'), 'BindAll': fun...'<SNR>39_previewBookmark', 'key': 'go'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
78 returning #0

continuing in 77

77 returning #0

continuing in NERDTreeAddKeyMap

NERDTreeAddKeyMap returning #0

continuing in nerdtree#ui_glue#createDefaultBindings

line 19:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapActivateNode, 'scope': 'all', 'callback': s.'activateAll' })
calling NERDTreeAddKeyMap({'key': 'o', 'scope': 'all', 'callback': '<SNR>39_activateAll'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling 77({'key': 'o', 'scope': 'all', 'callback': '<SNR>39_activateAll'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling 71('o', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
71 returning {}

continuing in 77

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling 78({'All': function('69'), 'BindAll': fun...ck': '<SNR>39_activateAll', 'key': 'o'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
78 returning #0

continuing in 77

77 returning #0

continuing in NERDTreeAddKeyMap

NERDTreeAddKeyMap returning #0

continuing in nerdtree#ui_glue#createDefaultBindings

line 20: 
line 21:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenSplit, 'scope': 'FileNode', 'callback': s.'openHSplit' })
calling NERDTreeAddKeyMap({'key': 'i', 'scope': 'FileNode', 'callback': '<SNR>39_openHSplit'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling 77({'key': 'i', 'scope': 'FileNode', 'callback': '<SNR>39_openHSplit'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling 71('i', 'FileNode')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
71 returning {}

continuing in 77

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling 78({'All': function('69'), 'BindAll': fun...ack': '<SNR>39_openHSplit', 'key': 'i'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
78 returning #0

continuing in 77

77 returning #0

continuing in NERDTreeAddKeyMap

NERDTreeAddKeyMap returning #0

continuing in nerdtree#ui_glue#createDefaultBindings

line 22:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenSplit, 'scope': 'Bookmark', 'callback': s.'openHSplitBookmark' })
calling NERDTreeAddKeyMap({'key': 'i', 'scope': 'Bookmark', 'callback': '<SNR>39_openHSplitBookmark'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling 77({'key': 'i', 'scope': 'Bookmark', 'callback': '<SNR>39_openHSplitBookmark'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling 71('i', 'Bookmark')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
71 returning {}

continuing in 77

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling 78({'All': function('69'), 'BindAll': fun...SNR>39_openHSplitBookmark', 'key': 'i'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
78 returning #0

continuing in 77

77 returning #0

continuing in NERDTreeAddKeyMap

NERDTreeAddKeyMap returning #0

continuing in nerdtree#ui_glue#createDefaultBindings

line 23:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenVSplit, 'scope': 'FileNode', 'callback': s.'openVSplit' })
calling NERDTreeAddKeyMap({'key': 's', 'scope': 'FileNode', 'callback': '<SNR>39_openVSplit'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling 77({'key': 's', 'scope': 'FileNode', 'callback': '<SNR>39_openVSplit'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling 71('s', 'FileNode')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
71 returning {}

continuing in 77

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling 78({'All': function('69'), 'BindAll': fun...ack': '<SNR>39_openVSplit', 'key': 's'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
78 returning #0

continuing in 77

77 returning #0

continuing in NERDTreeAddKeyMap

NERDTreeAddKeyMap returning #0

continuing in nerdtree#ui_glue#createDefaultBindings

line 24:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenVSplit, 'scope': 'Bookmark', 'callback': s.'openVSplitBookmark' })
calling NERDTreeAddKeyMap({'key': 's', 'scope': 'Bookmark', 'callback': '<SNR>39_openVSplitBookmark'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling 77({'key': 's', 'scope': 'Bookmark', 'callback': '<SNR>39_openVSplitBookmark'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling 71('s', 'Bookmark')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
71 returning {}

continuing in 77

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling 78({'All': function('69'), 'BindAll': fun...SNR>39_openVSplitBookmark', 'key': 's'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
78 returning #0

continuing in 77

77 returning #0

continuing in NERDTreeAddKeyMap

NERDTreeAddKeyMap returning #0

continuing in nerdtree#ui_glue#createDefaultBindings

line 25: 
line 26:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreview, 'scope': 'FileNode', 'callback': s.'previewNodeCurrent' })
calling NERDTreeAddKeyMap({'key': 'go', 'scope': 'FileNode', 'callback': '<SNR>39_previewNodeCurrent'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling 77({'key': 'go', 'scope': 'FileNode', 'callback': '<SNR>39_previewNodeCurrent'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling 71('go', 'FileNode')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
71 returning {}

continuing in 77

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling 78({'All': function('69'), 'BindAll': fun...NR>39_previewNodeCurrent', 'key': 'go'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
78 returning #0

continuing in 77

77 returning #0

continuing in NERDTreeAddKeyMap

NERDTreeAddKeyMap returning #0

continuing in nerdtree#ui_glue#createDefaultBindings

line 27:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreviewSplit, 'scope': 'FileNode', 'callback': s.'previewNodeHSplit' })
calling NERDTreeAddKeyMap({'key': 'gi', 'scope': 'FileNode', 'callback': '<SNR>39_previewNodeHSplit'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling 77({'key': 'gi', 'scope': 'FileNode', 'callback': '<SNR>39_previewNodeHSplit'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling 71('gi', 'FileNode')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
71 returning {}

continuing in 77

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling 78({'All': function('69'), 'BindAll': fun...SNR>39_previewNodeHSplit', 'key': 'gi'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
78 returning #0

continuing in 77

77 returning #0

continuing in NERDTreeAddKeyMap

NERDTreeAddKeyMap returning #0

continuing in nerdtree#ui_glue#createDefaultBindings

line 28:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreviewSplit, 'scope': 'Bookmark', 'callback': s.'previewNodeHSplitBookmark' })
calling NERDTreeAddKeyMap({'key': 'gi', 'scope': 'Bookmark', 'ca...': '<SNR>39_previewNodeHSplitBookmark'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling 77({'key': 'gi', 'scope': 'Bookmark', 'ca...': '<SNR>39_previewNodeHSplitBookmark'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling 71('gi', 'Bookmark')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
71 returning {}

continuing in 77

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling 78({'All': function('69'), 'BindAll': fun...reviewNodeHSplitBookmark', 'key': 'gi'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
78 returning #0

continuing in 77

77 returning #0

continuing in NERDTreeAddKeyMap

NERDTreeAddKeyMap returning #0

continuing in nerdtree#ui_glue#createDefaultBindings

line 29:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreviewVSplit, 'scope': 'FileNode', 'callback': s.'previewNodeVSplit' })
calling NERDTreeAddKeyMap({'key': 'gs', 'scope': 'FileNode', 'callback': '<SNR>39_previewNodeVSplit'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling 77({'key': 'gs', 'scope': 'FileNode', 'callback': '<SNR>39_previewNodeVSplit'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling 71('gs', 'FileNode')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
71 returning {}

continuing in 77

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling 78({'All': function('69'), 'BindAll': fun...SNR>39_previewNodeVSplit', 'key': 'gs'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
78 returning #0

continuing in 77

77 returning #0

continuing in NERDTreeAddKeyMap

NERDTreeAddKeyMap returning #0

continuing in nerdtree#ui_glue#createDefaultBindings

line 30:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreviewVSplit, 'scope': 'Bookmark', 'callback': s.'previewNodeVSplitBookmark' })
calling NERDTreeAddKeyMap({'key': 'gs', 'scope': 'Bookmark', 'ca...': '<SNR>39_previewNodeVSplitBookmark'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling 77({'key': 'gs', 'scope': 'Bookmark', 'ca...': '<SNR>39_previewNodeVSplitBookmark'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling 71('gs', 'Bookmark')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
71 returning {}

continuing in 77

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling 78({'All': function('69'), 'BindAll': fun...reviewNodeVSplitBookmark', 'key': 'gs'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
78 returning #0

continuing in 77

77 returning #0

continuing in NERDTreeAddKeyMap

NERDTreeAddKeyMap returning #0

continuing in nerdtree#ui_glue#createDefaultBindings

line 31: 
line 32:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenRecursively, 'scope': 'DirNode', 'callback': s.'openNodeRecursively' })
calling NERDTreeAddKeyMap({'key': 'O', 'scope': 'DirNode', 'callback': '<SNR>39_openNodeRecursively'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling 77({'key': 'O', 'scope': 'DirNode', 'callback': '<SNR>39_openNodeRecursively'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling 71('O', 'DirNode')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
71 returning {}

continuing in 77

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling 78({'All': function('69'), 'BindAll': fun...NR>39_openNodeRecursively', 'key': 'O'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
78 returning #0

continuing in 77

77 returning #0

continuing in NERDTreeAddKeyMap

NERDTreeAddKeyMap returning #0

continuing in nerdtree#ui_glue#createDefaultBindings

line 33: 
line 34:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapUpdir, 'scope': 'all', 'callback': s . 'upDirCurrentRootClosed' })
calling NERDTreeAddKeyMap({'key': 'u', 'scope': 'all', 'callback': '<SNR>39_upDirCurrentRootClosed'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling 77({'key': 'u', 'scope': 'all', 'callback': '<SNR>39_upDirCurrentRootClosed'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling 71('u', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
71 returning {}

continuing in 77

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling 78({'All': function('69'), 'BindAll': fun...39_upDirCurrentRootClosed', 'key': 'u'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
78 returning #0

continuing in 77

77 returning #0

continuing in NERDTreeAddKeyMap

NERDTreeAddKeyMap returning #0

continuing in nerdtree#ui_glue#createDefaultBindings

line 35:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapUpdirKeepOpen, 'scope': 'all', 'callback': s . 'upDirCurrentRootOpen' })
calling NERDTreeAddKeyMap({'key': 'U', 'scope': 'all', 'callback': '<SNR>39_upDirCurrentRootOpen'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling 77({'key': 'U', 'scope': 'all', 'callback': '<SNR>39_upDirCurrentRootOpen'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling 71('U', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
71 returning {}

continuing in 77

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling 78({'All': function('69'), 'BindAll': fun...R>39_upDirCurrentRootOpen', 'key': 'U'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
78 returning #0

continuing in 77

77 returning #0

continuing in NERDTreeAddKeyMap

NERDTreeAddKeyMap returning #0

continuing in nerdtree#ui_glue#createDefaultBindings

line 36:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapChangeRoot, 'scope': 'Node', 'callback': s . 'chRoot' })
calling NERDTreeAddKeyMap({'key': 'C', 'scope': 'Node', 'callback': '<SNR>39_chRoot'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling 77({'key': 'C', 'scope': 'Node', 'callback': '<SNR>39_chRoot'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling 71('C', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
71 returning {}

continuing in 77

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling 78({'All': function('69'), 'BindAll': fun...allback': '<SNR>39_chRoot', 'key': 'C'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
78 returning #0

continuing in 77

77 returning #0

continuing in NERDTreeAddKeyMap

NERDTreeAddKeyMap returning #0

continuing in nerdtree#ui_glue#createDefaultBindings

line 37: 
line 38:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapChdir, 'scope': 'Node', 'callback': s.'chCwd' })
calling NERDTreeAddKeyMap({'key': 'cd', 'scope': 'Node', 'callback': '<SNR>39_chCwd'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling 77({'key': 'cd', 'scope': 'Node', 'callback': '<SNR>39_chCwd'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling 71('cd', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
71 returning {}

continuing in 77

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling 78({'All': function('69'), 'BindAll': fun...allback': '<SNR>39_chCwd', 'key': 'cd'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
78 returning #0

continuing in 77

77 returning #0

continuing in NERDTreeAddKeyMap

NERDTreeAddKeyMap returning #0

continuing in nerdtree#ui_glue#createDefaultBindings

line 39: 
line 40:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapQuit, 'scope': 'all', 'callback': s.'closeTreeWindow' })
calling NERDTreeAddKeyMap({'key': 'q', 'scope': 'all', 'callback': '<SNR>39_closeTreeWindow'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling 77({'key': 'q', 'scope': 'all', 'callback': '<SNR>39_closeTreeWindow'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling 71('q', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
71 returning {}

continuing in 77

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling 78({'All': function('69'), 'BindAll': fun... '<SNR>39_closeTreeWindow', 'key': 'q'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
78 returning #0

continuing in 77

77 returning #0

continuing in NERDTreeAddKeyMap

NERDTreeAddKeyMap returning #0

continuing in nerdtree#ui_glue#createDefaultBindings

line 41: 
line 42:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapCWD, 'scope': 'all', 'callback': 'nerdtree#ui_glue#chRootCwd' })
calling NERDTreeAddKeyMap({'key': 'CD', 'scope': 'all', 'callback': 'nerdtree#ui_glue#chRootCwd'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling 77({'key': 'CD', 'scope': 'all', 'callback': 'nerdtree#ui_glue#chRootCwd'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling 71('CD', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
71 returning {}

continuing in 77

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling 78({'All': function('69'), 'BindAll': fun...rdtree#ui_glue#chRootCwd', 'key': 'CD'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
78 returning #0

continuing in 77

77 returning #0

continuing in NERDTreeAddKeyMap

NERDTreeAddKeyMap returning #0

continuing in nerdtree#ui_glue#createDefaultBindings

line 43: 
line 44:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapRefreshRoot, 'scope': 'all', 'callback': s.'refreshRoot' })
calling NERDTreeAddKeyMap({'key': 'R', 'scope': 'all', 'callback': '<SNR>39_refreshRoot'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling 77({'key': 'R', 'scope': 'all', 'callback': '<SNR>39_refreshRoot'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling 71('R', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
71 returning {}

continuing in 77

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling 78({'All': function('69'), 'BindAll': fun...ck': '<SNR>39_refreshRoot', 'key': 'R'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
78 returning #0

continuing in 77

77 returning #0

continuing in NERDTreeAddKeyMap

NERDTreeAddKeyMap returning #0

continuing in nerdtree#ui_glue#createDefaultBindings

line 45:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapRefresh, 'scope': 'Node', 'callback': s.'refreshCurrent' })
calling NERDTreeAddKeyMap({'key': 'r', 'scope': 'Node', 'callback': '<SNR>39_refreshCurrent'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling 77({'key': 'r', 'scope': 'Node', 'callback': '<SNR>39_refreshCurrent'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling 71('r', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
71 returning {}

continuing in 77

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling 78({'All': function('69'), 'BindAll': fun...: '<SNR>39_refreshCurrent', 'key': 'r'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
78 returning #0

continuing in 77

77 returning #0

continuing in NERDTreeAddKeyMap

NERDTreeAddKeyMap returning #0

continuing in nerdtree#ui_glue#createDefaultBindings

line 46: 
line 47:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapHelp, 'scope': 'all', 'callback': s.'displayHelp' })
calling NERDTreeAddKeyMap({'key': '?', 'scope': 'all', 'callback': '<SNR>39_displayHelp'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling 77({'key': '?', 'scope': 'all', 'callback': '<SNR>39_displayHelp'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling 71('?', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
71 returning {}

continuing in 77

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling 78({'All': function('69'), 'BindAll': fun...ck': '<SNR>39_displayHelp', 'key': '?'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
78 returning #0

continuing in 77

77 returning #0

continuing in NERDTreeAddKeyMap

NERDTreeAddKeyMap returning #0

continuing in nerdtree#ui_glue#createDefaultBindings

line 48:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleZoom, 'scope': 'all', 'callback': s.'toggleZoom' })
calling NERDTreeAddKeyMap({'key': 'A', 'scope': 'all', 'callback': '<SNR>39_toggleZoom'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling 77({'key': 'A', 'scope': 'all', 'callback': '<SNR>39_toggleZoom'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling 71('A', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
71 returning {}

continuing in 77

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling 78({'All': function('69'), 'BindAll': fun...ack': '<SNR>39_toggleZoom', 'key': 'A'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
78 returning #0

continuing in 77

77 returning #0

continuing in NERDTreeAddKeyMap

NERDTreeAddKeyMap returning #0

continuing in nerdtree#ui_glue#createDefaultBindings

line 49:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleHidden, 'scope': 'all', 'callback': s.'toggleShowHidden' })
calling NERDTreeAddKeyMap({'key': 'I', 'scope': 'all', 'callback': '<SNR>39_toggleShowHidden'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling 77({'key': 'I', 'scope': 'all', 'callback': '<SNR>39_toggleShowHidden'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling 71('I', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
71 returning {}

continuing in 77

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling 78({'All': function('69'), 'BindAll': fun...'<SNR>39_toggleShowHidden', 'key': 'I'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
78 returning #0

continuing in 77

77 returning #0

continuing in NERDTreeAddKeyMap

NERDTreeAddKeyMap returning #0

continuing in nerdtree#ui_glue#createDefaultBindings

line 50:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleFilters, 'scope': 'all', 'callback': s.'toggleIgnoreFilter' })
calling NERDTreeAddKeyMap({'key': 'f', 'scope': 'all', 'callback': '<SNR>39_toggleIgnoreFilter'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling 77({'key': 'f', 'scope': 'all', 'callback': '<SNR>39_toggleIgnoreFilter'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling 71('f', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
71 returning {}

continuing in 77

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling 78({'All': function('69'), 'BindAll': fun...SNR>39_toggleIgnoreFilter', 'key': 'f'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
78 returning #0

continuing in 77

77 returning #0

continuing in NERDTreeAddKeyMap

NERDTreeAddKeyMap returning #0

continuing in nerdtree#ui_glue#createDefaultBindings

line 51:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleFiles, 'scope': 'all', 'callback': s.'toggleShowFiles' })
calling NERDTreeAddKeyMap({'key': 'F', 'scope': 'all', 'callback': '<SNR>39_toggleShowFiles'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling 77({'key': 'F', 'scope': 'all', 'callback': '<SNR>39_toggleShowFiles'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling 71('F', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
71 returning {}

continuing in 77

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling 78({'All': function('69'), 'BindAll': fun... '<SNR>39_toggleShowFiles', 'key': 'F'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
78 returning #0

continuing in 77

77 returning #0

continuing in NERDTreeAddKeyMap

NERDTreeAddKeyMap returning #0

continuing in nerdtree#ui_glue#createDefaultBindings

line 52:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleBookmarks, 'scope': 'all', 'callback': s.'toggleShowBookmarks' })
calling NERDTreeAddKeyMap({'key': 'B', 'scope': 'all', 'callback': '<SNR>39_toggleShowBookmarks'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling 77({'key': 'B', 'scope': 'all', 'callback': '<SNR>39_toggleShowBookmarks'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling 71('B', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
71 returning {}

continuing in 77

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling 78({'All': function('69'), 'BindAll': fun...NR>39_toggleShowBookmarks', 'key': 'B'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
78 returning #0

continuing in 77

77 returning #0

continuing in NERDTreeAddKeyMap

NERDTreeAddKeyMap returning #0

continuing in nerdtree#ui_glue#createDefaultBindings

line 53:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleFileLines, 'scope': 'all', 'callback': s.'toggleShowFileLines' })
calling NERDTreeAddKeyMap({'key': 'FL', 'scope': 'all', 'callback': '<SNR>39_toggleShowFileLines'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling 77({'key': 'FL', 'scope': 'all', 'callback': '<SNR>39_toggleShowFileLines'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling 71('FL', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
71 returning {}

continuing in 77

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling 78({'All': function('69'), 'BindAll': fun...R>39_toggleShowFileLines', 'key': 'FL'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
78 returning #0

continuing in 77

77 returning #0

continuing in NERDTreeAddKeyMap

NERDTreeAddKeyMap returning #0

continuing in nerdtree#ui_glue#createDefaultBindings

line 54: 
line 55:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapCloseDir, 'scope': 'Node', 'callback': s.'closeCurrentDir' })
calling NERDTreeAddKeyMap({'key': 'x', 'scope': 'Node', 'callback': '<SNR>39_closeCurrentDir'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling 77({'key': 'x', 'scope': 'Node', 'callback': '<SNR>39_closeCurrentDir'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling 71('x', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
71 returning {}

continuing in 77

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling 78({'All': function('69'), 'BindAll': fun... '<SNR>39_closeCurrentDir', 'key': 'x'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
78 returning #0

continuing in 77

77 returning #0

continuing in NERDTreeAddKeyMap

NERDTreeAddKeyMap returning #0

continuing in nerdtree#ui_glue#createDefaultBindings

line 56:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapCloseChildren, 'scope': 'DirNode', 'callback': s.'closeChildren' })
calling NERDTreeAddKeyMap({'key': 'X', 'scope': 'DirNode', 'callback': '<SNR>39_closeChildren'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling 77({'key': 'X', 'scope': 'DirNode', 'callback': '<SNR>39_closeChildren'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling 71('X', 'DirNode')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
71 returning {}

continuing in 77

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling 78({'All': function('69'), 'BindAll': fun...': '<SNR>39_closeChildren', 'key': 'X'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
78 returning #0

continuing in 77

77 returning #0

continuing in NERDTreeAddKeyMap

NERDTreeAddKeyMap returning #0

continuing in nerdtree#ui_glue#createDefaultBindings

line 57: 
line 58:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapMenu, 'scope': 'Node', 'callback': s.'showMenu' })
calling NERDTreeAddKeyMap({'key': 'm', 'scope': 'Node', 'callback': '<SNR>39_showMenu'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling 77({'key': 'm', 'scope': 'Node', 'callback': '<SNR>39_showMenu'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling 71('m', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
71 returning {}

continuing in 77

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling 78({'All': function('69'), 'BindAll': fun...lback': '<SNR>39_showMenu', 'key': 'm'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
78 returning #0

continuing in 77

77 returning #0

continuing in NERDTreeAddKeyMap

NERDTreeAddKeyMap returning #0

continuing in nerdtree#ui_glue#createDefaultBindings

line 59: 
line 60:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpParent, 'scope': 'Node', 'callback': s.'jumpToParent' })
calling NERDTreeAddKeyMap({'key': 'p', 'scope': 'Node', 'callback': '<SNR>39_jumpToParent'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling 77({'key': 'p', 'scope': 'Node', 'callback': '<SNR>39_jumpToParent'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling 71('p', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
71 returning {}

continuing in 77

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling 78({'All': function('69'), 'BindAll': fun...k': '<SNR>39_jumpToParent', 'key': 'p'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
78 returning #0

continuing in 77

77 returning #0

continuing in NERDTreeAddKeyMap

NERDTreeAddKeyMap returning #0

continuing in nerdtree#ui_glue#createDefaultBindings

line 61:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpFirstChild, 'scope': 'Node', 'callback': s.'jumpToFirstChild' })
calling NERDTreeAddKeyMap({'key': 'K', 'scope': 'Node', 'callback': '<SNR>39_jumpToFirstChild'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling 77({'key': 'K', 'scope': 'Node', 'callback': '<SNR>39_jumpToFirstChild'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling 71('K', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
71 returning {}

continuing in 77

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling 78({'All': function('69'), 'BindAll': fun...'<SNR>39_jumpToFirstChild', 'key': 'K'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
78 returning #0

continuing in 77

77 returning #0

continuing in NERDTreeAddKeyMap

NERDTreeAddKeyMap returning #0

continuing in nerdtree#ui_glue#createDefaultBindings

line 62:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpLastChild, 'scope': 'Node', 'callback': s.'jumpToLastChild' })
calling NERDTreeAddKeyMap({'key': 'J', 'scope': 'Node', 'callback': '<SNR>39_jumpToLastChild'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling 77({'key': 'J', 'scope': 'Node', 'callback': '<SNR>39_jumpToLastChild'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling 71('J', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
71 returning {}

continuing in 77

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling 78({'All': function('69'), 'BindAll': fun... '<SNR>39_jumpToLastChild', 'key': 'J'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
78 returning #0

continuing in 77

77 returning #0

continuing in NERDTreeAddKeyMap

NERDTreeAddKeyMap returning #0

continuing in nerdtree#ui_glue#createDefaultBindings

line 63:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpRoot, 'scope': 'all', 'callback': s.'jumpToRoot' })
calling NERDTreeAddKeyMap({'key': 'P', 'scope': 'all', 'callback': '<SNR>39_jumpToRoot'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling 77({'key': 'P', 'scope': 'all', 'callback': '<SNR>39_jumpToRoot'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling 71('P', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
71 returning {}

continuing in 77

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling 78({'All': function('69'), 'BindAll': fun...ack': '<SNR>39_jumpToRoot', 'key': 'P'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
78 returning #0

continuing in 77

77 returning #0

continuing in NERDTreeAddKeyMap

NERDTreeAddKeyMap returning #0

continuing in nerdtree#ui_glue#createDefaultBindings

line 64:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpNextSibling, 'scope': 'Node', 'callback': s.'jumpToNextSibling' })
calling NERDTreeAddKeyMap({'key': '<C-j>', 'scope': 'Node', 'callback': '<SNR>39_jumpToNextSibling'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling 77({'key': '<C-j>', 'scope': 'Node', 'callback': '<SNR>39_jumpToNextSibling'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling 71('<C-j>', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
71 returning {}

continuing in 77

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling 78({'All': function('69'), 'BindAll': fun...>39_jumpToNextSibling', 'key': '<C-j>'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
78 returning #0

continuing in 77

77 returning #0

continuing in NERDTreeAddKeyMap

NERDTreeAddKeyMap returning #0

continuing in nerdtree#ui_glue#createDefaultBindings

line 65:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpPrevSibling, 'scope': 'Node', 'callback': s.'jumpToPrevSibling' })
calling NERDTreeAddKeyMap({'key': '<C-k>', 'scope': 'Node', 'callback': '<SNR>39_jumpToPrevSibling'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling 77({'key': '<C-k>', 'scope': 'Node', 'callback': '<SNR>39_jumpToPrevSibling'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling 71('<C-k>', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
71 returning {}

continuing in 77

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling 78({'All': function('69'), 'BindAll': fun...>39_jumpToPrevSibling', 'key': '<C-k>'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
78 returning #0

continuing in 77

77 returning #0

continuing in NERDTreeAddKeyMap

NERDTreeAddKeyMap returning #0

continuing in nerdtree#ui_glue#createDefaultBindings

line 66:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpBookmarks, 'scope': 'all', 'callback': s.'jumpToBookmarks' })
calling NERDTreeAddKeyMap({'key': 'gb', 'scope': 'all', 'callback': '<SNR>39_jumpToBookmarks'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling 77({'key': 'gb', 'scope': 'all', 'callback': '<SNR>39_jumpToBookmarks'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling 71('gb', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
71 returning {}

continuing in 77

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling 78({'All': function('69'), 'BindAll': fun...'<SNR>39_jumpToBookmarks', 'key': 'gb'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
78 returning #0

continuing in 77

77 returning #0

continuing in NERDTreeAddKeyMap

NERDTreeAddKeyMap returning #0

continuing in nerdtree#ui_glue#createDefaultBindings

line 67: 
line 68:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenInTab, 'scope': 'Node', 'callback': s . 'openInNewTab' })
calling NERDTreeAddKeyMap({'key': 't', 'scope': 'Node', 'callback': '<SNR>39_openInNewTab'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling 77({'key': 't', 'scope': 'Node', 'callback': '<SNR>39_openInNewTab'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling 71('t', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
71 returning {}

continuing in 77

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling 78({'All': function('69'), 'BindAll': fun...k': '<SNR>39_openInNewTab', 'key': 't'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
78 returning #0

continuing in 77

77 returning #0

continuing in NERDTreeAddKeyMap

NERDTreeAddKeyMap returning #0

continuing in nerdtree#ui_glue#createDefaultBindings

line 69:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenInTabSilent, 'scope': 'Node', 'callback': s . 'openInNewTabSilent' })
calling NERDTreeAddKeyMap({'key': 'T', 'scope': 'Node', 'callback': '<SNR>39_openInNewTabSilent'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling 77({'key': 'T', 'scope': 'Node', 'callback': '<SNR>39_openInNewTabSilent'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling 71('T', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
71 returning {}

continuing in 77

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling 78({'All': function('69'), 'BindAll': fun...SNR>39_openInNewTabSilent', 'key': 'T'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
78 returning #0

continuing in 77

77 returning #0

continuing in NERDTreeAddKeyMap

NERDTreeAddKeyMap returning #0

continuing in nerdtree#ui_glue#createDefaultBindings

line 70:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenInTab, 'scope': 'Bookmark', 'callback': s . 'openInNewTab' })
calling NERDTreeAddKeyMap({'key': 't', 'scope': 'Bookmark', 'callback': '<SNR>39_openInNewTab'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling 77({'key': 't', 'scope': 'Bookmark', 'callback': '<SNR>39_openInNewTab'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling 71('t', 'Bookmark')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
71 returning {}

continuing in 77

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling 78({'All': function('69'), 'BindAll': fun...k': '<SNR>39_openInNewTab', 'key': 't'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
78 returning #0

continuing in 77

77 returning #0

continuing in NERDTreeAddKeyMap

NERDTreeAddKeyMap returning #0

continuing in nerdtree#ui_glue#createDefaultBindings

line 71:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenInTabSilent, 'scope': 'Bookmark', 'callback': s . 'openInNewTabSilent' })
calling NERDTreeAddKeyMap({'key': 'T', 'scope': 'Bookmark', 'callback': '<SNR>39_openInNewTabSilent'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling 77({'key': 'T', 'scope': 'Bookmark', 'callback': '<SNR>39_openInNewTabSilent'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling 71('T', 'Bookmark')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
71 returning {}

continuing in 77

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling 78({'All': function('69'), 'BindAll': fun...SNR>39_openInNewTabSilent', 'key': 'T'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
78 returning #0

continuing in 77

77 returning #0

continuing in NERDTreeAddKeyMap

NERDTreeAddKeyMap returning #0

continuing in nerdtree#ui_glue#createDefaultBindings

line 72: 
line 73:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenExpl, 'scope': 'DirNode', 'callback': s.'openExplorer' })
calling NERDTreeAddKeyMap({'key': 'e', 'scope': 'DirNode', 'callback': '<SNR>39_openExplorer'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling 77({'key': 'e', 'scope': 'DirNode', 'callback': '<SNR>39_openExplorer'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling 71('e', 'DirNode')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
71 returning {}

continuing in 77

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling 78({'All': function('69'), 'BindAll': fun...k': '<SNR>39_openExplorer', 'key': 'e'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
78 returning #0

continuing in 77

77 returning #0

continuing in NERDTreeAddKeyMap

NERDTreeAddKeyMap returning #0

continuing in nerdtree#ui_glue#createDefaultBindings

line 74:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenExpl, 'scope': 'FileNode', 'callback': s.'openExplorer' })
calling NERDTreeAddKeyMap({'key': 'e', 'scope': 'FileNode', 'callback': '<SNR>39_openExplorer'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling 77({'key': 'e', 'scope': 'FileNode', 'callback': '<SNR>39_openExplorer'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling 71('e', 'FileNode')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
71 returning {}

continuing in 77

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling 78({'All': function('69'), 'BindAll': fun...k': '<SNR>39_openExplorer', 'key': 'e'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
78 returning #0

continuing in 77

77 returning #0

continuing in NERDTreeAddKeyMap

NERDTreeAddKeyMap returning #0

continuing in nerdtree#ui_glue#createDefaultBindings

line 75: 
line 76:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapDeleteBookmark, 'scope': 'Bookmark', 'callback': s.'deleteBookmark' })
calling NERDTreeAddKeyMap({'key': 'D', 'scope': 'Bookmark', 'callback': '<SNR>39_deleteBookmark'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling 77({'key': 'D', 'scope': 'Bookmark', 'callback': '<SNR>39_deleteBookmark'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling 71('D', 'Bookmark')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
71 returning {}

continuing in 77

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling 78({'All': function('69'), 'BindAll': fun...: '<SNR>39_deleteBookmark', 'key': 'D'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
78 returning #0

continuing in 77

77 returning #0

continuing in NERDTreeAddKeyMap

NERDTreeAddKeyMap returning #0

continuing in nerdtree#ui_glue#createDefaultBindings

nerdtree#ui_glue#createDefaultBindings returning #0

continuing in nerdtree#postSourceActions

line 3: 
line 4:     "load all nerdtree plugins
line 5:     runtime! nerdtree_plugin/**/*.vim
Searching for "nerdtree_plugin/**/*.vim" in "/home/Dante/.vim,/home/Dante/.vim/plugged/onedark.vim,/home/Dante/.vim/plugged/onehalf/vim,/home/Dante/.vim/plugged/gruvbox,/home/Dante/.vim/plugged/lightline.vim,/home/Dante/.vim/plugged/vim-tmux-navigator,/home/Dante/.vim/plugged/vimtex,/home/Dante/.vim/plugged/nerdtree,/home/Dante/.vim/plugged/fzf,/home/Dante/.vim/plugged/fzf.vim,/home/Dante/.vim/plugged/vim-wayland-clipboard,/home/Dante/.vim/plugged/coc.nvim,/home/Dante/.vim/plugged/vim-obsession,/usr/share/vim/vimfiles,/usr/share/vim/vim91,/usr/share/vim/vimfiles/after,/home/Dante/.vim/plugged/vimtex/after,/home/Dante/.vim/after"
Searching for "/home/Dante/.vim/nerdtree_plugin/**/*.vim"
Searching for "/home/Dante/.vim/plugged/onedark.vim/nerdtree_plugin/**/*.vim"
Searching for "/home/Dante/.vim/plugged/onehalf/vim/nerdtree_plugin/**/*.vim"
Searching for "/home/Dante/.vim/plugged/gruvbox/nerdtree_plugin/**/*.vim"
Searching for "/home/Dante/.vim/plugged/lightline.vim/nerdtree_plugin/**/*.vim"
Searching for "/home/Dante/.vim/plugged/vim-tmux-navigator/nerdtree_plugin/**/*.vim"
Searching for "/home/Dante/.vim/plugged/vimtex/nerdtree_plugin/**/*.vim"
Searching for "/home/Dante/.vim/plugged/nerdtree/nerdtree_plugin/**/*.vim"
chdir(/home/Dante/.vim/plugged/nerdtree/nerdtree_plugin)
fchdir() to previous dir
line 5: sourcing "/home/Dante/.vim/plugged/nerdtree/nerdtree_plugin/exec_menuitem.vim"
line 1: " ============================================================================
line 2: " File:        exec_menuitem.vim
line 3: " Description: plugin for NERD Tree that provides an execute file menu item
line 4: " Maintainer:  Martin Grenfell <martin.grenfell at gmail dot com>
line 5: " License:     This program is free software. It comes without any warranty,
line 6: "              to the extent permitted by applicable law. You can redistribute
line 7: "              it and/or modify it under the terms of the Do What The Fuck You
line 8: "              Want To Public License, Version 2, as published by Sam Hocevar.
line 9: "              See http://sam.zoy.org/wtfpl/COPYING for more details.
line 10: "
line 11: " ============================================================================
line 12: if exists('g:loaded_nerdtree_exec_menuitem')
line 13:     finish
line 14: endif
line 15: let g:loaded_nerdtree_exec_menuitem = 1
line 16: 
line 17: call NERDTreeAddMenuItem({ 'text': '(!)Execute file', 'shortcut': '!', 'callback': 'NERDTreeExecFile', 'isActiveCallback': 'NERDTreeExecFileActive' })
calling NERDTreeAddMenuItem({'callback': 'NERDTreeExecFile', 'shor...iveCallback': 'NERDTreeExecFileActive'})

line 1:     call g:NERDTreeMenuItem.Create(a:options)
calling 62({'callback': 'NERDTreeExecFile', 'shor...iveCallback': 'NERDTreeExecFileActive'})

line 1:     let newMenuItem = copy(self)
line 2: 
line 3:     let newMenuItem.text = a:options['text']
line 4:     let newMenuItem.shortcut = a:options['shortcut']
line 5:     let newMenuItem.children = []
line 6: 
line 7:     let newMenuItem.isActiveCallback = -1
line 8:     if has_key(a:options, 'isActiveCallback')
line 9:         let newMenuItem.isActiveCallback = a:options['isActiveCallback']
line 10:     endif
line 11: 
line 12:     let newMenuItem.callback = -1
line 13:     if has_key(a:options, 'callback')
line 14:         let newMenuItem.callback = a:options['callback']
line 15:     endif
line 16: 
line 17:     if has_key(a:options, 'parent')
line 18:         call add(a:options['parent'].children, newMenuItem)
line 19:     else
line 20:         call add(s:MenuItem.All(), newMenuItem)
calling 60()

line 1:     if !exists('s:menuItems')
line 2:         let s:menuItems = []
line 3:     endif
line 4:     return s:menuItems
60 returning []

continuing in 62

line 21:     endif
line 22: 
line 23:     return newMenuItem
62 returning {'All': function('60'), 'isActiveCallb...reeExecFile', 'Create': function('62')}

continuing in NERDTreeAddMenuItem

NERDTreeAddMenuItem returning #0

continuing in /home/Dante/.vim/plugged/nerdtree/nerdtree_plugin/exec_menuitem.vim

line 22: 
line 23: function! NERDTreeExecFileActive()
line 27: 
line 28: function! NERDTreeExecFile()
finished sourcing /home/Dante/.vim/plugged/nerdtree/nerdtree_plugin/exec_menuitem.vim
continuing in nerdtree#postSourceActions
chdir(/home/Dante/.vim/plugged/nerdtree/nerdtree_plugin)
fchdir() to previous dir
line 5: sourcing "/home/Dante/.vim/plugged/nerdtree/nerdtree_plugin/fs_menu.vim"
line 1: " ============================================================================
line 2: " File:        fs_menu.vim
line 3: " Description: plugin for the NERD Tree that provides a file system menu
line 4: " Maintainer:  Martin Grenfell <martin.grenfell at gmail dot com>
line 5: " License:     This program is free software. It comes without any warranty,
line 6: "              to the extent permitted by applicable law. You can redistribute
line 7: "              it and/or modify it under the terms of the Do What The Fuck You
line 8: "              Want To Public License, Version 2, as published by Sam Hocevar.
line 9: "              See http://sam.zoy.org/wtfpl/COPYING for more details.
line 10: "
line 11: " ============================================================================
line 12: if exists('g:loaded_nerdtree_fs_menu')
line 13:     finish
line 14: endif
line 15: let g:loaded_nerdtree_fs_menu = 1
line 16: 
line 17: "Automatically delete the buffer after deleting or renaming a file
line 18: if !exists('g:NERDTreeAutoDeleteBuffer')
line 19:     let g:NERDTreeAutoDeleteBuffer = 0
line 20: endif
line 21: 
line 22: call NERDTreeAddMenuItem({'text': '(a)dd a childnode', 'shortcut': 'a', 'callback': 'NERDTreeAddNode'})
calling NERDTreeAddMenuItem({'callback': 'NERDTreeAddNode', 'shortcut': 'a', 'text': '(a)dd a childnode'})

line 1:     call g:NERDTreeMenuItem.Create(a:options)
calling 62({'callback': 'NERDTreeAddNode', 'shortcut': 'a', 'text': '(a)dd a childnode'})

line 1:     let newMenuItem = copy(self)
line 2: 
line 3:     let newMenuItem.text = a:options['text']
line 4:     let newMenuItem.shortcut = a:options['shortcut']
line 5:     let newMenuItem.children = []
line 6: 
line 7:     let newMenuItem.isActiveCallback = -1
line 8:     if has_key(a:options, 'isActiveCallback')
line 9:         let newMenuItem.isActiveCallback = a:options['isActiveCallback']
line 10:     endif
line 11: 
line 12:     let newMenuItem.callback = -1
line 13:     if has_key(a:options, 'callback')
line 14:         let newMenuItem.callback = a:options['callback']
line 15:     endif
line 16: 
line 17:     if has_key(a:options, 'parent')
line 18:         call add(a:options['parent'].children, newMenuItem)
line 19:     else
line 20:         call add(s:MenuItem.All(), newMenuItem)
calling 60()

line 1:     if !exists('s:menuItems')
line 2:         let s:menuItems = []
line 3:     endif
line 4:     return s:menuItems
60 returning [{'All': function('60'), 'isActiveCall...eeExecFile', 'Create': function('62')}]

continuing in 62

line 21:     endif
line 22: 
line 23:     return newMenuItem
62 returning {'All': function('60'), 'isActiveCallb...TreeAddNode', 'Create': function('62')}

continuing in NERDTreeAddMenuItem

NERDTreeAddMenuItem returning #0

continuing in /home/Dante/.vim/plugged/nerdtree/nerdtree_plugin/fs_menu.vim

line 23: call NERDTreeAddMenuItem({'text': '(m)ove the current node', 'shortcut': 'm', 'callback': 'NERDTreeMoveNode'})
calling NERDTreeAddMenuItem({'callback': 'NERDTreeMoveNode', 'shor...'m', 'text': '(m)ove the current node'})

line 1:     call g:NERDTreeMenuItem.Create(a:options)
calling 62({'callback': 'NERDTreeMoveNode', 'shor...'m', 'text': '(m)ove the current node'})

line 1:     let newMenuItem = copy(self)
line 2: 
line 3:     let newMenuItem.text = a:options['text']
line 4:     let newMenuItem.shortcut = a:options['shortcut']
line 5:     let newMenuItem.children = []
line 6: 
line 7:     let newMenuItem.isActiveCallback = -1
line 8:     if has_key(a:options, 'isActiveCallback')
line 9:         let newMenuItem.isActiveCallback = a:options['isActiveCallback']
line 10:     endif
line 11: 
line 12:     let newMenuItem.callback = -1
line 13:     if has_key(a:options, 'callback')
line 14:         let newMenuItem.callback = a:options['callback']
line 15:     endif
line 16: 
line 17:     if has_key(a:options, 'parent')
line 18:         call add(a:options['parent'].children, newMenuItem)
line 19:     else
line 20:         call add(s:MenuItem.All(), newMenuItem)
calling 60()

line 1:     if !exists('s:menuItems')
line 2:         let s:menuItems = []
line 3:     endif
line 4:     return s:menuItems
60 returning [{'All': function('60'), 'isActiveCall...reeAddNode', 'Create': function('62')}]

continuing in 62

line 21:     endif
line 22: 
line 23:     return newMenuItem
62 returning {'All': function('60'), 'isActiveCallb...reeMoveNode', 'Create': function('62')}

continuing in NERDTreeAddMenuItem

NERDTreeAddMenuItem returning #0

continuing in /home/Dante/.vim/plugged/nerdtree/nerdtree_plugin/fs_menu.vim

line 24: call NERDTreeAddMenuItem({'text': '(d)elete the current node', 'shortcut': 'd', 'callback': 'NERDTreeDeleteNode'})
calling NERDTreeAddMenuItem({'callback': 'NERDTreeDeleteNode', 'sh...', 'text': '(d)elete the current node'})

line 1:     call g:NERDTreeMenuItem.Create(a:options)
calling 62({'callback': 'NERDTreeDeleteNode', 'sh...', 'text': '(d)elete the current node'})

line 1:     let newMenuItem = copy(self)
line 2: 
line 3:     let newMenuItem.text = a:options['text']
line 4:     let newMenuItem.shortcut = a:options['shortcut']
line 5:     let newMenuItem.children = []
line 6: 
line 7:     let newMenuItem.isActiveCallback = -1
line 8:     if has_key(a:options, 'isActiveCallback')
line 9:         let newMenuItem.isActiveCallback = a:options['isActiveCallback']
line 10:     endif
line 11: 
line 12:     let newMenuItem.callback = -1
line 13:     if has_key(a:options, 'callback')
line 14:         let newMenuItem.callback = a:options['callback']
line 15:     endif
line 16: 
line 17:     if has_key(a:options, 'parent')
line 18:         call add(a:options['parent'].children, newMenuItem)
line 19:     else
line 20:         call add(s:MenuItem.All(), newMenuItem)
calling 60()

line 1:     if !exists('s:menuItems')
line 2:         let s:menuItems = []
line 3:     endif
line 4:     return s:menuItems
60 returning [{'All': function('60'), 'isActiveCall...eeMoveNode', 'Create': function('62')}]

continuing in 62

line 21:     endif
line 22: 
line 23:     return newMenuItem
62 returning {'All': function('60'), 'isActiveCallb...eDeleteNode', 'Create': function('62')}

continuing in NERDTreeAddMenuItem

NERDTreeAddMenuItem returning #0

continuing in /home/Dante/.vim/plugged/nerdtree/nerdtree_plugin/fs_menu.vim

line 25: 
line 26: if nerdtree#runningMac()
calling nerdtree#runningMac()

line 1:     return has('gui_mac') || has('gui_macvim') || has('mac') || has('osx')
nerdtree#runningMac returning #0

continuing in /home/Dante/.vim/plugged/nerdtree/nerdtree_plugin/fs_menu.vim

line 27:     call NERDTreeAddMenuItem({'text': '(r)eveal the current node in the Finder', 'shortcut': 'r', 'callback': 'NERDTreeRevealInFinder'})
line 28:     call NERDTreeAddMenuItem({'text': '(o)pen the current node with system editor', 'shortcut': 'o', 'callback': 'NERDTreeExecuteFile'})
line 29:     call NERDTreeAddMenuItem({'text': '(q)uicklook the current node', 'shortcut': 'q', 'callback': 'NERDTreeQuickLook'})
line 30: endif
line 31: 
line 32: if executable('xdg-open')
line 33:     call NERDTreeAddMenuItem({'text': '(r)eveal the current node in file manager', 'shortcut': 'r', 'callback': 'NERDTreeRevealFileLinux'})
calling NERDTreeAddMenuItem({'callback': 'NERDTreeRevealFileLinux'...veal the current node in file manager'})

line 1:     call g:NERDTreeMenuItem.Create(a:options)
calling 62({'callback': 'NERDTreeRevealFileLinux'...veal the current node in file manager'})

line 1:     let newMenuItem = copy(self)
line 2: 
line 3:     let newMenuItem.text = a:options['text']
line 4:     let newMenuItem.shortcut = a:options['shortcut']
line 5:     let newMenuItem.children = []
line 6: 
line 7:     let newMenuItem.isActiveCallback = -1
line 8:     if has_key(a:options, 'isActiveCallback')
line 9:         let newMenuItem.isActiveCallback = a:options['isActiveCallback']
line 10:     endif
line 11: 
line 12:     let newMenuItem.callback = -1
line 13:     if has_key(a:options, 'callback')
line 14:         let newMenuItem.callback = a:options['callback']
line 15:     endif
line 16: 
line 17:     if has_key(a:options, 'parent')
line 18:         call add(a:options['parent'].children, newMenuItem)
line 19:     else
line 20:         call add(s:MenuItem.All(), newMenuItem)
calling 60()

line 1:     if !exists('s:menuItems')
line 2:         let s:menuItems = []
line 3:     endif
line 4:     return s:menuItems
60 returning [{'All': function('60'), 'isActiveCall...DeleteNode', 'Create': function('62')}]

continuing in 62

line 21:     endif
line 22: 
line 23:     return newMenuItem
62 returning {'All': function('60'), 'isActiveCallb...alFileLinux', 'Create': function('62')}

continuing in NERDTreeAddMenuItem

NERDTreeAddMenuItem returning #0

continuing in /home/Dante/.vim/plugged/nerdtree/nerdtree_plugin/fs_menu.vim

line 34:     call NERDTreeAddMenuItem({'text': '(o)pen the current node with system editor', 'shortcut': 'o', 'callback': 'NERDTreeExecuteFileLinux'})
calling NERDTreeAddMenuItem({'callback': 'NERDTreeExecuteFileLinux...n the current node with system editor'})

line 1:     call g:NERDTreeMenuItem.Create(a:options)
calling 62({'callback': 'NERDTreeExecuteFileLinux...n the current node with system editor'})

line 1:     let newMenuItem = copy(self)
line 2: 
line 3:     let newMenuItem.text = a:options['text']
line 4:     let newMenuItem.shortcut = a:options['shortcut']
line 5:     let newMenuItem.children = []
line 6: 
line 7:     let newMenuItem.isActiveCallback = -1
line 8:     if has_key(a:options, 'isActiveCallback')
line 9:         let newMenuItem.isActiveCallback = a:options['isActiveCallback']
line 10:     endif
line 11: 
line 12:     let newMenuItem.callback = -1
line 13:     if has_key(a:options, 'callback')
line 14:         let newMenuItem.callback = a:options['callback']
line 15:     endif
line 16: 
line 17:     if has_key(a:options, 'parent')
line 18:         call add(a:options['parent'].children, newMenuItem)
line 19:     else
line 20:         call add(s:MenuItem.All(), newMenuItem)
calling 60()

line 1:     if !exists('s:menuItems')
line 2:         let s:menuItems = []
line 3:     endif
line 4:     return s:menuItems
60 returning [{'All': function('60'), 'isActiveCall...lFileLinux', 'Create': function('62')}]

continuing in 62

line 21:     endif
line 22: 
line 23:     return newMenuItem
62 returning {'All': function('60'), 'isActiveCallb...teFileLinux', 'Create': function('62')}

continuing in NERDTreeAddMenuItem

NERDTreeAddMenuItem returning #0

continuing in /home/Dante/.vim/plugged/nerdtree/nerdtree_plugin/fs_menu.vim

line 35: endif
line 36: 
line 37: if nerdtree#runningWindows()
calling nerdtree#runningWindows()

line 1:     return has('win16') || has('win32') || has('win64')
nerdtree#runningWindows returning #0

continuing in /home/Dante/.vim/plugged/nerdtree/nerdtree_plugin/fs_menu.vim

line 38:     call NERDTreeAddMenuItem({'text': '(r)eveal the current node in the Explorer', 'shortcut': 'r', 'callback': 'NERDTreeRevealInExplorer'})
line 39:     call NERDTreeAddMenuItem({'text': '(o)pen the current node with system editor', 'shortcut': 'o', 'callback': 'NERDTreeExecuteFileWindows'})
line 40: endif
line 41: 
line 42: if g:NERDTreePath.CopyingSupported()
calling 8()

line 1:     return exists('g:NERDTreeCopyCmd') || (exists('g:NERDTreeCopyDirCmd') && exists('g:NERDTreeCopyFileCmd'))
8 returning #1

continuing in /home/Dante/.vim/plugged/nerdtree/nerdtree_plugin/fs_menu.vim

line 43:     call NERDTreeAddMenuItem({'text': '(c)opy the current node', 'shortcut': 'c', 'callback': 'NERDTreeCopyNode'})
calling NERDTreeAddMenuItem({'callback': 'NERDTreeCopyNode', 'shor...'c', 'text': '(c)opy the current node'})

line 1:     call g:NERDTreeMenuItem.Create(a:options)
calling 62({'callback': 'NERDTreeCopyNode', 'shor...'c', 'text': '(c)opy the current node'})

line 1:     let newMenuItem = copy(self)
line 2: 
line 3:     let newMenuItem.text = a:options['text']
line 4:     let newMenuItem.shortcut = a:options['shortcut']
line 5:     let newMenuItem.children = []
line 6: 
line 7:     let newMenuItem.isActiveCallback = -1
line 8:     if has_key(a:options, 'isActiveCallback')
line 9:         let newMenuItem.isActiveCallback = a:options['isActiveCallback']
line 10:     endif
line 11: 
line 12:     let newMenuItem.callback = -1
line 13:     if has_key(a:options, 'callback')
line 14:         let newMenuItem.callback = a:options['callback']
line 15:     endif
line 16: 
line 17:     if has_key(a:options, 'parent')
line 18:         call add(a:options['parent'].children, newMenuItem)
line 19:     else
line 20:         call add(s:MenuItem.All(), newMenuItem)
calling 60()

line 1:     if !exists('s:menuItems')
line 2:         let s:menuItems = []
line 3:     endif
line 4:     return s:menuItems
60 returning [{'All': function('60'), 'isActiveCall...eFileLinux', 'Create': function('62')}]

continuing in 62

line 21:     endif
line 22: 
line 23:     return newMenuItem
62 returning {'All': function('60'), 'isActiveCallb...reeCopyNode', 'Create': function('62')}

continuing in NERDTreeAddMenuItem

NERDTreeAddMenuItem returning #0

continuing in /home/Dante/.vim/plugged/nerdtree/nerdtree_plugin/fs_menu.vim

line 44: endif
line 45: call NERDTreeAddMenuItem({'text': (has('clipboard')?'copy (p)ath to clipboard':'print (p)ath to screen'), 'shortcut': 'p', 'callback': 'NERDTreeCopyPath'})
calling NERDTreeAddMenuItem({'callback': 'NERDTreeCopyPath', 'shor...p', 'text': 'copy (p)ath to clipboard'})

line 1:     call g:NERDTreeMenuItem.Create(a:options)
calling 62({'callback': 'NERDTreeCopyPath', 'shor...p', 'text': 'copy (p)ath to clipboard'})

line 1:     let newMenuItem = copy(self)
line 2: 
line 3:     let newMenuItem.text = a:options['text']
line 4:     let newMenuItem.shortcut = a:options['shortcut']
line 5:     let newMenuItem.children = []
line 6: 
line 7:     let newMenuItem.isActiveCallback = -1
line 8:     if has_key(a:options, 'isActiveCallback')
line 9:         let newMenuItem.isActiveCallback = a:options['isActiveCallback']
line 10:     endif
line 11: 
line 12:     let newMenuItem.callback = -1
line 13:     if has_key(a:options, 'callback')
line 14:         let newMenuItem.callback = a:options['callback']
line 15:     endif
line 16: 
line 17:     if has_key(a:options, 'parent')
line 18:         call add(a:options['parent'].children, newMenuItem)
line 19:     else
line 20:         call add(s:MenuItem.All(), newMenuItem)
calling 60()

line 1:     if !exists('s:menuItems')
line 2:         let s:menuItems = []
line 3:     endif
line 4:     return s:menuItems
60 returning [{'All': function('60'), 'isActiveCall...eeCopyNode', 'Create': function('62')}]

continuing in 62

line 21:     endif
line 22: 
line 23:     return newMenuItem
62 returning {'All': function('60'), 'isActiveCallb...reeCopyPath', 'Create': function('62')}

continuing in NERDTreeAddMenuItem

NERDTreeAddMenuItem returning #0

continuing in /home/Dante/.vim/plugged/nerdtree/nerdtree_plugin/fs_menu.vim

line 46: 
line 47: if has('unix') || has('osx')
line 48:     call NERDTreeAddMenuItem({'text': '(l)ist the current node', 'shortcut': 'l', 'callback': 'NERDTreeListNode'})
calling NERDTreeAddMenuItem({'callback': 'NERDTreeListNode', 'shor...'l', 'text': '(l)ist the current node'})

line 1:     call g:NERDTreeMenuItem.Create(a:options)
calling 62({'callback': 'NERDTreeListNode', 'shor...'l', 'text': '(l)ist the current node'})

line 1:     let newMenuItem = copy(self)
line 2: 
line 3:     let newMenuItem.text = a:options['text']
line 4:     let newMenuItem.shortcut = a:options['shortcut']
line 5:     let newMenuItem.children = []
line 6: 
line 7:     let newMenuItem.isActiveCallback = -1
line 8:     if has_key(a:options, 'isActiveCallback')
line 9:         let newMenuItem.isActiveCallback = a:options['isActiveCallback']
line 10:     endif
line 11: 
line 12:     let newMenuItem.callback = -1
line 13:     if has_key(a:options, 'callback')
line 14:         let newMenuItem.callback = a:options['callback']
line 15:     endif
line 16: 
line 17:     if has_key(a:options, 'parent')
line 18:         call add(a:options['parent'].children, newMenuItem)
line 19:     else
line 20:         call add(s:MenuItem.All(), newMenuItem)
calling 60()

line 1:     if !exists('s:menuItems')
line 2:         let s:menuItems = []
line 3:     endif
line 4:     return s:menuItems
60 returning [{'All': function('60'), 'isActiveCall...eeCopyPath', 'Create': function('62')}]

continuing in 62

line 21:     endif
line 22: 
line 23:     return newMenuItem
62 returning {'All': function('60'), 'isActiveCallb...reeListNode', 'Create': function('62')}

continuing in NERDTreeAddMenuItem

NERDTreeAddMenuItem returning #0

continuing in /home/Dante/.vim/plugged/nerdtree/nerdtree_plugin/fs_menu.vim

line 49:     call NERDTreeAddMenuItem({'text': '(C)hange node permissions', 'shortcut':'C', 'callback': 'NERDTreeChangePermissions'})
calling NERDTreeAddMenuItem({'callback': 'NERDTreeChangePermission...', 'text': '(C)hange node permissions'})

line 1:     call g:NERDTreeMenuItem.Create(a:options)
calling 62({'callback': 'NERDTreeChangePermission...', 'text': '(C)hange node permissions'})

line 1:     let newMenuItem = copy(self)
line 2: 
line 3:     let newMenuItem.text = a:options['text']
line 4:     let newMenuItem.shortcut = a:options['shortcut']
line 5:     let newMenuItem.children = []
line 6: 
line 7:     let newMenuItem.isActiveCallback = -1
line 8:     if has_key(a:options, 'isActiveCallback')
line 9:         let newMenuItem.isActiveCallback = a:options['isActiveCallback']
line 10:     endif
line 11: 
line 12:     let newMenuItem.callback = -1
line 13:     if has_key(a:options, 'callback')
line 14:         let newMenuItem.callback = a:options['callback']
line 15:     endif
line 16: 
line 17:     if has_key(a:options, 'parent')
line 18:         call add(a:options['parent'].children, newMenuItem)
line 19:     else
line 20:         call add(s:MenuItem.All(), newMenuItem)
calling 60()

line 1:     if !exists('s:menuItems')
line 2:         let s:menuItems = []
line 3:     endif
line 4:     return s:menuItems
60 returning [{'All': function('60'), 'isActiveCall...eeListNode', 'Create': function('62')}]

continuing in 62

line 21:     endif
line 22: 
line 23:     return newMenuItem
62 returning {'All': function('60'), 'isActiveCallb...Permissions', 'Create': function('62')}

continuing in NERDTreeAddMenuItem

NERDTreeAddMenuItem returning #0

continuing in /home/Dante/.vim/plugged/nerdtree/nerdtree_plugin/fs_menu.vim

line 50: else
line 51:     call NERDTreeAddMenuItem({'text': '(l)ist the current node', 'shortcut': 'l', 'callback': 'NERDTreeListNodeWin32'})
line 52: endif
line 53: 
line 54: if exists('*system')
line 55:     call NERDTreeAddMenuItem({'text': 'Run (s)ystem command in this directory', 'shortcut':'s', 'callback': 'NERDTreeSystemCommand'})
calling NERDTreeAddMenuItem({'callback': 'NERDTreeSystemCommand', ...un (s)ystem command in this directory'})

line 1:     call g:NERDTreeMenuItem.Create(a:options)
calling 62({'callback': 'NERDTreeSystemCommand', ...un (s)ystem command in this directory'})

line 1:     let newMenuItem = copy(self)
line 2: 
line 3:     let newMenuItem.text = a:options['text']
line 4:     let newMenuItem.shortcut = a:options['shortcut']
line 5:     let newMenuItem.children = []
line 6: 
line 7:     let newMenuItem.isActiveCallback = -1
line 8:     if has_key(a:options, 'isActiveCallback')
line 9:         let newMenuItem.isActiveCallback = a:options['isActiveCallback']
line 10:     endif
line 11: 
line 12:     let newMenuItem.callback = -1
line 13:     if has_key(a:options, 'callback')
line 14:         let newMenuItem.callback = a:options['callback']
line 15:     endif
line 16: 
line 17:     if has_key(a:options, 'parent')
line 18:         call add(a:options['parent'].children, newMenuItem)
line 19:     else
line 20:         call add(s:MenuItem.All(), newMenuItem)
calling 60()

line 1:     if !exists('s:menuItems')
line 2:         let s:menuItems = []
line 3:     endif
line 4:     return s:menuItems
60 returning [{'All': function('60'), 'isActiveCall...ermissions', 'Create': function('62')}]

continuing in 62

line 21:     endif
line 22: 
line 23:     return newMenuItem
62 returning {'All': function('60'), 'isActiveCallb...stemCommand', 'Create': function('62')}

continuing in NERDTreeAddMenuItem

NERDTreeAddMenuItem returning #0

continuing in /home/Dante/.vim/plugged/nerdtree/nerdtree_plugin/fs_menu.vim

line 56: endif
line 57: 
line 58: "FUNCTION: s:inputPrompt(action){{{1
line 59: "returns the string that should be prompted to the user for the given action
line 60: "
line 61: "Args:
line 62: "action: the action that is being performed, e.g. 'delete'
line 63: function! s:inputPrompt(action)
line 98: 
line 99: "FUNCTION: s:promptToDelBuffer(bufnum, msg){{{1
line 100: "prints out the given msg and, if the user responds by pushing 'y' then the
line 101: "buffer with the given bufnum is deleted
line 102: "
line 103: "Args:
line 104: "bufnum: the buffer that may be deleted
line 105: "msg: a message that will be echoed to the user asking them if they wish to
line 106: "     del the buffer
line 107: function! s:promptToDelBuffer(bufnum, msg)
line 137: 
line 138: "FUNCTION: s:renameBuffer(bufNum, newNodeName, isDirectory){{{1
line 139: "The buffer with the given bufNum is replaced with a new one
line 140: "
line 141: "Args:
line 142: "bufNum: the buffer that may be deleted
line 143: "newNodeName: the name given to the renamed node
line 144: "isDirectory: determines how to do the create the new filenames
line 145: function! s:renameBuffer(bufNum, newNodeName, isDirectory)
line 189: 
line 190: "FUNCTION: NERDTreeAddNode(){{{1
line 191: function! NERDTreeAddNode()
line 223: 
line 224: "FUNCTION: NERDTreeMoveNode(){{{1
line 225: function! NERDTreeMoveNode()
line 295: 
line 296: " FUNCTION: NERDTreeDeleteNode() {{{1
line 297: function! NERDTreeDeleteNode()
line 334: 
line 335: " FUNCTION: NERDTreeListNode() {{{1
line 336: function! NERDTreeListNode()
line 356: 
line 357: " FUNCTION: NERDTreeListNodeWin32() {{{1
line 358: function! NERDTreeListNodeWin32()
line 374: 
line 375: " FUNCTION: NERDTreeChangePermissions() {{{1
line 376: function! NERDTreeChangePermissions()
line 397: 
line 398: " FUNCTION: NERDTreeCopyNode() {{{1
line 399: function! NERDTreeCopyNode()
line 437: 
line 438: " FUNCTION: NERDTreeCopyPath() {{{1
line 439: function! NERDTreeCopyPath()
line 452: 
line 453: " FUNCTION: NERDTreeQuickLook() {{{1
line 454: function! NERDTreeQuickLook()
line 463: 
line 464: " FUNCTION: NERDTreeRevealInFinder() {{{1
line 465: function! NERDTreeRevealInFinder()
line 474: 
line 475: " FUNCTION: NERDTreeExecuteFile() {{{1
line 476: function! NERDTreeExecuteFile()
line 485: 
line 486: " FUNCTION: NERDTreeRevealFileLinux() {{{1
line 487: function! NERDTreeRevealFileLinux()
line 506: 
line 507: " FUNCTION: NERDTreeExecuteFileLinux() {{{1
line 508: function! NERDTreeExecuteFileLinux()
line 517: 
line 518: " FUNCTION: NERDTreeRevealInExplorer() {{{1
line 519: function! NERDTreeRevealInExplorer()
line 528: 
line 529: " FUNCTION: NERDTreeExecuteFileWindows() {{{1
line 530: function! NERDTreeExecuteFileWindows()
line 539: 
line 540: " FUNCTION: NERDTreeSystemCommand() {{{1
line 541: function! NERDTreeSystemCommand()
line 556: 
line 557: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/Dante/.vim/plugged/nerdtree/nerdtree_plugin/fs_menu.vim
continuing in nerdtree#postSourceActions
chdir(/home/Dante/.vim/plugged/nerdtree/nerdtree_plugin)
fchdir() to previous dir
line 5: sourcing "/home/Dante/.vim/plugged/nerdtree/nerdtree_plugin/vcs.vim"
line 1: " ============================================================================
line 2: " File:        vcs.vim
line 3: " Description: NERDTree plugin that provides a command to open on the root of
line 4: "              a version control system repository.
line 5: " Maintainer:  Phil Runninger
line 6: " License:     This program is free software. It comes without any warranty,
line 7: "              to the extent permitted by applicable law. You can redistribute
line 8: "              it and/or modify it under the terms of the Do What The Fuck You
line 9: "              Want To Public License, Version 2, as published by Sam Hocevar.
line 10: "              See http://sam.zoy.org/wtfpl/COPYING for more details.
line 11: "
line 12: " ============================================================================
line 13: command! -n=? -complete=dir -bar NERDTreeVCS :call <SID>CreateTabTreeVCS('<args>')
line 14: command! -n=? -complete=dir -bar NERDTreeToggleVCS :call <SID>ToggleTabTreeVCS('<args>')
line 15: 
line 16: " FUNCTION: s:CreateTabTreeVCS(a:name) {{{1
line 17: function! s:CreateTabTreeVCS(name)
line 22: 
line 23: " FUNCTION: s:ToggleTabTreeVCS(a:name) {{{1
line 24: " Behaves the same as ToggleTabTree except roots directory at VCS root
line 25: function! s:ToggleTabTreeVCS(name)
line 30: 
line 31: " FUNCTION: s:FindParentVCSRoot(a:path) {{{1
line 32: " Finds the root version control system folder of the given path. If a:path is
line 33: " not part of a repository, return the original path.
line 34: function! s:FindParentVCSRoot(path)
line 47: 
finished sourcing /home/Dante/.vim/plugged/nerdtree/nerdtree_plugin/vcs.vim
continuing in nerdtree#postSourceActions
Searching for "/home/Dante/.vim/plugged/fzf/nerdtree_plugin/**/*.vim"
Searching for "/home/Dante/.vim/plugged/fzf.vim/nerdtree_plugin/**/*.vim"
Searching for "/home/Dante/.vim/plugged/vim-wayland-clipboard/nerdtree_plugin/**/*.vim"
Searching for "/home/Dante/.vim/plugged/coc.nvim/nerdtree_plugin/**/*.vim"
Searching for "/home/Dante/.vim/plugged/vim-obsession/nerdtree_plugin/**/*.vim"
Searching for "/usr/share/vim/vimfiles/nerdtree_plugin/**/*.vim"
Searching for "/usr/share/vim/vim91/nerdtree_plugin/**/*.vim"
Searching for "/usr/share/vim/vimfiles/after/nerdtree_plugin/**/*.vim"
Searching for "/home/Dante/.vim/plugged/vimtex/after/nerdtree_plugin/**/*.vim"
Searching for "/home/Dante/.vim/after/nerdtree_plugin/**/*.vim"
nerdtree#postSourceActions returning #0

continuing in /home/Dante/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 236: 
line 237: "reset &cpoptions back to users setting
line 238: let &cpoptions = s:old_cpo
line 239: 
line 240: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/Dante/.vim/plugged/nerdtree/plugin/NERD_tree.vim
Searching for "/home/Dante/.vim/plugged/fzf/plugin/**/*.vim"
chdir(/home/Dante/.vim/plugged/fzf/plugin)
fchdir() to previous dir
sourcing "/home/Dante/.vim/plugged/fzf/plugin/fzf.vim"
line 1: " Copyright (c) 2013-2024 Junegunn Choi
line 2: "
line 3: " MIT License
line 4: "
line 5: " Permission is hereby granted, free of charge, to any person obtaining
line 6: " a copy of this software and associated documentation files (the
line 7: " "Software"), to deal in the Software without restriction, including
line 8: " without limitation the rights to use, copy, modify, merge, publish,
line 9: " distribute, sublicense, and/or sell copies of the Software, and to
line 10: " permit persons to whom the Software is furnished to do so, subject to
line 11: " the following conditions:
line 12: "
line 13: " The above copyright notice and this permission notice shall be
line 14: " included in all copies or substantial portions of the Software.
line 15: "
line 16: " THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
line 17: " EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
line 18: " MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
line 19: " NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
line 20: " LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
line 21: " OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
line 22: " WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
line 23: 
line 24: if exists('g:loaded_fzf')
line 25:   finish
line 26: endif
line 27: let g:loaded_fzf = 1
line 28: 
line 29: let s:is_win = has('win32') || has('win64')
line 30: if s:is_win && &shellslash
line 31:   set noshellslash
line 32:   let s:base_dir = expand('<sfile>:h:h')
line 33:   set shellslash
line 34: else
line 35:   let s:base_dir = expand('<sfile>:h:h')
line 36: endif
line 37: if s:is_win
line 38:   let s:term_marker = '&::FZF'
line 39: 
line 40:   function! s:fzf_call(fn, ...)
line 49: 
line 50:   " Use utf-8 for fzf.vim commands
line 51:   " Return array of shell commands for cmd.exe
line 52:   function! s:enc_to_cp(str)
line 61:   function! s:wrap_cmds(cmds)
line 67: else
line 68:   let s:term_marker = ";#FZF"
line 69: 
line 70:   function! s:fzf_call(fn, ...)
line 73: 
line 74:   function! s:wrap_cmds(cmds)
line 77: 
line 78:   function! s:enc_to_cp(str)
line 81: endif
line 82: 
line 83: function! s:shellesc_cmd(arg)
line 100: 
line 101: function! fzf#shellescape(arg, ...)
line 113: 
line 114: function! s:fzf_getcwd()
line 117: 
line 118: function! s:fzf_fnamemodify(fname, mods)
line 121: 
line 122: function! s:fzf_expand(fmt)
line 125: 
line 126: function! s:fzf_tempname()
line 129: 
line 130: let s:layout_keys = ['window', 'tmux', 'up', 'down', 'left', 'right']
line 131: let s:fzf_go = s:base_dir.'/bin/fzf'
line 132: let s:fzf_tmux = s:base_dir.'/bin/fzf-tmux'
line 133: 
line 134: let s:cpo_save = &cpo
line 135: set cpo&vim
line 136: 
line 137: function! s:popup_support()
line 140: 
line 141: function! s:default_layout()
line 146: 
line 147: function! fzf#install()
line 168: 
line 169: let s:versions = {}
line 170: function s:get_version(bin)
line 183: 
line 184: function! s:compare_versions(a, b)
line 196: 
line 197: function! s:compare_binary_versions(a, b)
line 200: 
line 201: let s:min_version = '0.53.0'
line 202: let s:checked = {}
line 203: function! fzf#exec(...)
line 257: 
line 258: function! s:tmux_enabled()
line 280: 
line 281: function! s:escape(path)
line 285: 
line 286: function! s:error(msg)
line 291: 
line 292: function! s:warn(msg)
line 297: 
line 298: function! s:has_any(dict, keys)
line 306: 
line 307: function! s:open(cmd, target)
line 313: 
line 314: function! s:common_sink(action, lines) abort
line 358: 
line 359: function! s:get_color(attr, ...)
line 372: 
line 373: function! s:defaults()
line 378: 
line 379: function! s:validate_layout(layout)
line 388: 
line 389: function! s:evaluate_opts(options)
line 393: 
line 394: " [name string,] [opts dict,] [fullscreen boolean]
line 395: function! fzf#wrap(...)
line 454: 
line 455: function! s:use_sh()
line 467: 
line 468: function! s:writefile(...)
line 473: 
line 474: function! s:extract_option(opts, name)
line 497: 
line 498: let s:need_cmd_window = has('win32unix') && $TERM_PROGRAM ==# 'mintty' && s:compare_versions($TERM_PROGRAM_VERSION, '3.4.5') < 0 && !executable('winpty')
line 499: 
line 500: function! fzf#run(...) abort
line 572: 
line 573: function! s:present(dict, ...)
line 581: 
line 582: function! s:fzf_tmux(dict)
line 603: 
line 604: function! s:splittable(dict)
line 608: 
line 609: function! s:pushd(dict)
line 625: 
line 626: augroup fzf_popd
line 627:   autocmd!
line 628:   autocmd WinEnter * call s:dopopd()
line 629: augroup END
line 630: 
line 631: function! s:dopopd()
line 656: 
line 657: function! s:xterm_launcher()
line 666: unlet! s:launcher
line 667: if s:is_win || has('win32unix')
line 668:   let s:launcher = '%s'
line 669: else
line 670:   let s:launcher = function('s:xterm_launcher')
line 671: endif
line 672: 
line 673: function! s:exit_handler(dict, code, command, ...)
line 685: 
line 686: function! s:execute(dict, command, use_height, temps) abort
line 737: 
line 738: function! s:execute_tmux(dict, command, temps) abort
line 752: 
line 753: function! s:calc_size(max, val, dict)
line 777: 
line 778: function! s:getpos()
line 781: 
line 782: function! s:border_opt(window)
line 807: 
line 808: function! s:split(dict)
line 852: 
line 853: nnoremap <silent> <Plug>(fzf-insert) i
line 854: nnoremap <silent> <Plug>(fzf-normal) <Nop>
line 855: if exists(':tnoremap')
line 856:   tnoremap <silent> <Plug>(fzf-insert) <C-\><C-n>i
line 857:   tnoremap <silent> <Plug>(fzf-normal) <C-\><C-n>
line 858: endif
line 859: 
line 860: let s:warned = 0
line 861: function! s:handle_ambidouble(dict)
line 870: 
line 871: function! s:execute_term(dict, command, temps) abort
line 973: 
line 974: function! s:collect(temps) abort
line 983: 
line 984: function! s:callback(dict, lines) abort
line 1017: 
line 1018: if has('nvim')
line 1019:   function s:create_popup(opts) abort
line 1027: else
line 1028:   function! s:create_popup(opts) abort
line 1040: endif
line 1041: 
line 1042: function! s:popup(opts) abort
line 1067: 
line 1068: let s:default_action = { 'ctrl-t': 'tab split', 'ctrl-x': 'split', 'ctrl-v': 'vsplit' }
line 1072: 
line 1073: function! s:shortpath()
line 1081: 
line 1082: function! s:cmd(bang, ...) abort
line 1099: 
line 1100: command! -nargs=* -complete=dir -bang FZF call s:cmd(<bang>0, <f-args>)
line 1101: 
line 1102: let &cpo = s:cpo_save
line 1103: unlet s:cpo_save
finished sourcing /home/Dante/.vim/plugged/fzf/plugin/fzf.vim
Searching for "/home/Dante/.vim/plugged/fzf.vim/plugin/**/*.vim"
chdir(/home/Dante/.vim/plugged/fzf.vim/plugin)
fchdir() to previous dir
sourcing "/home/Dante/.vim/plugged/fzf.vim/plugin/fzf.vim"
line 1: " Copyright (c) 2015 Junegunn Choi
line 2: "
line 3: " MIT License
line 4: "
line 5: " Permission is hereby granted, free of charge, to any person obtaining
line 6: " a copy of this software and associated documentation files (the
line 7: " "Software"), to deal in the Software without restriction, including
line 8: " without limitation the rights to use, copy, modify, merge, publish,
line 9: " distribute, sublicense, and/or sell copies of the Software, and to
line 10: " permit persons to whom the Software is furnished to do so, subject to
line 11: " the following conditions:
line 12: "
line 13: " The above copyright notice and this permission notice shall be
line 14: " included in all copies or substantial portions of the Software.
line 15: "
line 16: " THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
line 17: " EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
line 18: " MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
line 19: " NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
line 20: " LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
line 21: " OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
line 22: " WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
line 23: 
line 24: if exists('g:loaded_fzf_vim')
line 25:   finish
line 26: endif
line 27: let g:loaded_fzf_vim = 1
line 28: 
line 29: let s:cpo_save = &cpo
line 30: set cpo&vim
line 31: let s:is_win = has('win32') || has('win64')
line 32: 
line 33: function! s:conf(name, default)
line 38: 
line 39: function! s:defs(commands)
line 52: 
line 53: call s:defs(['command!      -bang -nargs=? -complete=dir Files              call fzf#vim#files(<q-args>, fzf#vim#with_preview(), <bang>0)','command!      -bang -nargs=? GitFiles                         call fzf#vim#gitfiles(<q-args>, fzf#vim#with_preview(<q-args> == "?" ? { "placeholder": "" } : {}), <bang>0)','command!      -bang -nargs=? GFiles                           call fzf#vim#gitfiles(<q-args>, fzf#vim#with_preview(<q-args> == "?" ? { "placeholder": "" } : {}), <bang>0)','command! -bar -bang -nargs=? -complete=buffer Buffers         call fzf#vim#buffers(<q-args>, fzf#vim#with_preview({ "placeholder": "{1}" }), <bang>0)','command!      -bang -nargs=* SFiles                           call fzf#run(fzf#wrap({"source": "rg ~ --files --hidden -g \"!*.o\" -g \"!*.mod\" -g \"!*.pdf\" ".fzf#shellescape(<q-args>), "options": "--multi -i --preview \"bat --color=always --style=numbers --line-range=:500 {}\""}), fzf#vim#with_preview(), <bang>0)','command!      -bang -nargs=* Lines                        
calling <SNR>44_defs(['command!      -bang -nargs=? -comple...gs>, fzf#vim#with_preview(), <bang>0)'])

line 1:   let prefix = s:conf('command_prefix', '')
calling <SNR>44_conf('command_prefix', '')

line 1:   let conf = get(g:, 'fzf_vim', {})
line 2:   let val = get(conf, a:name, get(g:, 'fzf_' . a:name, a:default))
line 3:   return val
<SNR>44_conf returning ''

continuing in <SNR>44_defs

line 2:   if prefix =~# '^[^A-Z]'
line 3:     echoerr 'g:fzf_command_prefix must start with an uppercase letter'
line 4:     return
line 5:   endif
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 9: command!      -bang -nargs=? -complete=dir Files              call fzf#vim#files(<q-args>, fzf#vim#with_preview(), <bang>0)
line 10:     endif
line 11:   endfor
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 9: command!      -bang -nargs=? GitFiles                         call fzf#vim#gitfiles(<q-args>, fzf#vim#with_preview(<q-args> == "?" ? { "placeholder": "" } : {}), <bang>0)
line 10:     endif
line 11:   endfor
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 9: command!      -bang -nargs=? GFiles                           call fzf#vim#gitfiles(<q-args>, fzf#vim#with_preview(<q-args> == "?" ? { "placeholder": "" } : {}), <bang>0)
line 10:     endif
line 11:   endfor
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 9: command! -bar -bang -nargs=? -complete=buffer Buffers         call fzf#vim#buffers(<q-args>, fzf#vim#with_preview({ "placeholder": "{1}" }), <bang>0)
line 10:     endif
line 11:   endfor
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 9: command!      -bang -nargs=* SFiles                           call fzf#run(fzf#wrap({"source": "rg ~ --files --hidden -g \"!*.o\" -g \"!*.mod\" -g \"!*.pdf\" ".fzf#shellescape(<q-args>), "options": "--multi -i --preview \"bat --color=always --style=numbers --line-range=:500 {}\""}), fzf#vim#with_preview(), <bang>0)
line 10:     endif
line 11:   endfor
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 9: command!      -bang -nargs=* Lines                            call fzf#vim#lines(<q-args>, <bang>0)
line 10:     endif
line 11:   endfor
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 9: command!      -bang -nargs=* BLines                           call fzf#vim#buffer_lines(<q-args>, <bang>0)
line 10:     endif
line 11:   endfor
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 9: command! -bar -bang Colors                                    call fzf#vim#colors(<bang>0)
line 10:     endif
line 11:   endfor
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 9: command!      -bang -nargs=+ -complete=dir Locate             call fzf#vim#locate(<q-args>, fzf#vim#with_preview(), <bang>0)
line 10:     endif
line 11:   endfor
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 9: command!      -bang -nargs=* Ag                               call fzf#vim#ag(<q-args>, fzf#vim#with_preview(), <bang>0)
line 10:     endif
line 11:   endfor
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 9: command!      -bang -nargs=* Rg                               call fzf#vim#grep("rg --column --line-number --no-heading --color=always --smart-case -- ".fzf#shellescape(<q-args>), fzf#vim#with_preview(), <bang>0)
line 10:     endif
line 11:   endfor
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 9: command!      -bang -nargs=* RG                               call fzf#vim#grep2("rg --column --line-number --no-heading --color=always --smart-case -- ", <q-args>, fzf#vim#with_preview(), <bang>0)
line 10:     endif
line 11:   endfor
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 9: command!      -bang -nargs=* Tags                             call fzf#vim#tags(<q-args>, fzf#vim#with_preview({ "placeholder": "--tag {2}:{-1}:{3..}" }), <bang>0)
line 10:     endif
line 11:   endfor
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 9: command!      -bang -nargs=* BTags                            call fzf#vim#buffer_tags(<q-args>, fzf#vim#with_preview({ "placeholder": "{2}:{3..}" }), <bang>0)
line 10:     endif
line 11:   endfor
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 9: command! -bar -bang Snippets                                  call fzf#vim#snippets(<bang>0)
line 10:     endif
line 11:   endfor
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 9: command! -bar -bang Commands                                  call fzf#vim#commands(<bang>0)
line 10:     endif
line 11:   endfor
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 9: command! -bar -bang Jumps                                     call fzf#vim#jumps(fzf#vim#with_preview({ "placeholder": "{2..4}"}), <bang>0)
line 10:     endif
line 11:   endfor
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 9: command! -bar -bang Marks                                     call fzf#vim#marks(<bang>0)
line 10:     endif
line 11:   endfor
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 9: command! -bar -bang Changes                                   call fzf#vim#changes(<bang>0)
line 10:     endif
line 11:   endfor
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 9: command! -bar -bang Helptags                                  call fzf#vim#helptags(fzf#vim#with_preview({ "placeholder": "--tag {2}:{3}:{4}" }), <bang>0)
line 10:     endif
line 11:   endfor
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 9: command! -bar -bang Windows                                   call fzf#vim#windows(fzf#vim#with_preview({ "placeholder": "{2}" }), <bang>0)
line 10:     endif
line 11:   endfor
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 9: command! -bar -bang -nargs=* -range=% -complete=file Commits  let b:fzf_winview = winsaveview() | <line1>,<line2>call fzf#vim#commits(<q-args>, fzf#vim#with_preview({ "placeholder": "" }), <bang>0)
line 10:     endif
line 11:   endfor
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 9: command! -bar -bang -nargs=* -range=% BCommits                let b:fzf_winview = winsaveview() | <line1>,<line2>call fzf#vim#buffer_commits(<q-args>, fzf#vim#with_preview({ "placeholder": "" }), <bang>0)
line 10:     endif
line 11:   endfor
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 9: command! -bar -bang Maps                                      call fzf#vim#maps("n", <bang>0)
line 10:     endif
line 11:   endfor
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 9: command! -bar -bang Filetypes                                 call fzf#vim#filetypes(<bang>0)
line 10:     endif
line 11:   endfor
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 9: command!      -bang -nargs=* History                          call s:history(<q-args>, fzf#vim#with_preview(), <bang>0)
line 10:     endif
line 11:   endfor
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 10:     endif
line 11:   endfor
<SNR>44_defs returning #0

continuing in /home/Dante/.vim/plugged/fzf.vim/plugin/fzf.vim

line 80: 
line 81: function! s:history(arg, extra, bang)
line 91: 
line 92: function! fzf#complete(...)
line 95: 
line 96: if (has('nvim') || has('terminal') && has('patch-8.0.995')) && (s:conf('statusline', 1) || s:conf('nvim_statusline', 1))
calling <SNR>44_conf('statusline', 1)

line 1:   let conf = get(g:, 'fzf_vim', {})
line 2:   let val = get(conf, a:name, get(g:, 'fzf_' . a:name, a:default))
line 3:   return val
<SNR>44_conf returning #1

continuing in /home/Dante/.vim/plugged/fzf.vim/plugin/fzf.vim

line 97:   function! s:fzf_restore_colors()
line 113: 
line 114:   function! s:fzf_vim_term()
line 124: 
line 125:   augroup _fzf_statusline
line 126:     autocmd!
line 127:     autocmd FileType fzf call s:fzf_vim_term()
line 128:   augroup END
line 129: endif
line 130: 
line 131: if !exists('g:fzf#vim#buffers')
line 132:   let g:fzf#vim#buffers = {}
line 133: endif
line 134: 
line 135: augroup fzf_buffers
line 136:   autocmd!
line 137:   if exists('*reltimefloat')
line 138:     autocmd BufWinEnter,WinEnter * let g:fzf#vim#buffers[bufnr('')] = reltimefloat(reltime())
line 139:   else
line 140:     autocmd BufWinEnter,WinEnter * let g:fzf#vim#buffers[bufnr('')] = localtime()
line 141:   endif
line 142:   autocmd BufDelete * silent! call remove(g:fzf#vim#buffers, expand('<abuf>'))
line 143: augroup END
line 144: 
line 145: inoremap <expr> <plug>(fzf-complete-word)        fzf#vim#complete#word()
line 146: if s:is_win
line 147:   inoremap <expr> <plug>(fzf-complete-path)      fzf#vim#complete#path('dir /s/b')
line 148:   inoremap <expr> <plug>(fzf-complete-file)      fzf#vim#complete#path('dir /s/b/a:-d')
line 149: else
line 150:   inoremap <expr> <plug>(fzf-complete-path)      fzf#vim#complete#path("find . -path '*/\.*' -prune -o -print \| sed '1d;s:^..::'")
line 151:   inoremap <expr> <plug>(fzf-complete-file)      fzf#vim#complete#path("find . -path '*/\.*' -prune -o -type f -print -o -type l -print \| sed 's:^..::'")
line 152: endif
line 153: inoremap <expr> <plug>(fzf-complete-file-ag)     fzf#vim#complete#path('ag -l -g ""')
line 154: inoremap <expr> <plug>(fzf-complete-line)        fzf#vim#complete#line()
line 155: inoremap <expr> <plug>(fzf-complete-buffer-line) fzf#vim#complete#buffer_line()
line 156: 
line 157: nnoremap <silent> <plug>(fzf-maps-n) :<c-u>call fzf#vim#maps('n', 0)<cr>
line 158: inoremap <silent> <plug>(fzf-maps-i) <c-o>:call fzf#vim#maps('i', 0)<cr>
line 159: xnoremap <silent> <plug>(fzf-maps-x) :<c-u>call fzf#vim#maps('x', 0)<cr>
line 160: onoremap <silent> <plug>(fzf-maps-o) <c-c>:<c-u>call fzf#vim#maps('o', 0)<cr>
line 161: 
line 162: let &cpo = s:cpo_save
line 163: unlet s:cpo_save
line 164: 
finished sourcing /home/Dante/.vim/plugged/fzf.vim/plugin/fzf.vim
Searching for "/home/Dante/.vim/plugged/vim-wayland-clipboard/plugin/**/*.vim"
chdir(/home/Dante/.vim/plugged/vim-wayland-clipboard/plugin)
fchdir() to previous dir
sourcing "/home/Dante/.vim/plugged/vim-wayland-clipboard/plugin/wayland_clipboard.vim"
line 1: " wayland-clipboard.vim - Integrate with Wayland's clipboard when using the '+'
line 2: " register. Requires wl-clipboard and the +eval and +clipboard Vim features.
line 3: "
line 4: " This script was inspired by
line 5: " https://www.reddit.com/r/Fedora/comments/ax9p9t/vim_and_system_clipboard_under_wayland/
line 6: " but uses an autocmd to allow yanking with operators to work.
line 7: 
line 8: " Early exit checks {{{
line 9: 
line 10: " only load this script once
line 11: if exists('g:loaded_wayland_clipboard')
line 12:     finish
line 13: endif
line 14: let g:loaded_wayland_clipboard = 1
line 15: 
line 16: " only run this in Vim on Wayland -- Vim on X has native clipboard support,
line 17: " and Neovim already works with wl-copy by default
line 18: if has('nvim') || empty($WAYLAND_DISPLAY)
line 19:     finish
line 20: endif
line 21: 
line 22: " }}}
line 23: 
line 24: " Yanking {{{
line 25: 
line 26: " The '+' register doesn't work for yanking if:
line 27: " - vim was built without 'clipboard'.
line 28: " - x11 / xwayland is unavailable.
line 29: " (https://github.com/vim/vim/blob/93197fde0f1db09b1e495cf3eb14a8f42c318b80/src/register.c#L247)
line 30: "
line 31: " My solution is to map '"+' to '"w' and send the 'w' register to the
line 32: " Wayland clipboard as well.
line 33: "
line 34: " This variable controls whether '"+' gets mapped to '"w'. It's on by default
line 35: " if the 'clipboard' feature isn't available, or if $DISPLAY isn't set,
line 36: " but the user can turn it off always if desired.
line 37: let s:plus_to_w = (!has('clipboard') || empty($DISPLAY)) && !exists('g:wayland_clipboard_no_plus_to_w')
line 38: 
line 39: " remap '"+' to '"w' -- this will only apply to yanking since '"+p' and '"+P'
line 40: " are also remapped below
line 41: if s:plus_to_w
line 42:     nnoremap "+ "w
line 43:     vnoremap "+ "w
line 44: endif
line 45: 
line 46: let s:copy_args = exists('g:wayland_clipboard_copy_args') ? g:wayland_clipboard_copy_args : []
line 47: 
line 48: " pass register contents to wl-copy if the '+' (or 'w') register was used
line 49: function! s:WaylandYank()
line 59: 
line 60: " run s:WaylandYank() after every time text is yanked
line 61: augroup waylandyank
line 62:     autocmd!
line 63:     autocmd TextYankPost * call s:WaylandYank()
line 64: augroup END
line 65: 
line 66: " }}}
line 67: 
line 68: " Pasting {{{
line 69: 
line 70: " remap paste commands to first pull in clipboard contents with wl-paste
line 71: 
line 72: let s:paste_args = exists('g:wayland_clipboard_paste_args') ? g:wayland_clipboard_paste_args : []
line 73: let s:paste_args_str = empty(s:paste_args) ? '' : ' ' . join(s:paste_args)
line 74: 
line 75: function! s:clipboard_to_unnamed()
line 78: 
line 79: function! s:put(p, fallback)
line 87: 
line 88: function! s:ctrl_r(cr)
line 92: 
line 93: nnoremap <expr> <silent> "+p <SID>put('p', v:false)
line 94: nnoremap <expr> <silent> "+P <SID>put('P', v:false)
line 95: nnoremap <expr> <silent> p <SID>put('p', &clipboard !~ 'unnamedplus')
line 96: nnoremap <expr> <silent> P <SID>put('P', &clipboard !~ 'unnamedplus')
line 97: 
line 98: vnoremap <expr> <silent> "+p <SID>put('p', v:false)
line 99: vnoremap <expr> <silent> "+P <SID>put('P', v:false)
line 100: vnoremap <expr> <silent> p <SID>put('p', &clipboard !~ 'unnamedplus')
line 101: vnoremap <expr> <silent> P <SID>put('P', &clipboard !~ 'unnamedplus')
line 102: 
line 103: inoremap <expr> <silent> <C-R>+ <SID>ctrl_r("\<C-R>")
line 104: inoremap <expr> <silent> <C-R><C-R>+ <SID>ctrl_r("\<C-R>\<C-R>")
line 105: inoremap <expr> <silent> <C-R><C-O>+ <SID>ctrl_r("\<C-R>\<C-O>")
line 106: inoremap <expr> <silent> <C-R><C-P>+ <SID>ctrl_r("\<C-R>\<C-P>")
line 107: 
line 108: " }}}
line 109: 
line 110: " vim:foldmethod=marker:foldlevel=0
finished sourcing /home/Dante/.vim/plugged/vim-wayland-clipboard/plugin/wayland_clipboard.vim
Searching for "/home/Dante/.vim/plugged/coc.nvim/plugin/**/*.vim"
chdir(/home/Dante/.vim/plugged/coc.nvim/plugin)
fchdir() to previous dir
sourcing "/home/Dante/.vim/plugged/coc.nvim/plugin/coc.vim"
line 1: scriptencoding utf-8
line 2: if exists('g:did_coc_loaded') || v:version < 800
line 3:   finish
line 4: endif
line 5: 
line 6: function! s:checkVersion() abort
line 28: 
line 29: call s:checkVersion()
calling <SNR>46_checkVersion()

line 1:   let l:unsupported = 0
line 2:   if get(g:, 'coc_disable_startup_warning', 0) != 1
line 3:     if has('nvim')
line 4:       let l:unsupported = !has('nvim-0.8.0')
line 5:     else
line 6:       let l:unsupported = !has('patch-9.0.0438')
line 7:     endif
line 8: 
line 9:     if l:unsupported == 1
line 10:       echohl Error
line 11:       echom "coc.nvim requires at least Vim 9.0.0438 or Neovim 0.8.0, but you're using an older version."
line 12:       echom "Please upgrade your (neo)vim."
line 13:       echom "You can add this to your vimrc to avoid this message:"
line 14:       echom "    let g:coc_disable_startup_warning = 1"
line 15:       echom "Note that some features may error out or behave incorrectly."
line 16:       echom "Please do not report bugs unless you're using at least Vim 9.0.0438 or Neovim 0.8.0."
line 17:       echohl None
line 18:       sleep 2
line 19:     endif
line 20:   endif
<SNR>46_checkVersion returning #0

continuing in /home/Dante/.vim/plugged/coc.nvim/plugin/coc.vim

line 30: 
line 31: let g:did_coc_loaded = 1
line 32: let g:coc_service_initialized = 0
line 33: let s:root = expand('<sfile>:h:h')
line 34: let s:is_vim = !has('nvim')
line 35: let s:is_gvim = s:is_vim && has("gui_running")
line 36: 
line 37: if get(g:, 'coc_start_at_startup', 1) && !s:is_gvim
line 38:   call coc#rpc#start_server()
Searching for "autoload/coc/rpc.vim" in "/home/Dante/.vim,/home/Dante/.vim/plugged/onedark.vim,/home/Dante/.vim/plugged/onehalf/vim,/home/Dante/.vim/plugged/gruvbox,/home/Dante/.vim/plugged/lightline.vim,/home/Dante/.vim/plugged/vim-tmux-navigator,/home/Dante/.vim/plugged/vimtex,/home/Dante/.vim/plugged/nerdtree,/home/Dante/.vim/plugged/fzf,/home/Dante/.vim/plugged/fzf.vim,/home/Dante/.vim/plugged/vim-wayland-clipboard,/home/Dante/.vim/plugged/coc.nvim,/home/Dante/.vim/plugged/vim-obsession,/usr/share/vim/vimfiles,/usr/share/vim/vim91,/usr/share/vim/vimfiles/after,/home/Dante/.vim/plugged/vimtex/after,/home/Dante/.vim/after"
Searching for "/home/Dante/.vim/autoload/coc/rpc.vim"
Searching for "/home/Dante/.vim/plugged/onedark.vim/autoload/coc/rpc.vim"
Searching for "/home/Dante/.vim/plugged/onehalf/vim/autoload/coc/rpc.vim"
Searching for "/home/Dante/.vim/plugged/gruvbox/autoload/coc/rpc.vim"
Searching for "/home/Dante/.vim/plugged/lightline.vim/autoload/coc/rpc.vim"
Searching for "/home/Dante/.vim/plugged/vim-tmux-navigator/autoload/coc/rpc.vim"
Searching for "/home/Dante/.vim/plugged/vimtex/autoload/coc/rpc.vim"
Searching for "/home/Dante/.vim/plugged/nerdtree/autoload/coc/rpc.vim"
Searching for "/home/Dante/.vim/plugged/fzf/autoload/coc/rpc.vim"
Searching for "/home/Dante/.vim/plugged/fzf.vim/autoload/coc/rpc.vim"
Searching for "/home/Dante/.vim/plugged/vim-wayland-clipboard/autoload/coc/rpc.vim"
Searching for "/home/Dante/.vim/plugged/coc.nvim/autoload/coc/rpc.vim"
chdir(/home/Dante/.vim/plugged/coc.nvim/autoload/coc)
fchdir() to previous dir
line 38: sourcing "/home/Dante/.vim/plugged/coc.nvim/autoload/coc/rpc.vim"
line 1: scriptencoding utf-8
line 2: let s:is_win = has("win32") || has("win64")
line 3: let s:client = v:null
line 4: let s:name = 'coc'
line 5: let s:is_vim = !has('nvim')
line 6: let s:chan_id = 0
line 7: let s:root = expand('<sfile>:h:h:h')
line 8: 
line 9: function! coc#rpc#start_server()
line 74: 
line 75: function! coc#rpc#started() abort
line 78: 
line 79: function! coc#rpc#ready()
line 85: 
line 86: " Used for test on neovim only
line 87: function! coc#rpc#set_channel(chan_id) abort
line 92: 
line 93: function! coc#rpc#get_channel() abort
line 99: 
line 100: function! coc#rpc#kill()
line 109: 
line 110: function! coc#rpc#show_errors()
line 121: 
line 122: function! coc#rpc#stop()
line 136: 
line 137: function! coc#rpc#restart()
line 165: 
line 166: function! coc#rpc#close_connection() abort
line 181: 
line 182: function! coc#rpc#request(method, args) abort
line 188: 
line 189: function! coc#rpc#notify(method, args) abort
line 196: 
line 197: function! coc#rpc#request_async(method, args, cb) abort
line 203: 
line 204: " receive async response
line 205: function! coc#rpc#async_response(id, resp, isErr) abort
line 211: 
line 212: " send async response to server
line 213: function! coc#rpc#async_request(id, method, args)
line 222: 
line 223: function! s:check_vim_enter() abort
line 228: 
line 229: " Used on vim and remote address only
line 230: function! s:on_channel_close() abort
finished sourcing /home/Dante/.vim/plugged/coc.nvim/autoload/coc/rpc.vim
continuing in /home/Dante/.vim/plugged/coc.nvim/plugin/coc.vim
calling coc#rpc#start_server()

line 1:   let test = get(g:, 'coc_node_env', '') ==# 'test'
line 2:   if test && !s:is_vim && !exists('$COC_NVIM_REMOTE_ADDRESS')
line 3:     " server already started, chan_id could be available later
line 4:     let s:client = coc#client#create(s:name, [])
line 5:     let s:client['running'] = s:chan_id != 0
line 6:     let s:client['chan_id'] = s:chan_id
line 7:     return
line 8:   endif
line 9:   if exists('$COC_NVIM_REMOTE_ADDRESS')
line 10:     let address = $COC_NVIM_REMOTE_ADDRESS
line 11:     if s:is_vim
line 12:       let s:client = coc#client#create(s:name, [])
line 13:       " TODO don't know if vim support named pipe on windows.
line 14:       let address = address =~# ':\d\+$' ? address : 'unix:'.address
line 15:       let channel = ch_open(address, { 'mode': 'json', 'close_cb': {channel -> s:on_channel_close()}, 'noblock': 1, 'timeout': 1000, })
line 21:       if ch_status(channel) == 'open'
line 22:         let s:client['running'] = 1
line 23:         let s:client['channel'] = channel
line 24:       endif
line 25:     else
line 26:       let s:client = coc#client#create(s:name, [])
line 27:       try
line 28:         let mode = address =~# ':\d\+$' ? 'tcp' : 'pipe'
line 29:         let chan_id = sockconnect(mode, address, { 'rpc': 1 })
line 30:         if chan_id > 0
line 31:           let s:client['running'] = 1
line 32:           let s:client['chan_id'] = chan_id
line 33:         endif
line 34:       catch /connection\ refused/
line 35:         " ignroe
line 36:       endtry
line 37:     endif
line 38:     if !s:client['running']
line 39:       echohl Error | echom '[coc.nvim] Unable connect to '.address.' from variable $COC_NVIM_REMOTE_ADDRESS' | echohl None
line 39:  echom '[coc.nvim] Unable connect to '.address.' from variable $COC_NVIM_REMOTE_ADDRESS' | echohl None
line 39:  echohl None
line 40:     elseif !test
line 41:       let logfile = exists('$NVIM_COC_LOG_FILE') ? $NVIM_COC_LOG_FILE : ''
line 42:       let loglevel = exists('$NVIM_COC_LOG_LEVEL') ? $NVIM_COC_LOG_LEVEL : ''
line 43:       let runtimepath = join(globpath(&runtimepath, "", 0, 1), ",")
line 44:       let data = [s:root, coc#util#get_data_home(), coc#util#get_config_home(), logfile, loglevel, runtimepath]
line 45:       if s:is_vim
line 46:         call ch_sendraw(s:client['channel'], json_encode(data)."\n")
line 47:       else
line 48:         call call('rpcnotify', [s:client['chan_id'], 'init'] + data)
line 49:       endif
line 50:     endif
line 51:     return
line 52:   endif
line 53:   if empty(s:client)
line 54:     let cmd = coc#util#job_command()
Searching for "autoload/coc/util.vim" in "/home/Dante/.vim,/home/Dante/.vim/plugged/onedark.vim,/home/Dante/.vim/plugged/onehalf/vim,/home/Dante/.vim/plugged/gruvbox,/home/Dante/.vim/plugged/lightline.vim,/home/Dante/.vim/plugged/vim-tmux-navigator,/home/Dante/.vim/plugged/vimtex,/home/Dante/.vim/plugged/nerdtree,/home/Dante/.vim/plugged/fzf,/home/Dante/.vim/plugged/fzf.vim,/home/Dante/.vim/plugged/vim-wayland-clipboard,/home/Dante/.vim/plugged/coc.nvim,/home/Dante/.vim/plugged/vim-obsession,/usr/share/vim/vimfiles,/usr/share/vim/vim91,/usr/share/vim/vimfiles/after,/home/Dante/.vim/plugged/vimtex/after,/home/Dante/.vim/after"
Searching for "/home/Dante/.vim/autoload/coc/util.vim"
Searching for "/home/Dante/.vim/plugged/onedark.vim/autoload/coc/util.vim"
Searching for "/home/Dante/.vim/plugged/onehalf/vim/autoload/coc/util.vim"
Searching for "/home/Dante/.vim/plugged/gruvbox/autoload/coc/util.vim"
Searching for "/home/Dante/.vim/plugged/lightline.vim/autoload/coc/util.vim"
Searching for "/home/Dante/.vim/plugged/vim-tmux-navigator/autoload/coc/util.vim"
Searching for "/home/Dante/.vim/plugged/vimtex/autoload/coc/util.vim"
Searching for "/home/Dante/.vim/plugged/nerdtree/autoload/coc/util.vim"
Searching for "/home/Dante/.vim/plugged/fzf/autoload/coc/util.vim"
Searching for "/home/Dante/.vim/plugged/fzf.vim/autoload/coc/util.vim"
Searching for "/home/Dante/.vim/plugged/vim-wayland-clipboard/autoload/coc/util.vim"
Searching for "/home/Dante/.vim/plugged/coc.nvim/autoload/coc/util.vim"
chdir(/home/Dante/.vim/plugged/coc.nvim/autoload/coc)
fchdir() to previous dir
line 54: sourcing "/home/Dante/.vim/plugged/coc.nvim/autoload/coc/util.vim"
line 1: scriptencoding utf-8
line 2: let s:root = expand('<sfile>:h:h:h')
line 3: let s:is_win = has('win32') || has('win64')
line 4: let s:is_vim = !has('nvim')
line 5: let s:vim_api_version = 34
line 6: 
line 7: function! coc#util#merge_winhl(curr, hls) abort
line 19: 
line 20: function! coc#util#api_version() abort
line 23: 
line 24: function! coc#util#semantic_hlgroups() abort
line 29: 
line 30: " get cursor position
line 31: function! coc#util#cursor()
line 34: 
line 35: function! coc#util#change_info() abort
line 38: 
line 39: function! coc#util#jumpTo(line, character) abort
line 43: 
line 44: function! coc#util#root_patterns() abort
line 47: 
line 48: function! coc#util#get_config(key) abort
line 51: 
line 52: function! coc#util#open_terminal(opts) abort
line 55: 
line 56: function! coc#util#synname() abort
line 59: 
line 60: function! coc#util#setline(lnum, line)
line 63: 
line 64: function! coc#util#path_replace_patterns() abort
line 76: 
line 77: function! coc#util#version()
line 85: 
line 86: function! coc#util#check_refresh(bufnr)
line 95: 
line 96: function! coc#util#diagnostic_info(bufnr, checkInsert) abort
line 120: 
line 121: function! coc#util#open_file(cmd, file)
line 125: 
line 126: function! coc#util#job_command()
line 146: 
line 147: function! coc#util#jump(cmd, filepath, ...) abort
line 189: 
line 190: function! s:safer_open(cmd, file) abort
line 222: 
line 223: function! coc#util#variables(bufnr) abort
line 233: 
line 234: function! coc#util#with_callback(method, args, cb)
line 246: 
line 247: function! coc#util#timer(method, args)
line 250: 
line 251: function! s:Call(method, args)
line 259: 
line 260: function! coc#util#vim_info()
line 297: 
line 298: function! coc#util#all_state()
line 306: 
line 307: function! coc#util#install() abort
line 314: 
line 315: function! coc#util#extension_root() abort
line 318: 
line 319: function! coc#util#update_extensions(...) abort
line 327: 
line 328: function! coc#util#install_extension(args) abort
line 337: 
line 338: function! coc#util#do_autocmd(name) abort
line 343: 
line 344: function! coc#util#unmap(bufnr, keys) abort
line 351: 
line 352: function! coc#util#refactor_foldlevel(lnum) abort
line 358: 
line 359: function! coc#util#refactor_fold_text(lnum) abort
line 367: 
line 368: " get tabsize & expandtab option
line 369: function! coc#util#get_format_opts(bufnr) abort
line 383: 
line 384: function! coc#util#get_editoroption(winid) abort
line 409: 
line 410: function! coc#util#tabnr_id(tabnr) abort
line 413: 
line 414: function! coc#util#get_loaded_bufs() abort
line 417: 
line 418: function! coc#util#editor_infos() abort
line 438: 
line 439: function! coc#util#tabpages() abort
line 445: 
line 446: function! coc#util#getpid()
line 453: 
line 454: " Get indentkeys for indent on TextChangedP, consider = for word indent only.
line 455: function! coc#util#get_indentkeys() abort
line 464: 
line 465: function! coc#util#get_bufoptions(bufnr, max) abort
line 496: 
line 497: function! coc#util#bufsize(bufnr) abort
line 507: 
line 508: function! coc#util#get_config_home()
line 537: 
line 538: function! coc#util#get_data_home()
line 565: 
line 566: function! coc#util#get_complete_option()
line 592: 
line 593: " used by vim
line 594: function! coc#util#get_buf_lines(bufnr, changedtick)
line 607: 
line 608: " used for TextChangedI with InsertCharPre
line 609: function! coc#util#get_changeinfo(bufnr)
line 625: 
line 626: " Get the valid position from line, character of current buffer
line 627: function! coc#util#valid_position(line, character) abort
line 635: 
line 636: function! s:visible_ranges(winid) abort
finished sourcing /home/Dante/.vim/plugged/coc.nvim/autoload/coc/util.vim
continuing in coc#rpc#start_server
calling coc#util#job_command()

line 1:   if (has_key(g:, 'coc_node_path'))
line 2:     let node = expand(g:coc_node_path)
line 3:   else
line 4:     let node = $COC_NODE_PATH == '' ? 'node' : $COC_NODE_PATH
line 5:   endif
line 6:   if !executable(node)
line 7:     echohl Error | echom '[coc.nvim] "'.node.'" is not executable, checkout https://nodejs.org/en/download/' | echohl None
line 7:  echom '[coc.nvim] "'.node.'" is not executable, checkout https://nodejs.org/en/download/' | echohl None
line 7:  echohl None
line 8:     return
line 9:   endif
line 10:   if !filereadable(s:root.'/build/index.js')
line 11:     if isdirectory(s:root.'/src')
line 12:       echohl Error | echom '[coc.nvim] build/index.js not found, please install dependencies and compile coc.nvim by: npm ci' | echohl None
line 12:  echom '[coc.nvim] build/index.js not found, please install dependencies and compile coc.nvim by: npm ci' | echohl None
line 12:  echohl None
line 13:     else
line 14:       echohl Error | echon '[coc.nvim] your coc.nvim is broken.' | echohl None
line 14:  echon '[coc.nvim] your coc.nvim is broken.' | echohl None
line 14:  echohl None
line 15:     endif
line 16:     return
line 17:   endif
line 18:   return [node] + get(g:, 'coc_node_args', ['--no-warnings']) + [s:root.'/build/index.js']
coc#util#job_command returning ['node', '--no-warnings', '/home/Dante/.vim/plugged/coc.nvim/build/index.js']

continuing in coc#rpc#start_server

line 55:     if empty(cmd) | return | endif
line 55:  return | endif
line 55:  endif
line 56:     let $COC_VIMCONFIG = coc#util#get_config_home()
calling coc#util#get_config_home()

line 1:   if !empty(get(g:, 'coc_config_home', ''))
line 2:       return resolve(expand(g:coc_config_home))
line 3:   endif
line 4:   if exists('$VIMCONFIG')
line 5:     return resolve($VIMCONFIG)
line 6:   endif
line 7:   if has('nvim')
line 8:     let appname = empty($NVIM_APPNAME) ? 'nvim' : $NVIM_APPNAME
line 9:     if exists('$XDG_CONFIG_HOME')
line 10:       return resolve($XDG_CONFIG_HOME."/".appname)
line 11:     endif
line 12:     if s:is_win
line 13:       return resolve($HOME.'/AppData/Local/'.appname)
line 14:     endif
line 15:     return resolve($HOME.'/.config/'.appname)
line 16:   else
line 17:     if s:is_win
line 18:       return resolve($HOME."/vimfiles")
line 19:     endif
line 20:     if isdirectory(resolve($HOME.'/.vim'))
line 21:       return resolve($HOME.'/.vim')
coc#util#get_config_home returning '/home/Dante/.vim'

continuing in coc#rpc#start_server

line 57:     let $COC_DATA_HOME = coc#util#get_data_home()
calling coc#util#get_data_home()

line 1:   if get(g:, 'coc_node_env', '') ==# 'test'
line 2:     return $COC_DATA_HOME
line 3:   endif
line 4:   if !empty(get(g:, 'coc_data_home', ''))
line 5:     let dir = resolve(expand(g:coc_data_home))
line 6:   else
line 7:     if exists('$XDG_CONFIG_HOME') && isdirectory(resolve($XDG_CONFIG_HOME))
line 8:       let dir = resolve($XDG_CONFIG_HOME."/coc")
line 9:     else
line 10:       if s:is_win
line 11:         let dir = resolve(expand('~/AppData/Local/coc'))
line 12:       else
line 13:         let dir = resolve(expand('~/.config/coc'))
line 14:       endif
line 15:     endif
line 16:   endif
line 17:   if !isdirectory(dir)
line 18:     call coc#notify#create(['creating coc.nvim data directory: '.dir], { 'borderhighlight': 'CocInfoSign', 'timeout': 5000, 'kind': 'info', })
line 23:     call mkdir(dir, "p", 0755)
line 24:   endif
line 25:   return dir
coc#util#get_data_home returning '/home/Dante/.config/coc'

continuing in coc#rpc#start_server

line 58:     let s:client = coc#client#create(s:name, cmd)
Searching for "autoload/coc/client.vim" in "/home/Dante/.vim,/home/Dante/.vim/plugged/onedark.vim,/home/Dante/.vim/plugged/onehalf/vim,/home/Dante/.vim/plugged/gruvbox,/home/Dante/.vim/plugged/lightline.vim,/home/Dante/.vim/plugged/vim-tmux-navigator,/home/Dante/.vim/plugged/vimtex,/home/Dante/.vim/plugged/nerdtree,/home/Dante/.vim/plugged/fzf,/home/Dante/.vim/plugged/fzf.vim,/home/Dante/.vim/plugged/vim-wayland-clipboard,/home/Dante/.vim/plugged/coc.nvim,/home/Dante/.vim/plugged/vim-obsession,/usr/share/vim/vimfiles,/usr/share/vim/vim91,/usr/share/vim/vimfiles/after,/home/Dante/.vim/plugged/vimtex/after,/home/Dante/.vim/after"
Searching for "/home/Dante/.vim/autoload/coc/client.vim"
Searching for "/home/Dante/.vim/plugged/onedark.vim/autoload/coc/client.vim"
Searching for "/home/Dante/.vim/plugged/onehalf/vim/autoload/coc/client.vim"
Searching for "/home/Dante/.vim/plugged/gruvbox/autoload/coc/client.vim"
Searching for "/home/Dante/.vim/plugged/lightline.vim/autoload/coc/client.vim"
Searching for "/home/Dante/.vim/plugged/vim-tmux-navigator/autoload/coc/client.vim"
Searching for "/home/Dante/.vim/plugged/vimtex/autoload/coc/client.vim"
Searching for "/home/Dante/.vim/plugged/nerdtree/autoload/coc/client.vim"
Searching for "/home/Dante/.vim/plugged/fzf/autoload/coc/client.vim"
Searching for "/home/Dante/.vim/plugged/fzf.vim/autoload/coc/client.vim"
Searching for "/home/Dante/.vim/plugged/vim-wayland-clipboard/autoload/coc/client.vim"
Searching for "/home/Dante/.vim/plugged/coc.nvim/autoload/coc/client.vim"
chdir(/home/Dante/.vim/plugged/coc.nvim/autoload/coc)
fchdir() to previous dir
line 58: sourcing "/home/Dante/.vim/plugged/coc.nvim/autoload/coc/client.vim"
line 1: scriptencoding utf-8
line 2: let s:root = expand('<sfile>:h:h:h')
line 3: let s:is_vim = !has('nvim')
line 4: let s:is_win = has("win32") || has("win64")
line 5: let s:clients = {}
line 6: 
line 7: if get(g:, 'node_client_debug', 0)
line 8:   echohl WarningMsg | echo '[coc.nvim] Enable g:node_client_debug could impact your vim experience' | echohl None
line 8:  echo '[coc.nvim] Enable g:node_client_debug could impact your vim experience' | echohl None
line 8:  echohl None
line 9:   let $NODE_CLIENT_LOG_LEVEL = 'debug'
line 10:   if exists('$NODE_CLIENT_LOG_FILE')
line 11:     let s:logfile = resolve($NODE_CLIENT_LOG_FILE)
line 12:   else
line 13:     let s:logfile = tempname()
line 14:     let $NODE_CLIENT_LOG_FILE = s:logfile
line 15:   endif
line 16: endif
line 17: 
line 18: " create a client
line 19: function! coc#client#create(name, command)
line 38: 
line 39: function! s:start() dict
line 90: 
line 91: function! s:on_stderr(name, msgs)
line 104: 
line 105: function! coc#client#check_version() abort
line 128: 
line 129: function! s:on_exit(name, code) abort
line 142: 
line 143: function! coc#client#get_client(name) abort
line 146: 
line 147: function! coc#client#get_channel(client)
line 153: 
line 154: function! s:request(method, args) dict
line 190: 
line 191: function! s:notify(method, args) dict
line 218: 
line 219: function! s:request_async(method, args, cb) dict
line 231: 
line 232: function! s:on_async_response(id, resp, isErr) dict
line 246: 
line 247: function! coc#client#is_running(name) abort
line 264: 
line 265: function! coc#client#stop(name) abort
line 287: 
line 288: function! coc#client#kill(name) abort
line 303: 
line 304: function! coc#client#request(name, method, args)
line 310: 
line 311: function! coc#client#notify(name, method, args)
line 317: 
line 318: function! coc#client#request_async(name, method, args, cb)
line 324: 
line 325: function! coc#client#on_response(name, id, resp, isErr)
line 331: 
line 332: function! coc#client#restart(name) abort
line 340: 
line 341: function! coc#client#restart_all()
line 346: 
line 347: function! coc#client#open_log()
line 354: 
line 355: function! s:on_error(name, msgs) abort
finished sourcing /home/Dante/.vim/plugged/coc.nvim/autoload/coc/client.vim
continuing in coc#rpc#start_server
calling coc#client#create('coc', ['node', '--no-warnings', '/home/Dante/.vim/plugged/coc.nvim/build/index.js'])

line 1:   let client = {}
line 2:   let client['command'] = a:command
line 3:   let client['name'] = a:name
line 4:   let client['running'] = 0
line 5:   let client['async_req_id'] = 1
line 6:   let client['async_callbacks'] = {}
line 7:   " vim only
line 8:   let client['channel'] = v:null
line 9:   " neovim only
line 10:   let client['chan_id'] = 0
line 11:   let client['start'] = function('s:start', [], client)
line 12:   let client['request'] = function('s:request', [], client)
line 13:   let client['notify'] = function('s:notify', [], client)
line 14:   let client['request_async'] = function('s:request_async', [], client)
line 15:   let client['on_async_response'] = function('s:on_async_response', [], client)
line 16:   let s:clients[a:name] = client
line 17:   return client

continuing in coc#rpc#start_server

line 59:   endif
line 60:   if !coc#client#is_running('coc')
calling coc#client#is_running('coc')

line 1:   let client = get(s:clients, a:name, v:null)
line 2:   if empty(client) | return 0 | endif
line 2:  return 0 | endif
line 2:  endif
line 3:   if !client['running'] | return 0 | endif
line 3:  return 0 | endif
coc#client#is_running returning #0

continuing in coc#rpc#start_server

line 61:     call s:client['start']()
calling <SNR>49_start()

line 1:   if self.running | return | endif
line 1:  return | endif
line 1:  endif
line 2:   if !isdirectory(getcwd())
line 3:     echoerr '[coc.nvim] Current cwd is not a valid directory.'
line 4:     return
line 5:   endif
line 6:   let tmpdir = fnamemodify(tempname(), ':p:h')
line 7:   if s:is_vim
line 8:     if get(g:, 'node_client_debug', 0)
line 9:       let file = tmpdir . '/coc.log'
line 10:       call ch_logfile(file, 'w')
line 11:       echohl MoreMsg | echo '[coc.nvim] channel log to '.file | echohl None
line 11:  echo '[coc.nvim] channel log to '.file | echohl None
line 11:  echohl None
line 12:     endif
line 13:     let options = { 'noblock': 1, 'in_mode': 'json', 'out_mode': 'json', 'err_mode': 'nl', 'err_cb': {channel, message -> s:on_stderr(self.name, split(message, "\n"))}, 'exit_cb': {channel, code -> s:on_exit(self.name, code)}, 'env': { 'NODE_NO_WARNINGS': '1', 'VIM_NODE_RPC': '1', 'TMPDIR': tmpdir, }}
line 26:     let job = job_start(self.command, options)
line 27:     let status = job_status(job)
line 28:     if status !=# 'run'
line 29:       let self.running = 0
line 30:       echohl Error | echom 'Failed to start '.self.name.' service' | echohl None
line 30:  echom 'Failed to start '.self.name.' service' | echohl None
line 30:  echohl None
line 31:       return
line 32:     endif
line 33:     let self['running'] = 1
line 34:     let self['channel'] = job_getchannel(job)
line 35:   else
line 36:     let opts = { 'rpc': 1, 'on_stderr': {channel, msgs -> s:on_stderr(self.name, msgs)}, 'on_exit': {channel, code -> s:on_exit(self.name, code)}, 'env': { 'NODE_NO_WARNINGS': '1', 'TMPDIR': tmpdir } }
line 42:     let chan_id = jobstart(self.command, opts)
line 43:     if chan_id <= 0
line 44:       echohl Error | echom 'Failed to start '.self.name.' service' | echohl None
line 44:  echom 'Failed to start '.self.name.' service' | echohl None
line 44:  echohl None
line 45:       return
line 46:     endif
line 47:     let self['chan_id'] = chan_id
line 48:     let self['running'] = 1
line 49:   endif
<SNR>49_start returning #0

continuing in coc#rpc#start_server

line 62:   endif
line 63:   call s:check_vim_enter()
calling <SNR>47_check_vim_enter()

line 1:   if s:client['running'] && v:vim_did_enter
line 2:     call coc#rpc#notify('VimEnter', [coc#util#path_replace_patterns(), join(globpath(&runtimepath, "", 0, 1), ",")])
line 3:   endif
<SNR>47_check_vim_enter returning #0

continuing in coc#rpc#start_server

coc#rpc#start_server returning #0

continuing in /home/Dante/.vim/plugged/coc.nvim/plugin/coc.vim

line 39: endif
line 40: 
line 41: function! CocTagFunc(pattern, flags, info) abort
line 48: 
line 49: " Used by popup prompt on vim
line 50: function! CocPopupCallback(bufnr, arglist) abort
line 76: 
line 77: function! CocAction(name, ...) abort
line 83: 
line 84: function! CocHasProvider(name, ...) abort
line 88: 
line 89: function! CocActionAsync(name, ...) abort
line 92: 
line 93: function! CocRequest(...) abort
line 96: 
line 97: function! CocNotify(...) abort
line 100: 
line 101: function! CocRegisterNotification(id, method, cb) abort
line 104: 
line 105: " Deprecated, use CocRegisterNotification instead
line 106: function! CocRegistNotification(id, method, cb) abort
line 109: 
line 110: function! CocLocations(id, method, ...) abort
line 114: 
line 115: function! CocLocationsAsync(id, method, ...) abort
line 119: 
line 120: function! CocRequestAsync(...)
line 123: 
line 124: function! s:AsyncRequest(name, args) abort
line 137: 
line 138: function! s:CommandList(...) abort
line 142: 
line 143: function! s:ExtensionList(...) abort
line 149: 
line 150: function! s:SearchOptions(...) abort
line 157: 
line 158: function! s:LoadedExtensions(...) abort
line 162: 
line 163: function! s:InstallOptions(...)abort
line 167: 
line 168: function! s:OpenConfig()
line 185: 
line 186: function! s:get_color(item, fallback) abort
line 198: 
line 199: function! s:AddAnsiGroups() abort
line 227: 
line 228: function! s:CreateHighlight(group, fg, bg) abort
line 236: 
line 237: function! s:OpenDiagnostics(...) abort
line 246: 
line 247: function! s:Disable() abort
line 258: 
line 259: function! s:Autocmd(...) abort
line 265: 
line 266: function! s:HandleCharInsert(char, bufnr) abort
line 278: 
line 279: function! s:HandleTextChangedI(bufnr) abort
line 285: 
line 286: function! s:HandleInsertLeave(bufnr) abort
line 290: 
line 291: function! s:HandleWinScrolled(winid) abort
line 297: 
line 298: function! s:HandleWinClosed(winid) abort
line 303: 
line 304: function! s:SyncAutocmd(...)
line 310: 
line 311: function! s:VimLeavePre() abort
line 326: 
line 327: function! s:VimEnter() abort
line 337: 
line 338: function! s:Enable(initialize)
line 429: 
line 430: function! s:StaticHighlight() abort
line 483: 
line 484: call s:StaticHighlight()
calling <SNR>46_StaticHighlight()

line 1:   hi default CocSelectedText  ctermfg=Red     guifg=#fb4934 guibg=NONE
line 2:   hi default CocCodeLens      ctermfg=Gray    guifg=#999999 guibg=NONE
line 3:   hi default CocUnderline     term=underline cterm=underline gui=underline guisp=#ebdbb2
line 4:   hi default CocBold          term=bold cterm=bold gui=bold
line 5:   hi default CocItalic        term=italic cterm=italic gui=italic
line 6:   hi default CocStrikeThrough term=strikethrough cterm=strikethrough gui=strikethrough
line 7:   hi default CocMarkdownLink  ctermfg=Blue    guifg=#15aabf guibg=NONE
line 8:   hi default CocDisabled      guifg=#999999   ctermfg=gray
line 9:   hi default CocSearch        ctermfg=Blue    guifg=#15aabf guibg=NONE
line 10:   hi default CocLink          term=underline cterm=underline gui=underline guisp=#15aabf
line 11:   hi default link CocFloatActive         CocSearch
line 12:   hi default link CocFadeOut             Conceal
line 13:   hi default link CocMarkdownCode        markdownCode
line 14:   hi default link CocMarkdownHeader      markdownH1
line 15:   hi default link CocDeprecatedHighlight CocStrikeThrough
line 16:   hi default link CocUnusedHighlight     CocFadeOut
line 17:   hi default link CocListSearch          CocSearch
line 18:   hi default link CocListMode            ModeMsg
line 19:   hi default link CocListPath            Comment
line 20:   hi default link CocHighlightText       CursorColumn
line 21:   hi default link CocHoverRange          Search
line 22:   hi default link CocCursorRange         Search
line 23:   hi default link CocLinkedEditing       CocCursorRange
line 24:   hi default link CocHighlightRead       CocHighlightText
line 25:   hi default link CocHighlightWrite      CocHighlightText
line 26:   " Notification
line 27:   hi default CocNotificationProgress  ctermfg=Blue    guifg=#15aabf guibg=NONE
line 28:   hi default link CocNotificationButton  CocUnderline
line 29:   hi default link CocNotificationError   CocErrorFloat
line 30:   hi default link CocNotificationWarning CocWarningFloat
line 31:   hi default link CocNotificationInfo    CocInfoFloat
line 32:   " Snippet
line 33:   hi default link CocSnippetVisual       Visual
line 34:   " Tree view highlights
line 35:   hi default link CocTreeTitle       Title
line 36:   hi default link CocTreeDescription Comment
line 37:   hi default link CocTreeOpenClose   CocBold
line 38:   hi default link CocTreeSelected    CursorLine
line 39:   hi default link CocSelectedRange   CocHighlightText
line 40:   " Symbol highlights
line 41:   hi default link CocSymbolDefault       MoreMsg
line 42:   "Pum
line 43:   hi default link CocPumSearch           CocSearch
line 44:   hi default link CocPumDetail           Comment
line 45:   hi default link CocPumMenu             CocFloating
line 46:   hi default link CocPumShortcut         Comment
line 47:   hi default link CocPumDeprecated       CocStrikeThrough
line 48:   hi default CocVirtualText             ctermfg=12 guifg=#504945
line 49:   hi default link CocPumVirtualText        CocVirtualText
line 50:   hi default link CocInputBoxVirtualText   CocVirtualText
line 51:   hi default link CocFloatDividingLine     CocVirtualText
<SNR>46_StaticHighlight returning #0

continuing in /home/Dante/.vim/plugged/coc.nvim/plugin/coc.vim

line 485: call s:AddAnsiGroups()
calling <SNR>46_AddAnsiGroups()

line 1:   let color_map = {}
line 2:   let colors = ['#282828', '#cc241d', '#98971a', '#d79921', '#458588', '#b16286', '#689d6a', '#a89984', '#928374']
line 3:   let names = ['black', 'red', 'green', 'yellow', 'blue', 'magenta', 'cyan', 'white', 'grey']
line 4:   for i in range(0, len(names) - 1)
line 5:     let name = names[i]
line 6:     if exists('g:terminal_ansi_colors')
line 7:       let color_map[name] = s:get_color(get(g:terminal_ansi_colors, i, colors[i]), colors[i])
line 8:     else
line 9:       let color_map[name] = get(g:, 'terminal_color_'.i, colors[i])
line 10:     endif
line 11:   endfor
line 4:   for i in range(0, len(names) - 1)
line 5:     let name = names[i]
line 6:     if exists('g:terminal_ansi_colors')
line 7:       let color_map[name] = s:get_color(get(g:terminal_ansi_colors, i, colors[i]), colors[i])
line 8:     else
line 9:       let color_map[name] = get(g:, 'terminal_color_'.i, colors[i])
line 10:     endif
line 11:   endfor
line 4:   for i in range(0, len(names) - 1)
line 5:     let name = names[i]
line 6:     if exists('g:terminal_ansi_colors')
line 7:       let color_map[name] = s:get_color(get(g:terminal_ansi_colors, i, colors[i]), colors[i])
line 8:     else
line 9:       let color_map[name] = get(g:, 'terminal_color_'.i, colors[i])
line 10:     endif
line 11:   endfor
line 4:   for i in range(0, len(names) - 1)
line 5:     let name = names[i]
line 6:     if exists('g:terminal_ansi_colors')
line 7:       let color_map[name] = s:get_color(get(g:terminal_ansi_colors, i, colors[i]), colors[i])
line 8:     else
line 9:       let color_map[name] = get(g:, 'terminal_color_'.i, colors[i])
line 10:     endif
line 11:   endfor
line 4:   for i in range(0, len(names) - 1)
line 5:     let name = names[i]
line 6:     if exists('g:terminal_ansi_colors')
line 7:       let color_map[name] = s:get_color(get(g:terminal_ansi_colors, i, colors[i]), colors[i])
line 8:     else
line 9:       let color_map[name] = get(g:, 'terminal_color_'.i, colors[i])
line 10:     endif
line 11:   endfor
line 4:   for i in range(0, len(names) - 1)
line 5:     let name = names[i]
line 6:     if exists('g:terminal_ansi_colors')
line 7:       let color_map[name] = s:get_color(get(g:terminal_ansi_colors, i, colors[i]), colors[i])
line 8:     else
line 9:       let color_map[name] = get(g:, 'terminal_color_'.i, colors[i])
line 10:     endif
line 11:   endfor
line 4:   for i in range(0, len(names) - 1)
line 5:     let name = names[i]
line 6:     if exists('g:terminal_ansi_colors')
line 7:       let color_map[name] = s:get_color(get(g:terminal_ansi_colors, i, colors[i]), colors[i])
line 8:     else
line 9:       let color_map[name] = get(g:, 'terminal_color_'.i, colors[i])
line 10:     endif
line 11:   endfor
line 4:   for i in range(0, len(names) - 1)
line 5:     let name = names[i]
line 6:     if exists('g:terminal_ansi_colors')
line 7:       let color_map[name] = s:get_color(get(g:terminal_ansi_colors, i, colors[i]), colors[i])
line 8:     else
line 9:       let color_map[name] = get(g:, 'terminal_color_'.i, colors[i])
line 10:     endif
line 11:   endfor
line 4:   for i in range(0, len(names) - 1)
line 5:     let name = names[i]
line 6:     if exists('g:terminal_ansi_colors')
line 7:       let color_map[name] = s:get_color(get(g:terminal_ansi_colors, i, colors[i]), colors[i])
line 8:     else
line 9:       let color_map[name] = get(g:, 'terminal_color_'.i, colors[i])
line 10:     endif
line 11:   endfor
line 4:   for i in range(0, len(names) - 1)
line 5:     let name = names[i]
line 6:     if exists('g:terminal_ansi_colors')
line 7:       let color_map[name] = s:get_color(get(g:terminal_ansi_colors, i, colors[i]), colors[i])
line 8:     else
line 9:       let color_map[name] = get(g:, 'terminal_color_'.i, colors[i])
line 10:     endif
line 11:   endfor
line 12:   try
line 13:     for name in keys(color_map)
line 14:       let foreground = toupper(name[0]).name[1:]
line 15:       let foregroundColor = color_map[name]
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListBlackBlack guifg=#282828 guibg=#282828
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListBlackBlue guifg=#282828 guibg=#458588
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListBlackGreen guifg=#282828 guibg=#98971a
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListBlackGrey guifg=#282828 guibg=#928374
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListBlackWhite guifg=#282828 guibg=#a89984
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListBlackCyan guifg=#282828 guibg=#689d6a
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListBlackYellow guifg=#282828 guibg=#d79921
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListBlackMagenta guifg=#282828 guibg=#b16286
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListBlackRed guifg=#282828 guibg=#cc241d
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 20:       endfor
line 21:       exe 'hi default CocListFg'.foreground. ' guifg='.foregroundColor. ' ctermfg='.foreground
line 21: hi default CocListFgBlack guifg=#282828 ctermfg=Black
line 22:       exe 'hi default CocListBg'.foreground. ' guibg='.foregroundColor. ' ctermbg='.foreground
line 22: hi default CocListBgBlack guibg=#282828 ctermbg=Black
line 23:     endfor
line 13:     for name in keys(color_map)
line 14:       let foreground = toupper(name[0]).name[1:]
line 15:       let foregroundColor = color_map[name]
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListBlueBlack guifg=#458588 guibg=#282828
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListBlueBlue guifg=#458588 guibg=#458588
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListBlueGreen guifg=#458588 guibg=#98971a
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListBlueGrey guifg=#458588 guibg=#928374
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListBlueWhite guifg=#458588 guibg=#a89984
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListBlueCyan guifg=#458588 guibg=#689d6a
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListBlueYellow guifg=#458588 guibg=#d79921
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListBlueMagenta guifg=#458588 guibg=#b16286
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListBlueRed guifg=#458588 guibg=#cc241d
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 20:       endfor
line 21:       exe 'hi default CocListFg'.foreground. ' guifg='.foregroundColor. ' ctermfg='.foreground
line 21: hi default CocListFgBlue guifg=#458588 ctermfg=Blue
line 22:       exe 'hi default CocListBg'.foreground. ' guibg='.foregroundColor. ' ctermbg='.foreground
line 22: hi default CocListBgBlue guibg=#458588 ctermbg=Blue
line 23:     endfor
line 13:     for name in keys(color_map)
line 14:       let foreground = toupper(name[0]).name[1:]
line 15:       let foregroundColor = color_map[name]
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListGreenBlack guifg=#98971a guibg=#282828
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListGreenBlue guifg=#98971a guibg=#458588
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListGreenGreen guifg=#98971a guibg=#98971a
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListGreenGrey guifg=#98971a guibg=#928374
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListGreenWhite guifg=#98971a guibg=#a89984
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListGreenCyan guifg=#98971a guibg=#689d6a
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListGreenYellow guifg=#98971a guibg=#d79921
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListGreenMagenta guifg=#98971a guibg=#b16286
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListGreenRed guifg=#98971a guibg=#cc241d
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 20:       endfor
line 21:       exe 'hi default CocListFg'.foreground. ' guifg='.foregroundColor. ' ctermfg='.foreground
line 21: hi default CocListFgGreen guifg=#98971a ctermfg=Green
line 22:       exe 'hi default CocListBg'.foreground. ' guibg='.foregroundColor. ' ctermbg='.foreground
line 22: hi default CocListBgGreen guibg=#98971a ctermbg=Green
line 23:     endfor
line 13:     for name in keys(color_map)
line 14:       let foreground = toupper(name[0]).name[1:]
line 15:       let foregroundColor = color_map[name]
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListGreyBlack guifg=#928374 guibg=#282828
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListGreyBlue guifg=#928374 guibg=#458588
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListGreyGreen guifg=#928374 guibg=#98971a
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListGreyGrey guifg=#928374 guibg=#928374
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListGreyWhite guifg=#928374 guibg=#a89984
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListGreyCyan guifg=#928374 guibg=#689d6a
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListGreyYellow guifg=#928374 guibg=#d79921
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListGreyMagenta guifg=#928374 guibg=#b16286
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListGreyRed guifg=#928374 guibg=#cc241d
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 20:       endfor
line 21:       exe 'hi default CocListFg'.foreground. ' guifg='.foregroundColor. ' ctermfg='.foreground
line 21: hi default CocListFgGrey guifg=#928374 ctermfg=Grey
line 22:       exe 'hi default CocListBg'.foreground. ' guibg='.foregroundColor. ' ctermbg='.foreground
line 22: hi default CocListBgGrey guibg=#928374 ctermbg=Grey
line 23:     endfor
line 13:     for name in keys(color_map)
line 14:       let foreground = toupper(name[0]).name[1:]
line 15:       let foregroundColor = color_map[name]
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListWhiteBlack guifg=#a89984 guibg=#282828
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListWhiteBlue guifg=#a89984 guibg=#458588
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListWhiteGreen guifg=#a89984 guibg=#98971a
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListWhiteGrey guifg=#a89984 guibg=#928374
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListWhiteWhite guifg=#a89984 guibg=#a89984
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListWhiteCyan guifg=#a89984 guibg=#689d6a
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListWhiteYellow guifg=#a89984 guibg=#d79921
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListWhiteMagenta guifg=#a89984 guibg=#b16286
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListWhiteRed guifg=#a89984 guibg=#cc241d
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 20:       endfor
line 21:       exe 'hi default CocListFg'.foreground. ' guifg='.foregroundColor. ' ctermfg='.foreground
line 21: hi default CocListFgWhite guifg=#a89984 ctermfg=White
line 22:       exe 'hi default CocListBg'.foreground. ' guibg='.foregroundColor. ' ctermbg='.foreground
line 22: hi default CocListBgWhite guibg=#a89984 ctermbg=White
line 23:     endfor
line 13:     for name in keys(color_map)
line 14:       let foreground = toupper(name[0]).name[1:]
line 15:       let foregroundColor = color_map[name]
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListCyanBlack guifg=#689d6a guibg=#282828
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListCyanBlue guifg=#689d6a guibg=#458588
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListCyanGreen guifg=#689d6a guibg=#98971a
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListCyanGrey guifg=#689d6a guibg=#928374
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListCyanWhite guifg=#689d6a guibg=#a89984
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListCyanCyan guifg=#689d6a guibg=#689d6a
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListCyanYellow guifg=#689d6a guibg=#d79921
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListCyanMagenta guifg=#689d6a guibg=#b16286
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListCyanRed guifg=#689d6a guibg=#cc241d
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 20:       endfor
line 21:       exe 'hi default CocListFg'.foreground. ' guifg='.foregroundColor. ' ctermfg='.foreground
line 21: hi default CocListFgCyan guifg=#689d6a ctermfg=Cyan
line 22:       exe 'hi default CocListBg'.foreground. ' guibg='.foregroundColor. ' ctermbg='.foreground
line 22: hi default CocListBgCyan guibg=#689d6a ctermbg=Cyan
line 23:     endfor
line 13:     for name in keys(color_map)
line 14:       let foreground = toupper(name[0]).name[1:]
line 15:       let foregroundColor = color_map[name]
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListYellowBlack guifg=#d79921 guibg=#282828
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListYellowBlue guifg=#d79921 guibg=#458588
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListYellowGreen guifg=#d79921 guibg=#98971a
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListYellowGrey guifg=#d79921 guibg=#928374
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListYellowWhite guifg=#d79921 guibg=#a89984
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListYellowCyan guifg=#d79921 guibg=#689d6a
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListYellowYellow guifg=#d79921 guibg=#d79921
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListYellowMagenta guifg=#d79921 guibg=#b16286
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListYellowRed guifg=#d79921 guibg=#cc241d
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 20:       endfor
line 21:       exe 'hi default CocListFg'.foreground. ' guifg='.foregroundColor. ' ctermfg='.foreground
line 21: hi default CocListFgYellow guifg=#d79921 ctermfg=Yellow
line 22:       exe 'hi default CocListBg'.foreground. ' guibg='.foregroundColor. ' ctermbg='.foreground
line 22: hi default CocListBgYellow guibg=#d79921 ctermbg=Yellow
line 23:     endfor
line 13:     for name in keys(color_map)
line 14:       let foreground = toupper(name[0]).name[1:]
line 15:       let foregroundColor = color_map[name]
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListMagentaBlack guifg=#b16286 guibg=#282828
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListMagentaBlue guifg=#b16286 guibg=#458588
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListMagentaGreen guifg=#b16286 guibg=#98971a
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListMagentaGrey guifg=#b16286 guibg=#928374
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListMagentaWhite guifg=#b16286 guibg=#a89984
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListMagentaCyan guifg=#b16286 guibg=#689d6a
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListMagentaYellow guifg=#b16286 guibg=#d79921
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListMagentaMagenta guifg=#b16286 guibg=#b16286
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListMagentaRed guifg=#b16286 guibg=#cc241d
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 20:       endfor
line 21:       exe 'hi default CocListFg'.foreground. ' guifg='.foregroundColor. ' ctermfg='.foreground
line 21: hi default CocListFgMagenta guifg=#b16286 ctermfg=Magenta
line 22:       exe 'hi default CocListBg'.foreground. ' guibg='.foregroundColor. ' ctermbg='.foreground
line 22: hi default CocListBgMagenta guibg=#b16286 ctermbg=Magenta
line 23:     endfor
line 13:     for name in keys(color_map)
line 14:       let foreground = toupper(name[0]).name[1:]
line 15:       let foregroundColor = color_map[name]
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListRedBlack guifg=#cc241d guibg=#282828
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListRedBlue guifg=#cc241d guibg=#458588
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListRedGreen guifg=#cc241d guibg=#98971a
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListRedGrey guifg=#cc241d guibg=#928374
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListRedWhite guifg=#cc241d guibg=#a89984
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListRedCyan guifg=#cc241d guibg=#689d6a
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListRedYellow guifg=#cc241d guibg=#d79921
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListRedMagenta guifg=#cc241d guibg=#b16286
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 19: hi default CocListRedRed guifg=#cc241d guibg=#cc241d
line 20:       endfor
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 20:       endfor
line 21:       exe 'hi default CocListFg'.foreground. ' guifg='.foregroundColor. ' ctermfg='.foreground
line 21: hi default CocListFgRed guifg=#cc241d ctermfg=Red
line 22:       exe 'hi default CocListBg'.foreground. ' guibg='.foregroundColor. ' ctermbg='.foreground
line 22: hi default CocListBgRed guibg=#cc241d ctermbg=Red
line 23:     endfor
line 13:     for name in keys(color_map)
line 14:       let foreground = toupper(name[0]).name[1:]
line 15:       let foregroundColor = color_map[name]
line 16:       for key in keys(color_map)
line 17:         let background = toupper(key[0]).key[1:]
line 18:         let backgroundColor = color_map[key]
line 19:         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
line 20:       endfor
line 21:       exe 'hi default CocListFg'.foreground. ' guifg='.foregroundColor. ' ctermfg='.foreground
line 22:       exe 'hi default CocListBg'.foreground. ' guibg='.foregroundColor. ' ctermbg='.foreground
line 23:     endfor
line 24:   catch /.*/
line 25:     " ignore invalid color
line 26:   endtry
<SNR>46_AddAnsiGroups returning #0

continuing in /home/Dante/.vim/plugged/coc.nvim/plugin/coc.vim

line 486: 
line 487: function! s:Highlight() abort
line 626: 
line 627: function! s:ShowInfo()
line 661: 
line 662: function! s:CursorRangeFromSelected(type, ...) abort
line 666: 
line 667: function! s:FormatFromSelected(type)
line 670: 
line 671: function! s:CodeActionFromSelected(type)
line 674: 
line 675: function! s:CodeActionRefactorFromSelected(type)
line 678: 
line 679: command! -nargs=0 CocOutline      :call coc#rpc#notify('showOutline', [])
line 680: command! -nargs=? CocDiagnostics  :call s:OpenDiagnostics(<f-args>)
line 681: command! -nargs=0 CocInfo         :call s:ShowInfo()
line 682: command! -nargs=0 CocOpenLog      :call coc#rpc#notify('openLog',  [])
line 683: command! -nargs=0 CocDisable      :call s:Disable()
line 684: command! -nargs=0 CocEnable       :call s:Enable(0)
line 685: command! -nargs=0 CocConfig       :call s:OpenConfig()
line 686: command! -nargs=0 CocLocalConfig  :call coc#rpc#notify('openLocalConfig', [])
line 687: command! -nargs=0 CocRestart      :call coc#rpc#restart()
line 688: command! -nargs=0 CocStart        :call coc#rpc#start_server()
line 689: command! -nargs=0 CocPrintErrors  :call coc#rpc#show_errors()
line 690: command! -nargs=1 -complete=custom,s:LoadedExtensions  CocWatch    :call coc#rpc#notify('watchExtension', [<f-args>])
line 691: command! -nargs=+ -complete=custom,s:SearchOptions  CocSearch    :call coc#rpc#notify('search', [<f-args>])
line 692: command! -nargs=+ -complete=custom,s:ExtensionList  CocUninstall :call CocActionAsync('uninstallExtension', <f-args>)
line 693: command! -nargs=* -complete=custom,s:CommandList -range CocCommand :call coc#rpc#notify('runCommand', [<f-args>])
line 694: command! -nargs=* -complete=custom,coc#list#options CocList      :call coc#rpc#notify('openList',  [<f-args>])
line 695: command! -nargs=? -complete=custom,coc#list#names CocListResume   :call coc#rpc#notify('listResume', [<f-args>])
line 696: command! -nargs=? -complete=custom,coc#list#names CocListCancel   :call coc#rpc#notify('listCancel', [])
line 697: command! -nargs=? -complete=custom,coc#list#names CocPrev         :call coc#rpc#notify('listPrev', [<f-args>])
line 698: command! -nargs=? -complete=custom,coc#list#names CocNext         :call coc#rpc#notify('listNext', [<f-args>])
line 699: command! -nargs=? -complete=custom,coc#list#names CocFirst        :call coc#rpc#notify('listFirst', [<f-args>])
line 700: command! -nargs=? -complete=custom,coc#list#names CocLast         :call coc#rpc#notify('listLast', [<f-args>])
line 701: command! -nargs=0 CocUpdate       :call coc#util#update_extensions(1)
line 702: command! -nargs=0 -bar CocUpdateSync   :call coc#util#update_extensions()
line 703: command! -nargs=* -bar -complete=custom,s:InstallOptions CocInstall   :call coc#util#install_extension([<f-args>])
line 704: 
line 705: call s:Enable(1)
calling <SNR>46_Enable(1)

line 1:   if get(g:, 'coc_enabled', 0) == 1
line 2:     return
line 3:   endif
line 4: 
line 5:   let g:coc_enabled = 1
line 6:   sign define CocCurrentLine linehl=CocMenuSel
line 7:   sign define CocListCurrent linehl=CocListLine
line 8:   sign define CocTreeSelected linehl=CocTreeSelected
line 9:   if s:is_vim
line 10:     call coc#api#tabpage_ids()
Searching for "autoload/coc/api.vim" in "/home/Dante/.vim,/home/Dante/.vim/plugged/onedark.vim,/home/Dante/.vim/plugged/onehalf/vim,/home/Dante/.vim/plugged/gruvbox,/home/Dante/.vim/plugged/lightline.vim,/home/Dante/.vim/plugged/vim-tmux-navigator,/home/Dante/.vim/plugged/vimtex,/home/Dante/.vim/plugged/nerdtree,/home/Dante/.vim/plugged/fzf,/home/Dante/.vim/plugged/fzf.vim,/home/Dante/.vim/plugged/vim-wayland-clipboard,/home/Dante/.vim/plugged/coc.nvim,/home/Dante/.vim/plugged/vim-obsession,/usr/share/vim/vimfiles,/usr/share/vim/vim91,/usr/share/vim/vimfiles/after,/home/Dante/.vim/plugged/vimtex/after,/home/Dante/.vim/after"
Searching for "/home/Dante/.vim/autoload/coc/api.vim"
Searching for "/home/Dante/.vim/plugged/onedark.vim/autoload/coc/api.vim"
Searching for "/home/Dante/.vim/plugged/onehalf/vim/autoload/coc/api.vim"
Searching for "/home/Dante/.vim/plugged/gruvbox/autoload/coc/api.vim"
Searching for "/home/Dante/.vim/plugged/lightline.vim/autoload/coc/api.vim"
Searching for "/home/Dante/.vim/plugged/vim-tmux-navigator/autoload/coc/api.vim"
Searching for "/home/Dante/.vim/plugged/vimtex/autoload/coc/api.vim"
Searching for "/home/Dante/.vim/plugged/nerdtree/autoload/coc/api.vim"
Searching for "/home/Dante/.vim/plugged/fzf/autoload/coc/api.vim"
Searching for "/home/Dante/.vim/plugged/fzf.vim/autoload/coc/api.vim"
Searching for "/home/Dante/.vim/plugged/vim-wayland-clipboard/autoload/coc/api.vim"
Searching for "/home/Dante/.vim/plugged/coc.nvim/autoload/coc/api.vim"
chdir(/home/Dante/.vim/plugged/coc.nvim/autoload/coc)
fchdir() to previous dir
line 10: sourcing "/home/Dante/.vim/plugged/coc.nvim/autoload/coc/api.vim"
line 1: " ============================================================================
line 2: " Description: Client api used by vim8
line 3: " Author: Qiming Zhao <chemzqm@gmail.com>
line 4: " Licence: Anti 996 licence
line 5: " Last Modified: 2022-12-20
line 6: " ============================================================================
line 7: if has('nvim')
line 8:   finish
line 9: endif
line 10: 
line 11: scriptencoding utf-8
line 12: let s:funcs = {}
line 13: let s:prop_offset = get(g:, 'coc_text_prop_offset', 1000)
line 14: let s:namespace_id = 1
line 15: let s:namespace_cache = {}
line 16: let s:max_src_id = 1000
line 17: " bufnr => max textprop id
line 18: let s:buffer_id = {}
line 19: " srcId => list of types
line 20: let s:id_types = {}
line 21: let s:tab_id = 1
line 22: let s:keymap_arguments = ['nowait', 'silent', 'script', 'expr', 'unique']
line 23: 
line 24: " helper {{
line 25: " Create a window with bufnr for execute win_execute
line 26: function! s:create_popup(bufnr) abort
line 36: 
line 37: function! s:check_bufnr(bufnr) abort
line 42: 
line 43: " TextChanged not fired when using channel on vim.
line 44: function! s:on_textchange(bufnr) abort
line 48: 
line 49: " execute command for bufnr
line 50: function! s:buf_execute(bufnr, cmds) abort
line 65: 
line 66: function! s:check_winid(winid) abort
line 71: 
line 72: function! s:is_popup(winid) abort
line 79: 
line 80: function! s:tabid_nr(tid) abort
line 88: 
line 89: function! s:tabnr_id(nr) abort
line 98: 
line 99: function! s:generate_id(bufnr) abort
line 105: 
line 106: function! s:win_execute(winid, cmd, ...) abort
line 111: 
line 112: function! s:win_tabnr(winid) abort
line 121: 
line 122: function! s:buf_line_count(bufnr) abort
line 138: 
line 139: function! s:execute(cmd)
line 146: 
line 147: function s:inspect_type(v) abort
line 151: 
line 152: function! s:escape_space(text) abort
line 155: 
line 156: function! s:create_mode_prefix(mode, opts) abort
line 162: 
line 163: function! s:create_arguments(opts) abort
line 172: " }}"
line 173: 
line 174: " nvim client methods {{
line 175: function! s:funcs.set_current_dir(dir) abort
line 179: 
line 180: function! s:funcs.set_var(name, value) abort
line 184: 
line 185: function! s:funcs.del_var(name) abort
line 192: 
line 193: function! s:funcs.set_option(name, value) abort
line 197: 
line 198: function! s:funcs.get_option(name)
line 201: 
line 202: function! s:funcs.set_current_buf(bufnr) abort
line 207: 
line 208: function! s:funcs.set_current_win(winid) abort
line 213: 
line 214: function! s:funcs.set_current_tabpage(tid) abort
line 219: 
line 220: function! s:funcs.list_wins() abort
line 223: 
line 224: function! s:funcs.call_atomic(calls)
line 237: 
line 238: function! s:funcs.set_client_info(...) abort
line 242: 
line 243: function! s:funcs.subscribe(...) abort
line 247: 
line 248: function! s:funcs.unsubscribe(...) abort
line 252: 
line 253: function! s:funcs.call_function(method, args) abort
line 256: 
line 257: function! s:funcs.call_dict_function(dict, method, args) abort
line 263: 
line 264: function! s:funcs.command(command) abort
line 278: 
line 279: function! s:funcs.eval(expr) abort
line 282: 
line 283: function! s:funcs.get_api_info()
line 291: 
line 292: function! s:funcs.list_bufs()
line 295: 
line 296: function! s:funcs.feedkeys(keys, mode, escape_csi)
line 300: 
line 301: function! s:funcs.list_runtime_paths()
line 304: 
line 305: function! s:funcs.command_output(cmd)
line 308: 
line 309: function! s:funcs.exec(code, output) abort
line 317: 
line 318: " Queues raw user-input, <" is special. To input a literal "<", send <LT>.
line 319: function! s:funcs.input(keys) abort
line 324: 
line 325: function! s:funcs.create_buf(listed, scratch) abort
line 336: 
line 337: function! s:funcs.get_current_line()
line 340: 
line 341: function! s:funcs.set_current_line(line)
line 346: 
line 347: function! s:funcs.del_current_line()
line 352: 
line 353: function! s:funcs.get_var(var)
line 356: 
line 357: function! s:funcs.get_vvar(var)
line 360: 
line 361: function! s:funcs.get_current_buf()
line 364: 
line 365: function! s:funcs.get_current_win()
line 368: 
line 369: function! s:funcs.get_current_tabpage()
line 372: 
line 373: function! s:funcs.list_tabpages()
line 380: 
line 381: function! s:funcs.get_mode()
line 385: 
line 386: function! s:funcs.strwidth(str)
line 389: 
line 390: function! s:funcs.out_write(str)
line 394: 
line 395: function! s:funcs.err_write(str)
line 398: 
line 399: function! s:funcs.err_writeln(str)
line 405: 
line 406: function! s:funcs.create_namespace(name) abort
line 420: 
line 421: function! s:funcs.set_keymap(mode, lhs, rhs, opts) abort
line 430: 
line 431: function! s:funcs.del_keymap(mode, lhs) abort
line 436: " }}
line 437: 
line 438: " buffer methods {{
line 439: function! s:funcs.buf_set_option(bufnr, name, val)
line 449: 
line 450: function! s:funcs.buf_get_option(bufnr, name)
line 454: 
line 455: function! s:funcs.buf_get_changedtick(bufnr)
line 458: 
line 459: function! s:funcs.buf_is_valid(bufnr)
line 462: 
line 463: function! s:funcs.buf_is_loaded(bufnr)
line 466: 
line 467: function! s:funcs.buf_get_mark(bufnr, name)
line 473: 
line 474: function! s:funcs.buf_add_highlight(bufnr, srcId, hlGroup, line, colStart, colEnd, ...) abort
line 507: 
line 508: function! s:funcs.buf_clear_namespace(bufnr, srcId, startLine, endLine) abort
line 528: 
line 529: function! s:funcs.buf_line_count(bufnr) abort
line 533: 
line 534: function! s:funcs.buf_attach(...)
line 538: 
line 539: function! s:funcs.buf_detach()
line 543: 
line 544: function! s:funcs.buf_get_lines(bufnr, start, end, strict) abort
line 554: 
line 555: function! s:funcs.buf_set_lines(bufnr, start, end, strict, ...) abort
line 588: 
line 589: function! s:funcs.buf_set_name(bufnr, name) abort
line 597: 
line 598: function! s:funcs.buf_get_name(bufnr)
line 602: 
line 603: function! s:funcs.buf_get_var(bufnr, name)
line 610: 
line 611: function! s:funcs.buf_set_var(bufnr, name, val)
line 616: 
line 617: function! s:funcs.buf_del_var(bufnr, name)
line 623: 
line 624: function! s:funcs.buf_set_keymap(bufnr, mode, lhs, rhs, opts) abort
line 637: 
line 638: function! s:funcs.buf_del_keymap(bufnr, mode, lhs) abort
line 648: " }}
line 649: 
line 650: " window methods {{
line 651: function! s:funcs.win_get_buf(winid)
line 655: 
line 656: function! s:funcs.win_set_buf(winid, bufnr) abort
line 662: 
line 663: function! s:funcs.win_get_position(winid) abort
line 670: 
line 671: function! s:funcs.win_set_height(winid, height) abort
line 680: 
line 681: function! s:funcs.win_get_height(winid) abort
line 688: 
line 689: function! s:funcs.win_set_width(winid, width) abort
line 698: 
line 699: function! s:funcs.win_get_width(winid) abort
line 706: 
line 707: function! s:funcs.win_set_cursor(winid, pos) abort
line 713: 
line 714: function! s:funcs.win_get_cursor(winid) abort
line 720: 
line 721: function! s:funcs.win_set_option(winid, name, value) abort
line 732: 
line 733: function! s:funcs.win_get_option(winid, name, ...) abort
line 741: 
line 742: function! s:funcs.win_get_var(winid, name, ...) abort
line 746: 
line 747: function! s:funcs.win_set_var(winid, name, value) abort
line 752: 
line 753: function! s:funcs.win_del_var(winid, name) abort
line 758: 
line 759: function! s:funcs.win_is_valid(winid) abort
line 763: 
line 764: " Not work for popup
line 765: function! s:funcs.win_get_number(winid) abort
line 775: 
line 776: function! s:funcs.win_get_tabpage(winid) abort
line 780: 
line 781: function! s:funcs.win_close(winid, ...) abort
line 791: " }}
line 792: 
line 793: " tabpage methods {{
line 794: function! s:funcs.tabpage_get_number(tid)
line 797: 
line 798: function! s:funcs.tabpage_list_wins(tid)
line 802: 
line 803: function! s:funcs.tabpage_get_var(tid, name)
line 807: 
line 808: function! s:funcs.tabpage_set_var(tid, name, value)
line 813: 
line 814: function! s:funcs.tabpage_del_var(tid, name)
line 819: 
line 820: function! s:funcs.tabpage_is_valid(tid)
line 828: 
line 829: function! s:funcs.tabpage_get_win(tid)
line 833: " }}
line 834: 
line 835: function! coc#api#get_types(srcId) abort
line 838: 
line 839: function! coc#api#get_id_types() abort
line 842: 
line 843: function! coc#api#create_type(srcId, hlGroup, opts) abort
line 854: 
line 855: function! coc#api#func_names() abort
line 858: 
line 859: function! coc#api#call(method, args) abort
line 869: 
line 870: function! coc#api#exec(method, args) abort
line 873: 
line 874: function! coc#api#notify(method, args) abort
line 881: 
line 882: " create id for all tabpages
line 883: function! coc#api#tabpage_ids() abort
line 891: 
line 892: function! coc#api#get_tabid(nr) abort
line 895: " vim: set sw=2 ts=2 sts=2 et tw=78 foldmarker={{,}} foldmethod=marker foldlevel=0:
finished sourcing /home/Dante/.vim/plugged/coc.nvim/autoload/coc/api.vim
continuing in <SNR>46_Enable
calling coc#api#tabpage_ids()

line 1:   for nr in range(1, tabpagenr('$'))
line 2:     if gettabvar(nr, '__tid', -1) == -1
line 3:       call settabvar(nr, '__tid', s:tab_id)
line 4:       let s:tab_id = s:tab_id + 1
line 5:     endif
line 6:   endfor
line 1:   for nr in range(1, tabpagenr('$'))
line 2:     if gettabvar(nr, '__tid', -1) == -1
line 3:       call settabvar(nr, '__tid', s:tab_id)
line 4:       let s:tab_id = s:tab_id + 1
line 5:     endif
line 6:   endfor
coc#api#tabpage_ids returning #0

continuing in <SNR>46_Enable

line 11:   endif
line 12: 
line 13:   augroup coc_nvim
line 14:     autocmd!
line 15: 
line 16:     if !v:vim_did_enter
line 17:       autocmd VimEnter            * call s:VimEnter()
line 18:     else
line 19:       call s:Highlight()
line 20:     endif
line 21:     if s:is_vim
line 22:       if exists('##DirChanged')
line 23:         autocmd DirChanged        * call s:Autocmd('DirChanged', getcwd())
line 24:       endif
line 25:       if exists('##TerminalOpen')
line 26:         autocmd TerminalOpen      * call s:Autocmd('TermOpen', +expand('<abuf>'))
line 27:       endif
line 28:       autocmd CursorMoved         list:///* call coc#list#select(bufnr('%'), line('.'))
line 29:       autocmd TabNew              * call coc#api#tabpage_ids()
line 30:     else
line 31:       autocmd DirChanged        * call s:Autocmd('DirChanged', get(v:event, 'cwd', ''))
line 32:       autocmd TermOpen          * call s:Autocmd('TermOpen', +expand('<abuf>'))
line 33:       autocmd WinEnter          * call coc#float#nvim_win_enter(win_getid())
line 34:     endif
line 35:     if exists('##CompleteChanged')
line 36:       autocmd CompleteChanged   * call timer_start(1, { -> coc#pum#close()})
line 37:     endif
line 38:     autocmd CursorHold          * call coc#float#check_related()
line 39:     if exists('##WinClosed')
line 40:       autocmd WinClosed         * call s:HandleWinClosed(+expand('<amatch>'))
line 41:     elseif exists('##TabEnter')
line 42:       autocmd TabEnter          * call coc#notify#reflow()
line 43:     endif
line 44:     if exists('##WinScrolled')
line 45:       autocmd WinScrolled       * call s:HandleWinScrolled(+expand('<amatch>'))
line 46:     endif
line 47:     autocmd TabNew              * call s:Autocmd('TabNew', coc#util#tabnr_id(tabpagenr()))
line 48:     autocmd TabClosed           * call s:Autocmd('TabClosed', coc#util#tabpages())
line 49:     autocmd WinLeave            * call s:Autocmd('WinLeave', win_getid())
line 50:     autocmd WinEnter            * call s:Autocmd('WinEnter', win_getid())
line 51:     autocmd BufWinLeave         * call s:Autocmd('BufWinLeave', +expand('<abuf>'), bufwinid(+expand('<abuf>')))
line 52:     autocmd BufWinEnter         * call s:Autocmd('BufWinEnter', +expand('<abuf>'), win_getid())
line 53:     autocmd FileType            * call s:Autocmd('FileType', expand('<amatch>'), +expand('<abuf>'))
line 54:     autocmd InsertCharPre       * call s:HandleCharInsert(v:char, bufnr('%'))
line 55:     if exists('##TextChangedP')
line 56:       autocmd TextChangedP      * call s:Autocmd('TextChangedP', +expand('<abuf>'), coc#util#change_info())
line 57:     endif
line 58:     autocmd TextChangedI        * call s:HandleTextChangedI(+expand('<abuf>'))
line 59:     autocmd InsertLeave         * call s:HandleInsertLeave(+expand('<abuf>'))
line 60:     autocmd InsertEnter         * call s:Autocmd('InsertEnter', +expand('<abuf>'))
line 61:     autocmd BufHidden           * call s:Autocmd('BufHidden', +expand('<abuf>'))
line 62:     autocmd BufEnter            * call s:Autocmd('BufEnter', +expand('<abuf>'))
line 63:     autocmd TextChanged         * call s:Autocmd('TextChanged', +expand('<abuf>'), getbufvar(+expand('<abuf>'), 'changedtick'))
line 64:     autocmd BufWritePost        * call s:Autocmd('BufWritePost', +expand('<abuf>'), getbufvar(+expand('<abuf>'), 'changedtick'))
line 65:     autocmd CursorMoved         * call s:Autocmd('CursorMoved', +expand('<abuf>'), [line('.'), col('.')])
line 66:     autocmd CursorMovedI        * call s:Autocmd('CursorMovedI', +expand('<abuf>'), [line('.'), col('.')])
line 67:     autocmd CursorHold          * call s:Autocmd('CursorHold', +expand('<abuf>'), [line('.'), col('.')])
line 68:     autocmd CursorHoldI         * call s:Autocmd('CursorHoldI', +expand('<abuf>'), [line('.'), col('.')])
line 69:     autocmd BufNewFile,BufReadPost * call s:Autocmd('BufCreate', +expand('<abuf>'))
line 70:     autocmd BufUnload           * call s:Autocmd('BufUnload', +expand('<abuf>'))
line 71:     autocmd BufWritePre         * call s:SyncAutocmd('BufWritePre', +expand('<abuf>'), bufname(+expand('<abuf>')), getbufvar(+expand('<abuf>'), 'changedtick'))
line 72:     autocmd FocusGained         * if mode() !~# '^c' | call s:Autocmd('FocusGained') | endif
line 73:     autocmd FocusLost           * call s:Autocmd('FocusLost')
line 74:     autocmd VimResized          * call s:Autocmd('VimResized', &columns, &lines)
line 75:     autocmd VimLeavePre         * call s:VimLeavePre()
line 76:     autocmd BufReadCmd,FileReadCmd,SourceCmd list://* call coc#list#setup(expand('<amatch>'))
line 77:     autocmd BufWriteCmd __coc_refactor__* :call coc#rpc#notify('saveRefactor', [+expand('<abuf>')])
line 78:     autocmd ColorScheme * call s:Highlight() | call s:Autocmd('ColorScheme')
line 79: 
line 80:     if has('nvim-0.10')
line 81:       autocmd User CocDiagnosticChange call v:lua.require('coc.diagnostic').on_diagnostic_change()
line 82:     endif
line 83:   augroup end
line 84:   if a:initialize == 0
line 85:      call coc#rpc#request('attach', [])
line 86:      echohl MoreMsg
line 87:      echom '[coc.nvim] Event enabled'
line 88:      echohl None
line 89:   endif
<SNR>46_Enable returning #0

continuing in /home/Dante/.vim/plugged/coc.nvim/plugin/coc.vim

line 706: augroup coc_dynamic_autocmd
line 707: augroup END
line 708: augroup coc_dynamic_content
line 709: augroup END
line 710: augroup coc_dynamic_option
line 711: augroup END
line 712: 
line 713: " Default key-mappings for completion
line 714: if empty(mapcheck('<C-n>', 'i'))
line 715:   inoremap <silent><expr> <C-n> coc#pum#visible() ? coc#pum#next(1) : "\<C-n>"
line 716: endif
line 717: if empty(mapcheck('<C-p>', 'i'))
line 718:   inoremap <silent><expr> <C-p> coc#pum#visible() ? coc#pum#prev(1) : "\<C-p>"
line 719: endif
line 720: if empty(mapcheck('<down>', 'i'))
line 721:   inoremap <silent><expr> <down> coc#pum#visible() ? coc#pum#next(0) : "\<down>"
line 722: endif
line 723: if empty(mapcheck('<up>', 'i'))
line 724:   inoremap <silent><expr> <up> coc#pum#visible() ? coc#pum#prev(0) : "\<up>"
line 725: endif
line 726: if empty(mapcheck('<C-e>', 'i'))
line 727:   inoremap <silent><expr> <C-e> coc#pum#visible() ? coc#pum#cancel() : "\<C-e>"
line 728: endif
line 729: if empty(mapcheck('<C-y>', 'i'))
line 730:   inoremap <silent><expr> <C-y> coc#pum#visible() ? coc#pum#confirm() : "\<C-y>"
line 731: endif
line 732: if empty(mapcheck('<PageDown>', 'i'))
line 733:   inoremap <silent><expr> <PageDown> coc#pum#visible() ? coc#pum#scroll(1) : "\<PageDown>"
line 734: endif
line 735: if empty(mapcheck('<PageUp>', 'i'))
line 736:   inoremap <silent><expr> <PageUp> coc#pum#visible() ? coc#pum#scroll(0) : "\<PageUp>"
line 737: endif
line 738: 
line 739: vnoremap <silent> <Plug>(coc-range-select)          :<C-u>call       CocActionAsync('rangeSelect',     visualmode(), v:true)<CR>
line 740: vnoremap <silent> <Plug>(coc-range-select-backward) :<C-u>call       CocActionAsync('rangeSelect',     visualmode(), v:false)<CR>
line 741: nnoremap <Plug>(coc-range-select)                   :<C-u>call       CocActionAsync('rangeSelect',     '', v:true)<CR>
line 742: nnoremap <Plug>(coc-codelens-action)                :<C-u>call       CocActionAsync('codeLensAction')<CR>
line 743: vnoremap <silent> <Plug>(coc-format-selected)       :<C-u>call       CocActionAsync('formatSelected', visualmode())<CR>
line 744: vnoremap <silent> <Plug>(coc-codeaction-selected)   :<C-u>call       CocActionAsync('codeAction', visualmode())<CR>
line 745: vnoremap <Plug>(coc-codeaction-refactor-selected)   :<C-u>call       CocActionAsync('codeAction', visualmode(), ['refactor'], v:true)<CR>
line 746: nnoremap <Plug>(coc-codeaction-selected)            :<C-u>set        operatorfunc=<SID>CodeActionFromSelected<CR>g@
line 747: nnoremap <Plug>(coc-codeaction-refactor-selected)   :<C-u>set        operatorfunc=<SID>CodeActionRefactorFromSelected<CR>g@
line 748: nnoremap <Plug>(coc-codeaction)                     :<C-u>call       CocActionAsync('codeAction', '')<CR>
line 749: nnoremap <Plug>(coc-codeaction-line)                :<C-u>call       CocActionAsync('codeAction', 'currline')<CR>
line 750: nnoremap <Plug>(coc-codeaction-cursor)              :<C-u>call       CocActionAsync('codeAction', 'cursor')<CR>
line 751: nnoremap <Plug>(coc-codeaction-refactor)            :<C-u>call       CocActionAsync('codeAction', 'cursor', ['refactor'], v:true)<CR>
line 752: nnoremap <Plug>(coc-codeaction-source)              :<C-u>call       CocActionAsync('codeAction', '', ['source'], v:true)<CR>
line 753: nnoremap <silent> <Plug>(coc-rename)                :<C-u>call       CocActionAsync('rename')<CR>
line 754: nnoremap <silent> <Plug>(coc-format-selected)       :<C-u>set        operatorfunc=<SID>FormatFromSelected<CR>g@
line 755: nnoremap <silent> <Plug>(coc-format)                :<C-u>call       CocActionAsync('format')<CR>
line 756: nnoremap <silent> <Plug>(coc-diagnostic-info)       :<C-u>call       CocActionAsync('diagnosticInfo')<CR>
line 757: nnoremap <silent> <Plug>(coc-diagnostic-next)       :<C-u>call       CocActionAsync('diagnosticNext')<CR>
line 758: nnoremap <silent> <Plug>(coc-diagnostic-prev)       :<C-u>call       CocActionAsync('diagnosticPrevious')<CR>
line 759: nnoremap <silent> <Plug>(coc-diagnostic-next-error) :<C-u>call       CocActionAsync('diagnosticNext',     'error')<CR>
line 760: nnoremap <silent> <Plug>(coc-diagnostic-prev-error) :<C-u>call       CocActionAsync('diagnosticPrevious', 'error')<CR>
line 761: nnoremap <silent> <Plug>(coc-definition)            :<C-u>call       CocActionAsync('jumpDefinition')<CR>
line 762: nnoremap <silent> <Plug>(coc-declaration)           :<C-u>call       CocActionAsync('jumpDeclaration')<CR>
line 763: nnoremap <silent> <Plug>(coc-implementation)        :<C-u>call       CocActionAsync('jumpImplementation')<CR>
line 764: nnoremap <silent> <Plug>(coc-type-definition)       :<C-u>call       CocActionAsync('jumpTypeDefinition')<CR>
line 765: nnoremap <silent> <Plug>(coc-references)            :<C-u>call       CocActionAsync('jumpReferences')<CR>
line 766: nnoremap <silent> <Plug>(coc-references-used)       :<C-u>call       CocActionAsync('jumpUsed')<CR>
line 767: nnoremap <silent> <Plug>(coc-openlink)              :<C-u>call       CocActionAsync('openLink')<CR>
line 768: nnoremap <silent> <Plug>(coc-fix-current)           :<C-u>call       CocActionAsync('doQuickfix')<CR>
line 769: nnoremap <silent> <Plug>(coc-float-hide)            :<C-u>call       coc#float#close_all()<CR>
line 770: nnoremap <silent> <Plug>(coc-float-jump)            :<c-u>call       coc#float#jump()<cr>
line 771: nnoremap <silent> <Plug>(coc-command-repeat)        :<C-u>call       CocAction('repeatCommand')<CR>
line 772: nnoremap <silent> <Plug>(coc-refactor)              :<C-u>call       CocActionAsync('refactor')<CR>
line 773: 
line 774: nnoremap <silent> <Plug>(coc-cursors-operator) :<C-u>set operatorfunc=<SID>CursorRangeFromSelected<CR>g@
line 775: vnoremap <silent> <Plug>(coc-cursors-range)    :<C-u>call CocAction('cursorsSelect', bufnr('%'), 'range', visualmode())<CR>
line 776: nnoremap <silent> <Plug>(coc-cursors-word)     :<C-u>call CocAction('cursorsSelect', bufnr('%'), 'word', 'n')<CR>
line 777: nnoremap <silent> <Plug>(coc-cursors-position) :<C-u>call CocAction('cursorsSelect', bufnr('%'), 'position', 'n')<CR>
line 778: 
line 779: vnoremap <silent> <Plug>(coc-funcobj-i)        :<C-U>call CocAction('selectSymbolRange', v:true, visualmode(), ['Method', 'Function'])<CR>
line 780: vnoremap <silent> <Plug>(coc-funcobj-a)        :<C-U>call CocAction('selectSymbolRange', v:false, visualmode(), ['Method', 'Function'])<CR>
line 781: onoremap <silent> <Plug>(coc-funcobj-i)        :<C-U>call CocAction('selectSymbolRange', v:true, '', ['Method', 'Function'])<CR>
line 782: onoremap <silent> <Plug>(coc-funcobj-a)        :<C-U>call CocAction('selectSymbolRange', v:false, '', ['Method', 'Function'])<CR>
line 783: 
line 784: vnoremap <silent> <Plug>(coc-classobj-i)       :<C-U>call CocAction('selectSymbolRange', v:true, visualmode(), ['Interface', 'Struct', 'Class'])<CR>
line 785: vnoremap <silent> <Plug>(coc-classobj-a)       :<C-U>call CocAction('selectSymbolRange', v:false, visualmode(), ['Interface', 'Struct', 'Class'])<CR>
line 786: onoremap <silent> <Plug>(coc-classobj-i)       :<C-U>call CocAction('selectSymbolRange', v:true, '', ['Interface', 'Struct', 'Class'])<CR>
line 787: onoremap <silent> <Plug>(coc-classobj-a)       :<C-U>call CocAction('selectSymbolRange', v:false, '', ['Interface', 'Struct', 'Class'])<CR>
finished sourcing /home/Dante/.vim/plugged/coc.nvim/plugin/coc.vim
Searching for "/home/Dante/.vim/plugged/vim-obsession/plugin/**/*.vim"
chdir(/home/Dante/.vim/plugged/vim-obsession/plugin)
fchdir() to previous dir
sourcing "/home/Dante/.vim/plugged/vim-obsession/plugin/obsession.vim"
line 1: " obsession.vim - Continuously updated session files
line 2: " Maintainer:   Tim Pope <http://tpo.pe/>
line 3: " Version:      1.0
line 4: " GetLatestVimScripts: 4472 1 :AutoInstall: obsession.vim
line 5: 
line 6: if exists("g:loaded_obsession") || v:version < 704 || &cp
line 7:   finish
line 8: endif
line 9: let g:loaded_obsession = 1
line 10: 
line 11: command! -bar -bang -complete=file -nargs=? Obsession execute s:dispatch(<bang>0, <q-args>)
line 13: 
line 14: function! s:dispatch(bang, file) abort
line 56: 
line 57: function! s:doautocmd_user(arg) abort
line 64: 
line 65: function! s:persist() abort
line 102: 
line 103: function! ObsessionStatus(...) abort
line 121: 
line 122: augroup obsession
line 123:   autocmd!
line 124:   autocmd VimLeavePre * exe s:persist()
line 125:   autocmd BufEnter * if !get(g:, 'obsession_no_bufenter') |   exe s:persist() | endif
line 129:   autocmd User Flags call Hoist('global', 'ObsessionStatus')
line 130: augroup END
line 131: 
line 132: " vim:set et sw=2:
finished sourcing /home/Dante/.vim/plugged/vim-obsession/plugin/obsession.vim
Searching for "/usr/share/vim/vimfiles/plugin/**/*.vim"
chdir(/usr/share/vim/vimfiles/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vimfiles/plugin/fzf.vim"
line 1: " Copyright (c) 2013-2024 Junegunn Choi
line 2: "
line 3: " MIT License
line 4: "
line 5: " Permission is hereby granted, free of charge, to any person obtaining
line 6: " a copy of this software and associated documentation files (the
line 7: " "Software"), to deal in the Software without restriction, including
line 8: " without limitation the rights to use, copy, modify, merge, publish,
line 9: " distribute, sublicense, and/or sell copies of the Software, and to
line 10: " permit persons to whom the Software is furnished to do so, subject to
line 11: " the following conditions:
line 12: "
line 13: " The above copyright notice and this permission notice shall be
line 14: " included in all copies or substantial portions of the Software.
line 15: "
line 16: " THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
line 17: " EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
line 18: " MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
line 19: " NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
line 20: " LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
line 21: " OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
line 22: " WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
line 23: 
line 24: if exists('g:loaded_fzf')
line 25:   finish
finished sourcing /usr/share/vim/vimfiles/plugin/fzf.vim
Searching for "/usr/share/vim/vim91/plugin/**/*.vim"
chdir(/usr/share/vim/vim91/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim91/plugin/getscriptPlugin.vim"
line 1: " ---------------------------------------------------------------------
line 2: " getscriptPlugin.vim
line 3: "  Maintainer:^IThis runtime file is looking for a new maintainer.
line 4: "  Original Author:^ICharles E. Campbell
line 5: "  Date:^INov 29, 2013
line 6: "  Installing:^I:help glvs-install
line 7: "  Usage:^I:help glvs
line 8: "
line 9: " GetLatestVimScripts: 642 1 :AutoInstall: getscript.vim
line 10: "
line 11: " (Rom 15:11 WEB) Again, "Praise the Lord, all you Gentiles!  Let
line 12: " all the peoples praise Him."
line 13: " ---------------------------------------------------------------------
line 14: " Initialization:^I{{{1
line 15: " if you're sourcing this file, surely you can't be
line 16: " expecting vim to be in its vi-compatible mode
line 17: if exists("g:loaded_getscriptPlugin")
line 18:  finish
line 19: endif
line 20: if &cp
line 21:  if &verbose
line 22:   echo "GetLatestVimScripts is not vi-compatible; not loaded (you need to set nocp)"
line 23:  endif
line 24:  finish
line 25: endif
line 26: let g:loaded_getscriptPlugin = "v37"
line 27: let s:keepcpo                = &cpo
line 28: set cpo&vim
line 29: 
line 30: " ---------------------------------------------------------------------
line 31: "  Public Interface: {{{1
line 32: com!        -nargs=0 GetLatestVimScripts call getscript#GetLatestVimScripts()
line 33: com!        -nargs=0 GetScripts          call getscript#GetLatestVimScripts()
line 34: sil! com    -nargs=0 GLVS                call getscript#GetLatestVimScripts()
line 35: 
line 36: " ---------------------------------------------------------------------
line 37: " Restore Options: {{{1
line 38: let &cpo= s:keepcpo
line 39: unlet s:keepcpo
line 40: 
line 41: " ---------------------------------------------------------------------
line 42: " vim: ts=8 sts=2 fdm=marker nowrap
finished sourcing /usr/share/vim/vim91/plugin/getscriptPlugin.vim
chdir(/usr/share/vim/vim91/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim91/plugin/gzip.vim"
line 1: " Vim plugin for editing compressed files.
line 2: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 3: " Last Change:^I2023 Aug 10
line 4: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 5: 
line 6: " Exit quickly when:
line 7: " - this plugin was already loaded
line 8: " - when 'compatible' is set
line 9: " - some autocommands are already taking care of compressed files
line 10: if exists("loaded_gzip") || &cp || exists("#BufReadPre#*.gz")
line 11:   finish
line 12: endif
line 13: let loaded_gzip = 1
line 14: 
line 15: augroup gzip
line 16:   " Remove all gzip autocommands
line 17:   au!
line 18: 
line 19:   " Enable editing of gzipped files.
line 20:   " The functions are defined in autoload/gzip.vim.
line 21:   "
line 22:   " Set binary mode before reading the file.
line 23:   " Use "gzip -d", gunzip isn't always available.
line 24:   autocmd BufReadPre,FileReadPre^I*.gz,*.bz2,*.Z,*.lzma,*.xz,*.lz,*.zst,*.br,*.lzo setlocal bin
line 25:   autocmd BufReadPost,FileReadPost^I*.gz  call gzip#read("gzip -dn")
line 26:   autocmd BufReadPost,FileReadPost^I*.bz2 call gzip#read("bzip2 -d")
line 27:   autocmd BufReadPost,FileReadPost^I*.Z   call gzip#read("uncompress")
line 28:   autocmd BufReadPost,FileReadPost^I*.lzma call gzip#read("lzma -d")
line 29:   autocmd BufReadPost,FileReadPost^I*.xz  call gzip#read("xz -d")
line 30:   autocmd BufReadPost,FileReadPost^I*.lz  call gzip#read("lzip -d")
line 31:   autocmd BufReadPost,FileReadPost^I*.zst call gzip#read("zstd -d --rm")
line 32:   autocmd BufReadPost,FileReadPost^I*.br call gzip#read("brotli -d --rm")
line 33:   autocmd BufReadPost,FileReadPost^I*.lzo call gzip#read("lzop -d -U")
line 34:   autocmd BufWritePost,FileWritePost^I*.gz  call gzip#write("gzip")
line 35:   autocmd BufWritePost,FileWritePost^I*.bz2 call gzip#write("bzip2")
line 36:   autocmd BufWritePost,FileWritePost^I*.Z   call gzip#write("compress -f")
line 37:   autocmd BufWritePost,FileWritePost^I*.lzma call gzip#write("lzma -z")
line 38:   autocmd BufWritePost,FileWritePost^I*.xz  call gzip#write("xz -z")
line 39:   autocmd BufWritePost,FileWritePost^I*.lz  call gzip#write("lzip")
line 40:   autocmd BufWritePost,FileWritePost^I*.zst  call gzip#write("zstd --rm")
line 41:   autocmd BufWritePost,FileWritePost^I*.br  call gzip#write("brotli --rm")
line 42:   autocmd BufWritePost,FileWritePost^I*.lzo  call gzip#write("lzop -U")
line 43:   autocmd FileAppendPre^I^I^I*.gz  call gzip#appre("gzip -dn")
line 44:   autocmd FileAppendPre^I^I^I*.bz2 call gzip#appre("bzip2 -d")
line 45:   autocmd FileAppendPre^I^I^I*.Z   call gzip#appre("uncompress")
line 46:   autocmd FileAppendPre^I^I^I*.lzma call gzip#appre("lzma -d")
line 47:   autocmd FileAppendPre^I^I^I*.xz   call gzip#appre("xz -d")
line 48:   autocmd FileAppendPre^I^I^I*.lz   call gzip#appre("lzip -d")
line 49:   autocmd FileAppendPre^I^I^I*.zst call gzip#appre("zstd -d --rm")
line 50:   autocmd FileAppendPre^I^I^I*.br call gzip#appre("brotli -d --rm")
line 51:   autocmd FileAppendPre^I^I^I*.lzo call gzip#appre("lzop -d -U")
line 52:   autocmd FileAppendPost^I^I*.gz  call gzip#write("gzip")
line 53:   autocmd FileAppendPost^I^I*.bz2 call gzip#write("bzip2")
line 54:   autocmd FileAppendPost^I^I*.Z   call gzip#write("compress -f")
line 55:   autocmd FileAppendPost^I^I*.lzma call gzip#write("lzma -z")
line 56:   autocmd FileAppendPost^I^I*.xz call gzip#write("xz -z")
line 57:   autocmd FileAppendPost^I^I*.lz call gzip#write("lzip")
line 58:   autocmd FileAppendPost^I^I*.zst call gzip#write("zstd --rm")
line 59:   autocmd FileAppendPost^I^I*.br call gzip#write("brotli --rm")
line 60:   autocmd FileAppendPost^I^I*.lzo call gzip#write("lzop -U")
line 61: augroup END
finished sourcing /usr/share/vim/vim91/plugin/gzip.vim
chdir(/usr/share/vim/vim91/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim91/plugin/logiPat.vim"
line 1: " LogiPat: Boolean logical pattern matcher
line 2: "   Maintainer:^IThis runtime file is looking for a new maintainer.
line 3: "   Original Author:  Charles E. Campbell
line 4: "   Date:    Apr 04, 2016
line 5: "   Version: 4
line 6: "   Purpose: to do Boolean-logic based regular expression pattern matching
line 7: " Copyright:    Copyright (C) 1999-2011 Charles E. Campbell {{{1
line 8: "               Permission is hereby granted to use and distribute this code,
line 9: "               with or without modifications, provided that this copyright
line 10: "               notice is copied with it. Like most anything else that's free,
line 11: "               LogiPat.vim is provided *as is* and comes with no warranty
line 12: "               of any kind, either expressed or implied. By using this
line 13: "               plugin, you agree that in no event will the copyright
line 14: "               holder be liable for any damages resulting from the use
line 15: "               of this software.
line 16: "
line 17: "   Usage: {{{1
line 18: "       :LogiPat ...
line 19: "
line 20: "         Boolean logic supported:
line 21: "            () grouping operators
line 22: "            !  not the following pattern
line 23: "            |  logical or
line 24: "            &  logical and
line 25: "            "..pattern.."
line 26: "^IExample: {{{1
line 27: "^I^I:LogiPat !("january"|"february")
line 28: "^I^I  would match all strings not containing the strings january
line 29: "^I^I  or february
line 30: "^IGetLatestVimScripts: 1290 1 :AutoInstall: LogiPat.vim
line 31: "
line 32: "  Behold, you will conceive in your womb, and bring forth a son, {{{1
line 33: "  and will call his name Jesus. He will be great, and will be
line 34: "  called the Son of the Most High. The Lord God will give him the
line 35: "  throne of his father, David, and he will reign over the house of
line 36: "  Jacob forever. There will be no end to his kingdom. (Luke 1:31-33 WEB)
line 37: 
line 38: " ---------------------------------------------------------------------
line 39: " Load Once: {{{1
line 40: if &cp || exists("loaded_logiPat")
line 41:  finish
line 42: endif
line 43: let g:loaded_logiPat = "v4"
line 44: let s:keepcpo        = &cpo
line 45: set cpo&vim
line 46: "DechoRemOn
line 47: 
line 48: " ---------------------------------------------------------------------
line 49: " Public Interface: {{{1
line 50: com!     -nargs=* LogiPat^I^Icall   LogiPat(<q-args>,1)
line 51: sil! com -nargs=* LP^I^I^Icall   LogiPat(<q-args>,1)
line 52: sil! com -nargs=* LPR^I^I^Icall   LogiPat(<q-args>,1,"r")
line 53: com!     -nargs=+ LPE^I^I^Iechomsg LogiPat(<q-args>)
line 54: com!     -nargs=+ LogiPatFlags^Ilet  s:LogiPatFlags="<args>"
line 55: sil! com -nargs=+ LPF^I^I^Ilet  s:LogiPatFlags="<args>"
line 56: 
line 57: " =====================================================================
line 58: " Functions: {{{1
line 59: 
line 60: " ---------------------------------------------------------------------
line 61: " LogiPat: this function interprets the boolean-logic pattern {{{2
line 62: fun! LogiPat(pat,...)
line 147: 
line 148: " ---------------------------------------------------------------------
line 149: " s:String: Vim6.4 doesn't have string() {{{2
line 150: func! s:String(str)
line 153: 
line 154: " ---------------------------------------------------------------------
line 155: " LP_PatPush: {{{2
line 156: fun! s:LP_PatPush(pat)
line 163: 
line 164: " ---------------------------------------------------------------------
line 165: " LP_PatPop: pop a number/variable from LogiPat's pattern stack {{{2
line 166: fun! s:LP_PatPop(lookup)
line 179: 
line 180: " ---------------------------------------------------------------------
line 181: " LP_OpPush: {{{2
line 182: fun! s:LP_OpPush(op)
line 233: 
line 234: " ---------------------------------------------------------------------
line 235: " LP_Execute: execute operators from opstack using pattern stack {{{2
line 236: fun! s:LP_Execute(preclvl)
line 266: 
line 267: " ---------------------------------------------------------------------
line 268: " LP_Not: writes a logical-not for a pattern {{{2
line 269: fun! s:LP_Not(pat)
line 280: 
line 281: " ---------------------------------------------------------------------
line 282: " LP_Or: writes a logical-or branch using two patterns {{{2
line 283: fun! s:LP_Or(pat1,pat2)
line 289: 
line 290: " ---------------------------------------------------------------------
line 291: " LP_And: writes a logical-and concat using two patterns {{{2
line 292: fun! s:LP_And(pat1,pat2)
line 298: 
line 299: " ---------------------------------------------------------------------
line 300: " StackLook: {{{2
line 301: fun! s:StackLook(description)
line 335: 
line 336: " ---------------------------------------------------------------------
line 337: "  Cleanup And Modeline: {{{1
line 338: let &cpo= s:keepcpo
line 339: unlet s:keepcpo
line 340: " vim: ts=4 fdm=marker
finished sourcing /usr/share/vim/vim91/plugin/logiPat.vim
chdir(/usr/share/vim/vim91/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim91/plugin/manpager.vim"
line 1: " Vim plugin for using Vim as manpager.
line 2: " Maintainer: Enno Nagel <ennonagel+vim@gmail.com>
line 3: " Last Change: 2024 Jul 03
line 4: 
line 5: if exists('g:loaded_manpager_plugin')
line 6:   finish
line 7: endif
line 8: let g:loaded_manpager_plugin = 1
line 9: 
line 10: " Set up the current buffer (likely read from stdin) as a manpage
line 11: command MANPAGER call s:ManPager()
line 12: 
line 13: function s:ManPager()
finished sourcing /usr/share/vim/vim91/plugin/manpager.vim
chdir(/usr/share/vim/vim91/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim91/plugin/matchparen.vim"
line 1: " Vim plugin for showing matching parens
line 2: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 3: " Last Change:^I2024 May 18
line 4: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 5: 
line 6: " Exit quickly when:
line 7: " - this plugin was already loaded (or disabled)
line 8: " - when 'compatible' is set
line 9: if exists("g:loaded_matchparen") || &cp
line 10:   finish
line 11: endif
line 12: let g:loaded_matchparen = 1
line 13: 
line 14: if !exists("g:matchparen_timeout")
line 15:   let g:matchparen_timeout = 300
line 16: endif
line 17: if !exists("g:matchparen_insert_timeout")
line 18:   let g:matchparen_insert_timeout = 60
line 19: endif
line 20: if !exists("g:matchparen_disable_cursor_hl")
line 21:   let g:matchparen_disable_cursor_hl = 0
line 22: endif
line 23: 
line 24: let s:has_matchaddpos = exists('*matchaddpos')
line 25: 
line 26: augroup matchparen
line 27:   " Replace all matchparen autocommands
line 28:   autocmd! CursorMoved,CursorMovedI,WinEnter,WinScrolled * call s:Highlight_Matching_Pair()
line 29:   autocmd! BufWinEnter * autocmd SafeState * ++once call s:Highlight_Matching_Pair()
line 30:   autocmd! WinLeave,BufLeave * call s:Remove_Matches()
line 31:   if exists('##TextChanged')
line 32:     autocmd! TextChanged,TextChangedI * call s:Highlight_Matching_Pair()
line 33:     autocmd! TextChangedP * call s:Remove_Matches()
line 34:   endif
line 35: augroup END
line 36: 
line 37: " Skip the rest if it was already done.
line 38: if exists("*s:Highlight_Matching_Pair")
line 39:   finish
line 40: endif
line 41: 
line 42: let s:cpo_save = &cpo
line 43: set cpo-=C
line 44: 
line 45: " The function that is invoked (very often) to define a ":match" highlighting
line 46: " for any matching paren.
line 47: func s:Highlight_Matching_Pair()
line 212: 
line 213: func s:Remove_Matches()
line 221: 
line 222: " Define commands that will disable and enable the plugin.
line 223: command DoMatchParen call s:DoMatchParen()
line 224: command NoMatchParen call s:NoMatchParen()
line 225: 
line 226: func s:NoMatchParen()
line 233: 
line 234: func s:DoMatchParen()
line 240: 
line 241: let &cpo = s:cpo_save
line 242: unlet s:cpo_save
finished sourcing /usr/share/vim/vim91/plugin/matchparen.vim
chdir(/usr/share/vim/vim91/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim91/plugin/netrwPlugin.vim"
line 1: " Load the netrw package.
line 2: 
line 3: if &cp || exists("g:loaded_netrw") || exists("g:loaded_netrwPlugin")
line 4:   finish
line 5: endif
line 6: 
line 7: packadd netrw
Searching for "pack/*/start/netrw" in "/home/Dante/.vim,/usr/share/vim/vimfiles,/usr/share/vim/vim91,/usr/share/vim/vimfiles/after,/home/Dante/.vim/after"
Searching for "/home/Dante/.vim/pack/*/start/netrw"
Searching for "/usr/share/vim/vimfiles/pack/*/start/netrw"
Searching for "/usr/share/vim/vim91/pack/*/start/netrw"
Searching for "/usr/share/vim/vimfiles/after/pack/*/start/netrw"
Searching for "/home/Dante/.vim/after/pack/*/start/netrw"
not found in 'packpath': "pack/*/start/netrw"
Searching for "pack/*/opt/netrw" in "/home/Dante/.vim,/usr/share/vim/vimfiles,/usr/share/vim/vim91,/usr/share/vim/vimfiles/after,/home/Dante/.vim/after"
Searching for "/home/Dante/.vim/pack/*/opt/netrw"
Searching for "/usr/share/vim/vimfiles/pack/*/opt/netrw"
Searching for "/usr/share/vim/vim91/pack/*/opt/netrw"
chdir(/usr/share/vim/vim91)
fchdir() to previous dir
chdir(/home/Dante/.vim)
fchdir() to previous dir
chdir(/home/Dante/.vim/plugged/onedark.vim)
fchdir() to previous dir
chdir(/home/Dante/.vim/plugged/onehalf/vim)
fchdir() to previous dir
chdir(/home/Dante/.vim/plugged/gruvbox)
fchdir() to previous dir
chdir(/home/Dante/.vim/plugged/lightline.vim)
fchdir() to previous dir
chdir(/home/Dante/.vim/plugged/vim-tmux-navigator)
fchdir() to previous dir
chdir(/home/Dante/.vim/plugged/vimtex)
fchdir() to previous dir
chdir(/home/Dante/.vim/plugged/nerdtree)
fchdir() to previous dir
chdir(/home/Dante/.vim/plugged/fzf)
fchdir() to previous dir
chdir(/home/Dante/.vim/plugged/fzf.vim)
fchdir() to previous dir
chdir(/home/Dante/.vim/plugged/vim-wayland-clipboard)
fchdir() to previous dir
chdir(/home/Dante/.vim/plugged/coc.nvim)
fchdir() to previous dir
chdir(/home/Dante/.vim/plugged/vim-obsession)
fchdir() to previous dir
chdir(/usr/share/vim/vimfiles)
fchdir() to previous dir
chdir(/usr/share/vim/vim91)
fchdir() to previous dir
chdir(/usr/share/vim/vim91/pack/dist/opt)
fchdir() to previous dir
chdir(/usr/share/vim/vim91/pack/dist/opt/netrw/plugin)
fchdir() to previous dir
line 7: sourcing "/usr/share/vim/vim91/pack/dist/opt/netrw/plugin/netrwPlugin.vim"
line 1: " Maintainer: Luca Saccarola <github.e41mv@aleeas.com>
line 2: " Former Maintainer: Charles E Campbell
line 3: " Upstream: <https://github.com/saccarosium/netrw.vim>
line 4: " Copyright:    Copyright (C) 1999-2021 Charles E. Campbell {{{
line 5: "               Permission is hereby granted to use and distribute this code,
line 6: "               with or without modifications, provided that this copyright
line 7: "               notice is copied with it. Like anything else that's free,
line 8: "               netrw.vim, netrwPlugin.vim, and netrwSettings.vim are provided
line 9: "               *as is* and comes with no warranty of any kind, either
line 10: "               expressed or implied. By using this plugin, you agree that
line 11: "               in no event will the copyright holder be liable for any damages
line 12: "               resulting from the use of this software. }}}
line 13: 
line 14: if &cp || exists("g:loaded_netrwPlugin")
line 15:     finish
line 16: endif
line 17: 
line 18: let g:loaded_netrwPlugin = "v175"
line 19: 
line 20: let s:keepcpo = &cpo
line 21: set cpo&vim
line 22: 
line 23: " Commands Launch/URL: {{{
line 24: 
line 25: command -complete=shellcmd -nargs=1 Launch call netrw#Launch(trim(<q-args>))
line 26: command -complete=file -nargs=1 Open call netrw#Open(trim(<q-args>))
line 27: 
line 28: " }}}
line 29: " Local Browsing Autocmds: {{{
line 30: 
line 31: augroup FileExplorer
line 32:     au!
line 33:     au BufLeave * if &ft != "netrw"|let w:netrw_prvfile= expand("%:p")|endif
line 34:     au BufEnter * sil call s:LocalBrowse(expand("<amatch>"))
line 35:     au VimEnter * sil call s:VimEnter(expand("<amatch>"))
line 36:     if has("win32")
line 37:         au BufEnter .* sil call s:LocalBrowse(expand("<amatch>"))
line 38:     endif
line 39: augroup END
line 40: 
line 41: " }}}
line 42: " Network Browsing Reading Writing: {{{
line 43: 
line 44: augroup Network
line 45:     au!
line 46:     au BufReadCmd file://* call netrw#FileUrlEdit(expand("<amatch>"))
line 47:     au BufReadCmd ftp://*,rcp://*,scp://*,http://*,https://*,dav://*,davs://*,rsync://*,sftp://* exe "sil doau BufReadPre ".fnameescape(expand("<amatch>"))|call netrw#Nread(2,expand("<amatch>"))|exe "sil doau BufReadPost ".fnameescape(expand("<amatch>"))
line 48:     au FileReadCmd ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://* exe "sil doau FileReadPre ".fnameescape(expand("<amatch>"))|call netrw#Nread(1,expand("<amatch>"))|exe "sil doau FileReadPost ".fnameescape(expand("<amatch>"))
line 49:     au BufWriteCmd ftp://*,rcp://*,scp://*,http://*,file://*,dav://*,davs://*,rsync://*,sftp://* exe "sil doau BufWritePre ".fnameescape(expand("<amatch>"))|exe 'Nwrite '.fnameescape(expand("<amatch>"))|exe "sil doau BufWritePost ".fnameescape(expand("<amatch>"))
line 50:     au FileWriteCmd ftp://*,rcp://*,scp://*,http://*,file://*,dav://*,davs://*,rsync://*,sftp://* exe "sil doau FileWritePre ".fnameescape(expand("<amatch>"))|exe "'[,']".'Nwrite '.fnameescape(expand("<amatch>"))|exe "sil doau FileWritePost ".fnameescape(expand("<amatch>"))
line 51:     try
line 52:         au SourceCmd   ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://* exe 'Nsource '.fnameescape(expand("<amatch>"))
line 53:     catch /^Vim\%((\a\+)\)\=:E216/
line 54:         au SourcePre   ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://* exe 'Nsource '.fnameescape(expand("<amatch>"))
line 55:     endtry
line 56: augroup END
line 57: 
line 58: " }}}
line 59: " Commands: :Nread, :Nwrite, :NetUserPass {{{
line 60: 
line 61: command! -count=1 -nargs=* Nread let s:svpos= winsaveview()<bar>call netrw#NetRead(<count>,<f-args>)<bar>call winrestview(s:svpos)
line 62: command! -range=% -nargs=* Nwrite let s:svpos= winsaveview()<bar><line1>,<line2>call netrw#NetWrite(<f-args>)<bar>call winrestview(s:svpos)
line 63: command! -nargs=* NetUserPass call NetUserPass(<f-args>)
line 64: command! -nargs=* Nsource let s:svpos= winsaveview()<bar>call netrw#NetSource(<f-args>)<bar>call winrestview(s:svpos)
line 65: command! -nargs=? Ntree call netrw#SetTreetop(1,<q-args>)
line 66: 
line 67: " }}}
line 68: " Commands: :Explore, :Sexplore, Hexplore, Vexplore, Lexplore {{{
line 69: 
line 70: command! -nargs=* -bar -bang -count=0 -complete=dir Explore call netrw#Explore(<count>, 0, 0+<bang>0, <q-args>)
line 71: command! -nargs=* -bar -bang -count=0 -complete=dir Sexplore call netrw#Explore(<count>, 1, 0+<bang>0, <q-args>)
line 72: command! -nargs=* -bar -bang -count=0 -complete=dir Hexplore call netrw#Explore(<count>, 1, 2+<bang>0, <q-args>)
line 73: command! -nargs=* -bar -bang -count=0 -complete=dir Vexplore call netrw#Explore(<count>, 1, 4+<bang>0, <q-args>)
line 74: command! -nargs=* -bar -count=0 -complete=dir Texplore call netrw#Explore(<count>, 0, 6, <q-args>)
line 75: command! -nargs=* -bar -bang -count=0 -complete=dir Lexplore call netrw#Lexplore(<count>, <bang>0, <q-args>)
line 76: command! -nargs=* -bar -bang Nexplore call netrw#Explore(-1, 0, 0, <q-args>)
line 77: command! -nargs=* -bar -bang Pexplore call netrw#Explore(-2, 0, 0, <q-args>)
line 78: 
line 79: " }}}
line 80: " Commands: NetrwSettings {{{
line 81: 
line 82: command! -nargs=0 NetrwSettings call netrwSettings#NetrwSettings()
line 83: command! -bang NetrwClean call netrw#Clean(<bang>0)
line 84: 
line 85: " }}}
line 86: " Maps: {{{
line 87: 
line 88: if !exists("g:netrw_nogx")
line 89:     if maparg('gx','n') == ""
line 90:         if !hasmapto('<Plug>NetrwBrowseX')
line 91:             nmap <unique> gx <Plug>NetrwBrowseX
line 92:         endif
line 93:         nno <silent> <Plug>NetrwBrowseX :call netrw#BrowseX(netrw#GX(),netrw#CheckIfRemote(netrw#GX()))<cr>
line 94:     endif
line 95:     if maparg('gx','x') == ""
line 96:         if !hasmapto('<Plug>NetrwBrowseXVis')
line 97:             xmap <unique> gx <Plug>NetrwBrowseXVis
line 98:         endif
line 99:         xno <silent> <Plug>NetrwBrowseXVis :<c-u>call netrw#BrowseXVis()<cr>
line 100:     endif
line 101: endif
line 102: 
line 103: if exists("g:netrw_usetab") && g:netrw_usetab
line 104:     if maparg('<c-tab>','n') == ""
line 105:         nmap <unique> <c-tab> <Plug>NetrwShrink
line 106:     endif
line 107:     nno <silent> <Plug>NetrwShrink :call netrw#Shrink()<cr>
line 108: endif
line 109: 
line 110: " }}}
line 111: " LocalBrowse: invokes netrw#LocalBrowseCheck() on directory buffers {{{
line 112: 
line 113: function! s:LocalBrowse(dirname)
line 145: 
line 146: " }}}
line 147: " s:VimEnter: after all vim startup stuff is done, this function is called. {{{
line 148: "             Its purpose: to look over all windows and run s:LocalBrowse() on
line 149: "             them, which checks if they're directories and will create a directory
line 150: "             listing when appropriate.
line 151: "             It also sets s:vimentered, letting s:LocalBrowse() know that s:VimEnter()
line 152: "             has already been called.
line 153: function! s:VimEnter(dirname)
line 171: 
line 172: " }}}
line 173: " NetrwStatusLine: {{{
line 174: 
line 175: function! NetrwStatusLine()
line 184: 
line 185: " }}}
line 186: " NetUserPass: set username and password for subsequent ftp transfer {{{
line 187: "   Usage:  :call NetUserPass()                 -- will prompt for userid and password
line 188: "           :call NetUserPass("uid")            -- will prompt for password
line 189: "           :call NetUserPass("uid","password") -- sets global userid and password
line 190: function! NetUserPass(...)
line 208: 
line 209: " }}}
line 210: 
line 211: let &cpo= s:keepcpo
line 212: unlet s:keepcpo
line 213: 
line 214: " vim:ts=8 sts=4 sw=4 et fdm=marker
finished sourcing /usr/share/vim/vim91/pack/dist/opt/netrw/plugin/netrwPlugin.vim
continuing in /usr/share/vim/vim91/plugin/netrwPlugin.vim
line 7: augroup filetypedetect
line 7: augroup END
Searching for "/usr/share/vim/vimfiles/after/pack/*/opt/netrw"
Searching for "/home/Dante/.vim/after/pack/*/opt/netrw"
line 8: 
line 9: " vim:ts=8 sts=2 sw=2 et
finished sourcing /usr/share/vim/vim91/plugin/netrwPlugin.vim
chdir(/usr/share/vim/vim91/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim91/plugin/rrhelper.vim"
line 1: " Vim plugin with helper function(s) for --remote-wait
line 2: " Maintainer: Flemming Madsen <fma@cci.dk>
line 3: " Last Change: 2008 May 29
line 4: 
line 5: " Has this already been loaded?
line 6: if exists("loaded_rrhelper") || !has("clientserver")
line 7:   finish
line 8: endif
line 9: let loaded_rrhelper = 1
line 10: 
line 11: " Setup answers for a --remote-wait client who will assume
line 12: " a SetupRemoteReplies() function in the command server
line 13: 
line 14: function SetupRemoteReplies()
line 41: 
line 42: function DoRemoteReply(id, cnt, group, file)
line 47: 
line 48: " vim: set sw=2 sts=2 :
finished sourcing /usr/share/vim/vim91/plugin/rrhelper.vim
chdir(/usr/share/vim/vim91/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim91/plugin/spellfile.vim"
line 1: " Vim plugin for downloading spell files
line 2: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 3: " Last Change:^I2023 Aug 10
line 4: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 5: 
line 6: " Exit quickly when:
line 7: " - this plugin was already loaded
line 8: " - when 'compatible' is set
line 9: " - some autocommands are already taking care of spell files
line 10: if exists("loaded_spellfile_plugin") || &cp || exists("#SpellFileMissing")
line 11:   finish
line 12: endif
line 13: let loaded_spellfile_plugin = 1
line 14: 
line 15: " The function is in the autoload directory.
line 16: autocmd SpellFileMissing * call spellfile#LoadFile(expand('<amatch>'))
finished sourcing /usr/share/vim/vim91/plugin/spellfile.vim
chdir(/usr/share/vim/vim91/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim91/plugin/tarPlugin.vim"
line 1: " tarPlugin.vim -- a Vim plugin for browsing tarfiles
line 2: " Original was copyright (c) 2002, Michael C. Toren <mct@toren.net>
line 3: " Modified by Charles E. Campbell
line 4: " Distributed under the GNU General Public License.
line 5: "
line 6: " Updates are available from <http://michael.toren.net/code/>.  If you
line 7: " find this script useful, or have suggestions for improvements, please
line 8: " let me know.
line 9: " Also look there for further comments and documentation.
line 10: "
line 11: " This part only sets the autocommands.  The functions are in autoload/tar.vim.
line 12: " ---------------------------------------------------------------------
line 13: "  Load Once: {{{1
line 14: if &cp || exists("g:loaded_tarPlugin")
line 15:  finish
line 16: endif
line 17: let g:loaded_tarPlugin = "v32"
line 18: let s:keepcpo          = &cpo
line 19: set cpo&vim
line 20: 
line 21: " ---------------------------------------------------------------------
line 22: "  Public Interface: {{{1
line 23: augroup tar
line 24:   au!
line 25:   au BufReadCmd   tarfile::*^Icall tar#Read(expand("<amatch>"), 1)
line 26:   au FileReadCmd  tarfile::*^Icall tar#Read(expand("<amatch>"), 0)
line 27:   au BufWriteCmd  tarfile::*^Icall tar#Write(expand("<amatch>"))
line 28:   au FileWriteCmd tarfile::*^Icall tar#Write(expand("<amatch>"))
line 29: 
line 30:   if has("unix")
line 31:    au BufReadCmd   tarfile::*/*^Icall tar#Read(expand("<amatch>"), 1)
line 32:    au FileReadCmd  tarfile::*/*^Icall tar#Read(expand("<amatch>"), 0)
line 33:    au BufWriteCmd  tarfile::*/*^Icall tar#Write(expand("<amatch>"))
line 34:    au FileWriteCmd tarfile::*/*^Icall tar#Write(expand("<amatch>"))
line 35:   endif
line 36: 
line 37:   au BufReadCmd   *.tar.gz^I^Icall tar#Browse(expand("<amatch>"))
line 38:   au BufReadCmd   *.tar^I^I^Icall tar#Browse(expand("<amatch>"))
line 39:   au BufReadCmd   *.lrp^I^I^Icall tar#Browse(expand("<amatch>"))
line 40:   au BufReadCmd   *.tar.bz2^I^Icall tar#Browse(expand("<amatch>"))
line 41:   au BufReadCmd   *.tar.Z^I^Icall tar#Browse(expand("<amatch>"))
line 42:   au BufReadCmd   *.tbz^I^I^Icall tar#Browse(expand("<amatch>"))
line 43:   au BufReadCmd   *.tgz^I^I^Icall tar#Browse(expand("<amatch>"))
line 44:   au BufReadCmd   *.tar.lzma^Icall tar#Browse(expand("<amatch>"))
line 45:   au BufReadCmd   *.tar.xz^I^Icall tar#Browse(expand("<amatch>"))
line 46:   au BufReadCmd   *.txz^I^I^Icall tar#Browse(expand("<amatch>"))
line 47:   au BufReadCmd   *.tar.zst^I^Icall tar#Browse(expand("<amatch>"))
line 48:   au BufReadCmd   *.tzst^I^I^Icall tar#Browse(expand("<amatch>"))
line 49: augroup END
line 50: com! -nargs=? -complete=file Vimuntar call tar#Vimuntar(<q-args>)
line 51: 
line 52: " ---------------------------------------------------------------------
line 53: " Restoration And Modelines: {{{1
line 54: " vim: fdm=marker
line 55: let &cpo= s:keepcpo
line 56: unlet s:keepcpo
finished sourcing /usr/share/vim/vim91/plugin/tarPlugin.vim
chdir(/usr/share/vim/vim91/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim91/plugin/tohtml.vim"
line 1: " Vim plugin for converting a syntax highlighted file to HTML.
line 2: " Maintainer: Ben Fritz <fritzophrenic@gmail.com>
line 3: " Last Change: 2023 Sep 07
line 4: "
line 5: " The core of the code is in $VIMRUNTIME/autoload/tohtml.vim and
line 6: " $VIMRUNTIME/syntax/2html.vim
line 7: "
line 8: if exists('g:loaded_2html_plugin')
line 9:   finish
line 10: endif
line 11: let g:loaded_2html_plugin = 'vim9.0_v2'
line 12: 
line 13: "
line 14: " Changelog: {{{
line 15: "   9.0_v2  (this version): - Warn if using deprecated g:use_xhtml option
line 16: "                           - Change default g:html_use_input_for_pc to "none"
line 17: "                             instead of "fallback". All modern browsers support
line 18: "                             the "user-select: none" and "content:" CSS
line 19: "                             properties so the older method relying on extra
line 20: "                             markup and unspecified browser/app clipboard
line 21: "                             handling is only needed in rare special cases.
line 22: "                           - Fix SourceForge issue #33: generate diff filler
line 23: "                             correctly when new lines have been added to or
line 24: "                             removed from end of buffer.
line 25: "                           - Fix SourceForge issue #32/Vim Github issue #8547:
line 26: "                             use translated highlight ID for styling the
line 27: "                             special-use group names (e.g. LineNr) used
line 28: "                             directly by name in the 2html processing.
line 29: "                           - Fix SourceForge issue #26, refactoring to use
line 30: "                             :let-heredoc style string assignment and
line 31: "                             additional fixes for ".." vs. "." style string
line 32: "                             concatenation. Requires Vim v8.1.1354 or higher.
line 33: "   9.0_v1  (Vim 9.0.1275): - Implement g:html_no_doc and g:html_no_modeline
line 34: "                             for diff mode. Add tests.
line 35: "           (Vim 9.0.1122): NOTE: no version string update for this version!
line 36: "                           - Bugfix for variable name in g:html_no_doc
line 37: "           (Vim 9.0.0819): NOTE: no version string update for this version!
line 38: "                           - Add options g:html_no_doc, g:html_no_lines,
line 39: "                             and g:html_no_modeline (partially included in Vim
line 40: "                             runtime prior to version string update).
line 41: "                           - Updates for new Vim9 string append style (i.e. use
line 42: "                             ".." instead of "."). Requires Vim version
line 43: "                             8.1.1114 or higher.
line 44: "
line 45: "   8.1 updates: {{{
line 46: "   8.1_v2  (Vim 8.1.2312): - Fix SourceForge issue #19: fix calculation of tab
line 47: "                             stop position to use in expanding a tab, when that
line 48: "                             tab occurs after a syntax match which in turn
line 49: "                             comes after previously expanded tabs.
line 50: "                           - Set eventignore while splitting a window for the
line 51: "                             destination file to ignore FileType events;
line 52: "                             speeds up processing when the destination file
line 53: "                             already exists and HTML highlight takes too long.
line 54: "                           - Fix SourceForge issue #20: progress bar could not be
line 55: "                             seen when DiffDelete background color matched
line 56: "                             StatusLine background color. Added TOhtmlProgress
line 57: "                             highlight group for manual user override, but
line 58: "                             calculate it to be visible compared to StatusLine
line 59: "                             by default.
line 60: "                           - Fix SourceForge issue #1: Remove workaround for old
line 61: "                             browsers which don't support 'ch' CSS unit, since
line 62: "                             all modern browsers, including IE>=9, support it.
line 63: "                           - Fix SourceForge issue #10: support termguicolors
line 64: "                           - Fix SourceForge issue #21: default to using
line 65: "                             generated content instead of <input> tags for
line 66: "                             uncopyable text, so that text is correctly
line 67: "                             prevented from being copied in chrome. Use
line 68: "                             g:html_use_input_for_pc option to control the
line 69: "                             method used.
line 70: "                           - Switch to HTML5 to allow using vnu as a validator
line 71: "                             in unit test.
line 72: "                           - Fix fallback sizing of <input> tags for browsers
line 73: "                             without "ch" support.
line 74: "                           - Fix cursor on unselectable diff filler text.
line 75: "   8.1_v1  (Vim 8.1.0528): - Fix SourceForge issue #6: Don't generate empty
line 76: "                             script tag.
line 77: "                           - Fix SourceForge issue #5: javascript should
line 78: "                             declare variables with "var".
line 79: "                           - Fix SourceForge issue #13: errors thrown sourcing
line 80: "                             2html.vim directly when plugins not loaded.
line 81: "                           - Fix SourceForge issue #16: support 'vartabstop'.
line 82: "}}}
line 83: "
line 84: "   7.4 updates: {{{
line 85: "   7.4_v2  (Vim 7.4.0899): Fix error raised when converting a diff containing
line 86: "                           an empty buffer. Jan Stocker: allow g:html_font to
line 87: "                           take a list so it is easier to specfiy fallback
line 88: "                           fonts in the generated CSS.
line 89: "   7.4_v1  (Vim 7.4.0000): Fix modeline mangling for new "Vim:" format, and
line 90: "^I^I^I    also for version-specific modelines like "vim>703:".
line 91: "}}}
line 92: "
line 93: "   7.3 updates: {{{
line 94: "   7.3_v14 (Vim 7.3.1246): Allow suppressing line number anchors using
line 95: "^I^I^I    g:html_line_ids=0. Allow customizing
line 96: "^I^I^I    important IDs (like line IDs and fold IDs) using
line 97: "^I^I^I    g:html_id_expr evaluated when the buffer conversion
line 98: "^I^I^I    is started.
line 99: "   7.3_v13 (Vim 7.3.1088): Keep foldmethod at manual in the generated file and
line 100: "^I^I^I    insert modeline to set it to manual.
line 101: "^I^I^I    Fix bug: diff mode with 2 unsaved buffers creates a
line 102: "^I^I^I    duplicate of one buffer instead of including both.
line 103: "^I^I^I    Add anchors to each line so you can put '#L123'
line 104: "^I^I^I    or '#123' at the end of the URL to jump to line 123
line 105: "^I^I^I    (idea by Andy Spencer). Add javascript to open folds
line 106: "^I^I^I    to show the anchor being jumped to if it is hidden.
line 107: "^I^I^I    Fix XML validation error: &nsbp; not part of XML.
line 108: "^I^I^I    Allow TOhtml to chain together with other commands
line 109: "^I^I^I    using |.
line 110: "   7.3_v12 (Vim 7.3.0616): Fix modeline mangling to also work for when multiple
line 111: "^I^I^I    highlight groups make up the start-of-modeline text.
line 112: "^I^I^I    Improve render time of page with uncopyable regions
line 113: "^I^I^I    by not using one-input-per-char. Change name of
line 114: "^I^I^I    uncopyable option from html_unselectable to
line 115: "^I^I^I    html_prevent_copy. Added html_no_invalid option and
line 116: "^I^I^I    default to inserting invalid markup for uncopyable
line 117: "^I^I^I    regions to prevent MS Word from pasting undeletable
line 118: "^I^I^I    <input> elements. Fix 'cpo' handling (Thilo Six).
line 119: "^I^I 7.3_v12b1: Add html_unselectable option. Rework logic to
line 120: "^I^I^I    eliminate post-processing substitute commands in
line 121: "^I^I^I    favor of doing the work up front. Remove unnecessary
line 122: "^I^I^I    special treatment of 'LineNr' highlight group. Minor
line 123: "^I^I^I    speed improvements. Fix modeline mangling in
line 124: "^I^I^I    generated output so it works for text in the first
line 125: "^I^I^I    column. Fix missing line number and fold column in
line 126: "^I^I^I    diff filler lines. Fix that some fonts have a 1px
line 127: "^I^I^I    gap (using a dirty hack, improvements welcome). Add
line 128: "^I^I^I    "colorscheme" meta tag. Does NOT include support for
line 129: "^I^I^I    the new default foldtext added in v11, as the patch
line 130: "^I^I^I    adding it has not yet been included in Vim.
line 131: "   7.3_v11 ( unreleased ): Support new default foldtext from patch by Christian
line 132: "^I^I^I    Brabandt in
line 133: "^I^I^I    http://groups.google.com/d/topic/vim_dev/B6FSGfq9VoI/discussion.
line 134: "^I^I^I    This patch has not yet been included in Vim, thus
line 135: "^I^I^I    these changes are removed in the next version.
line 136: "   7.3_v10 (Vim 7.3.0227): Fix error E684 when converting a range wholly inside
line 137: "^I^I^I    multiple nested folds with dynamic folding on.
line 138: "^I^I^I    Also fix problem with foldtext in this situation.
line 139: "   7.3_v9  (Vim 7.3.0170): Add html_pre_wrap option active with html_use_css
line 140: "^I^I^I    and without html_no_pre, default value same as
line 141: "^I^I^I    'wrap' option, (Andy Spencer). Don't use
line 142: "^I^I^I    'fileencoding' for converted document encoding if
line 143: "^I^I^I    'buftype' indicates a special buffer which isn't
line 144: "^I^I^I    written.
line 145: "   7.3_v8  (Vim 7.3.0100): Add html_expand_tabs option to allow leaving tab
line 146: "^I^I^I    characters in generated output (Andy Spencer).
line 147: "^I^I^I    Escape text that looks like a modeline so Vim
line 148: "^I^I^I    doesn't use anything in the converted HTML as a
line 149: "^I^I^I    modeline. Bugfixes: Fix folding when a fold starts
line 150: "^I^I^I    before the conversion range. Remove fold column when
line 151: "^I^I^I    there are no folds.
line 152: "   7.3_v7  (Vim 7-3-0063): see betas released on vim_dev below:
line 153: "^I^I  7.3_v7b3: Fixed bug, convert Unicode to UTF-8 all the way.
line 154: "^I^I  7.3_v7b2: Remove automatic detection of encodings that are not
line 155: "^I^I^I    supported by all major browsers according to
line 156: "^I^I^I    http://wiki.whatwg.org/wiki/Web_Encodings and
line 157: "^I^I^I    convert to UTF-8 for all Unicode encodings. Make
line 158: "^I^I^I    HTML encoding to Vim encoding detection be
line 159: "^I^I^I    case-insensitive for built-in pairs.
line 160: "^I^I  7.3_v7b1: Remove use of setwinvar() function which cannot be
line 161: "^I^I^I    called in restricted mode (Andy Spencer). Use
line 162: "^I^I^I    'fencoding' instead of 'encoding' to determine by
line 163: "^I^I^I    charset, and make sure the 'fenc' of the generated
line 164: "^I^I^I    file matches its indicated charset. Add charsets for
line 165: "^I^I^I    all of Vim's natively supported encodings.
line 166: "   7.3_v6  (Vim 7.3.0000): Really fix bug with 'nowrapscan', 'magic' and other
line 167: "^I^I^I    user settings interfering with diff mode generation,
line 168: "^I^I^I    trailing whitespace (e.g. line number column) when
line 169: "^I^I^I    using html_no_pre, and bugs when using
line 170: "^I^I^I    html_hover_unfold.
line 171: "   7.3_v5  ( unreleased ): Fix bug with 'nowrapscan' and also with out-of-sync
line 172: "^I^I^I    folds in diff mode when first line was folded.
line 173: "   7.3_v4  (Vim 7.3.0000): Bugfixes, especially for xhtml markup, and diff mode
line 174: "   7.3_v3  (Vim 7.3.0000): Refactor option handling and make html_use_css
line 175: "^I^I^I    default to true when not set to anything. Use strict
line 176: "^I^I^I    doctypes where possible. Rename use_xhtml option to
line 177: "^I^I^I    html_use_xhtml for consistency. Use .xhtml extension
line 178: "^I^I^I    when using this option. Add meta tag for settings.
line 179: "   7.3_v2  (Vim 7.3.0000): Fix syntax highlighting in diff mode to use both the
line 180: "^I^I^I    diff colors and the normal syntax colors
line 181: "   7.3_v1  (Vim 7.3.0000): Add conceal support and meta tags in output
line 182: "}}}
line 183: "}}}
line 184: 
line 185: " TODO: {{{
line 186: "   * Check the issue tracker:
line 187: "     https://sourceforge.net/p/vim-tohtml/issues/search/?q=%21status%3Aclosed
line 188: "   * Options for generating the CSS in external style sheets. New :TOcss
line 189: "     command to convert the current color scheme into a (mostly) generic CSS
line 190: "     stylesheet which can be re-used. Alternate stylesheet support? Good start
line 191: "     by Erik Falor
line 192: "     ( https://groups.google.com/d/topic/vim_use/7XTmC4D22dU/discussion ).
line 193: "   * Add optional argument to :TOhtml command to specify mode (gui, cterm,
line 194: "     term) to use for the styling. Suggestion by "nacitar".
line 195: "   * Add way to override or specify which RGB colors map to the color numbers
line 196: "     in cterm. Get better defaults than just guessing? Suggestion by "nacitar".
line 197: "   * Disable filetype detection until after all processing is done.
line 198: "   * Add option for not generating the hyperlink on stuff that looks like a
line 199: "     URL? Or just color the link to fit with the colorscheme (and only special
line 200: "     when hovering)?
line 201: "   * Bug: Opera does not allow printing more than one page if uncopyable
line 202: "     regions is turned on. Possible solution: Add normal text line numbers with
line 203: "     display:none, set to display:inline for print style sheets, and hide
line 204: "     <input> elements for print, to allow Opera printing multiple pages (and
line 205: "     other uncopyable areas?). May need to make the new text invisible to IE
line 206: "     with conditional comments to prevent copying it, IE for some reason likes
line 207: "     to copy hidden text. Other browsers too?
line 208: "   * Bug: still a 1px gap throughout the fold column when html_prevent_copy is
line 209: "     "fn" in some browsers. Specifically, in Chromium on Ubuntu (but not Chrome
line 210: "     on Windows). Perhaps it is font related?
line 211: "   * Bug: still some gaps in the fold column when html_prevent_copy contains
line 212: "     'd' and showing the whole diff (observed in multiple browsers). Only gaps
line 213: "     on diff lines though.
line 214: "   * Undercurl support via CSS3, with fallback to dotted or something:
line 215: "^Ihttps://groups.google.com/d/topic/vim_use/BzXA6He1pHg/discussion
line 216: "   * Redo updates for modified default foldtext (v11) when/if the patch is
line 217: "     accepted to modify it.
line 218: "   * Test case +diff_one_file-dynamic_folds+expand_tabs-hover_unfold
line 219: "^I^I+ignore_conceal-ignore_folding+no_foldcolumn+no_pre+no_progress
line 220: "^I^I+number_lines-pre_wrap-use_css+use_xhtml+whole_filler.xhtml
line 221: "     does not show the whole diff filler as it is supposed to?
line 222: "   * Bug: when 'isprint' is wrong for the current encoding, will generate
line 223: "     invalid content. Can/should anything be done about this? Maybe a separate
line 224: "     plugin to correct 'isprint' based on encoding?
line 225: "   * Check to see if the windows-125\d encodings actually work in Unix without
line 226: "     the 8bit- prefix. Add prefix to autoload dictionaries for Unix if not.
line 227: "   * Font auto-detection similar to
line 228: "     http://www.vim.org/scripts/script.php?script_id=2384 but for a variety of
line 229: "     platforms.
line 230: "   * Pull in code from http://www.vim.org/scripts/script.php?script_id=3113 :
line 231: "^I- listchars support
line 232: "^I- full-line background highlight
line 233: "^I- other?
line 234: "   * Make it so deleted lines in a diff don't create side-scrolling (get it
line 235: "     free with full-line background highlight above).
line 236: "   * Restore open/closed folds and cursor position after processing each file
line 237: "     with option not to restore for speed increase.
line 238: "   * Add extra meta info (generation time, etc.)?
line 239: "   * Tidy up so we can use strict doctype in even more situations
line 240: "   * Implementation detail: add threshold for writing the lines to the html
line 241: "     buffer before we're done (5000 or so lines should do it)
line 242: "   * TODO comments for code cleanup scattered throughout
line 243: "}}}
line 244: 
line 245: " Define the :TOhtml command when:
line 246: " - 'compatible' is not set
line 247: " - this plugin or user override was not already loaded
line 248: " - user commands are available. {{{
line 249: if !&cp && !exists(":TOhtml") && has("user_commands")
line 250:   command -range=% -bar TOhtml :call tohtml#Convert2HTML(<line1>, <line2>)
line 251: endif "}}}
line 252: 
line 253: " Make sure any patches will probably use consistent indent
line 254: "   vim: ts=8 sw=2 sts=2 noet fdm=marker
finished sourcing /usr/share/vim/vim91/plugin/tohtml.vim
chdir(/usr/share/vim/vim91/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim91/plugin/tutor.vim"
line 1: if exists('g:loaded_tutor_mode_plugin') || &compatible
line 2:     finish
line 3: endif
line 4: let g:loaded_tutor_mode_plugin = 1
line 5: 
line 6: command! -nargs=? -complete=custom,tutor#TutorCmdComplete Tutor call tutor#TutorCmd(<q-args>)
finished sourcing /usr/share/vim/vim91/plugin/tutor.vim
chdir(/usr/share/vim/vim91/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim91/plugin/vimballPlugin.vim"
line 1: " vimballPlugin : construct a file containing both paths and files
line 2: " Maintainer:^IThis runtime file is looking for a new maintainer.
line 3: " Original Author: Charles E. Campbell
line 4: " Copyright: (c) 2004-2014 by Charles E. Campbell
line 5: "            The VIM LICENSE applies to Vimball.vim, and Vimball.txt
line 6: "            (see |copyright|) except use "Vimball" instead of "Vim".
line 7: "            No warranty, express or implied.
line 8: "  *** ***   Use At-Your-Own-Risk!   *** ***
line 9: "
line 10: " (Rom 2:1 WEB) Therefore you are without excuse, O man, whoever you are who
line 11: "      judge. For in that which you judge another, you condemn yourself. For
line 12: "      you who judge practice the same things.
line 13: " GetLatestVimScripts: 1502 1 :AutoInstall: vimball.vim
line 14: 
line 15: " ---------------------------------------------------------------------
line 16: "  Load Once: {{{1
line 17: if &cp || exists("g:loaded_vimballPlugin")
line 18:  finish
line 19: endif
line 20: let g:loaded_vimballPlugin = "v37"
line 21: let s:keepcpo              = &cpo
line 22: set cpo&vim
line 23: 
line 24: " ------------------------------------------------------------------------------
line 25: " Public Interface: {{{1
line 26: com! -range   -complete=file -nargs=+ -bang MkVimball^I^Icall vimball#MkVimball(<line1>,<line2>,<bang>0,<f-args>)
line 27: com! -nargs=? -complete=dir  UseVimball^I^I^I^I^I^Icall vimball#Vimball(1,<f-args>)
line 28: com! -nargs=0                VimballList^I^I^I^I^Icall vimball#Vimball(0)
line 29: com! -nargs=* -complete=dir  RmVimball^I^I^I^I^I^Icall vimball#SaveSettings()|call vimball#RmVimball(<f-args>)|call vimball#RestoreSettings()
line 30: augroup Vimball
line 31:  au!
line 32:  au BufEnter  *.vba,*.vba.gz,*.vba.bz2,*.vba.zip,*.vba.xz if getline(1) =~ '^" Vimball Archiver' |  setlocal bt=nofile fmr=[[[,]]] fdm=marker|if &ff != 'unix'|setlocal ma ff=unix noma|endif|if line('$') > 1|call vimball#ShowMesg(0, "Source this file to extract it! (:so %)")|endif | endif
line 36:  au SourceCmd *.vba.gz,*.vba.bz2,*.vba.zip,*.vba.xz^I^I^Ilet s:origfile=expand("%")|if expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|endif|call vimball#Decompress(expand("<amatch>"))|so %|if s:origfile!=expand("<afile>")|close|endif
line 37:  au SourceCmd *.vba^I^I^I^I^I^I^I^I^I^I^Iif expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|call vimball#Vimball(1)|close|else|call vimball#Vimball(1)|endif
line 38:  au BufEnter  *.vmb,*.vmb.gz,*.vmb.bz2,*.vmb.zip,*.vmb.xz if getline(1) =~ '^" Vimball Archiver' |  setlocal bt=nofile fmr=[[[,]]] fdm=marker|if &ff != 'unix'|setlocal ma ff=unix noma|endif|if line('$') > 1|call vimball#ShowMesg(0,"Source this file to extract it! (:so %)")|endif | endif
line 42:  au SourceCmd *.vmb.gz,*.vmb.bz2,*.vmb.zip,*.vmb.xz^I^I^Ilet s:origfile=expand("%")|if expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|endif|call vimball#Decompress(expand("<amatch>"))|so %|if s:origfile!=expand("<afile>")|close|endif
line 43:  au SourceCmd *.vmb^I^I^I^I^I^I^I^I^I^I^Iif expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|call vimball#Vimball(1)|close|else|call vimball#Vimball(1)|endif
line 44: augroup END
line 45: 
line 46: " =====================================================================
line 47: " Restoration And Modelines: {{{1
line 48: " vim: fdm=marker
line 49: let &cpo= s:keepcpo
line 50: unlet s:keepcpo
line 51: 
line 52: " vim: ts=4:
finished sourcing /usr/share/vim/vim91/plugin/vimballPlugin.vim
chdir(/usr/share/vim/vim91/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim91/plugin/zipPlugin.vim"
line 1: " zipPlugin.vim: Handles browsing zipfiles
line 2: "            PLUGIN PORTION
line 3: " Date:^I^I^IDec 07, 2021
line 4: " Maintainer:^IThis runtime file is looking for a new maintainer.
line 5: " Former Maintainer:^ICharles E Campbell
line 6: " License:^I^IVim License  (see vim's :help license)
line 7: " Copyright:    Copyright (C) 2005-2016 Charles E. Campbell {{{1
line 8: "               Permission is hereby granted to use and distribute this code,
line 9: "               with or without modifications, provided that this copyright
line 10: "               notice is copied with it. Like anything else that's free,
line 11: "               zipPlugin.vim is provided *as is* and comes with no warranty
line 12: "               of any kind, either expressed or implied. By using this
line 13: "               plugin, you agree that in no event will the copyright
line 14: "               holder be liable for any damages resulting from the use
line 15: "               of this software.
line 16: "
line 17: " (James 4:8 WEB) Draw near to God, and he will draw near to you.
line 18: " Cleanse your hands, you sinners; and purify your hearts, you double-minded.
line 19: " ---------------------------------------------------------------------
line 20: " Load Once: {{{1
line 21: if &cp || exists("g:loaded_zipPlugin")
line 22:  finish
line 23: endif
line 24: let g:loaded_zipPlugin = "v33"
line 25: let s:keepcpo          = &cpo
line 26: set cpo&vim
line 27: 
line 28: " ---------------------------------------------------------------------
line 29: " Options: {{{1
line 30: if !exists("g:zipPlugin_ext")
line 31:  let g:zipPlugin_ext='*.aar,*.apk,*.celzip,*.crtx,*.docm,*.docx,*.dotm,*.dotx,*.ear,*.epub,*.gcsx,*.glox,*.gqsx,*.ja,*.jar,*.kmz,*.odb,*.odc,*.odf,*.odg,*.odi,*.odm,*.odp,*.ods,*.odt,*.otc,*.otf,*.otg,*.oth,*.oti,*.otp,*.ots,*.ott,*.oxt,*.potm,*.potx,*.ppam,*.ppsm,*.ppsx,*.pptm,*.pptx,*.sldx,*.thmx,*.vdw,*.war,*.wsz,*.xap,*.xlam,*.xlsb,*.xlsm,*.xlsx,*.xltm,*.xltx,*.xpi,*.zip'
line 32: endif
line 33: 
line 34: " ---------------------------------------------------------------------
line 35: " Public Interface: {{{1
line 36: augroup zip
line 37:  au!
line 38:  au BufReadCmd   zipfile:*^Icall zip#Read(expand("<amatch>"), 1)
line 39:  au FileReadCmd  zipfile:*^Icall zip#Read(expand("<amatch>"), 0)
line 40:  au BufWriteCmd  zipfile:*^Icall zip#Write(expand("<amatch>"))
line 41:  au FileWriteCmd zipfile:*^Icall zip#Write(expand("<amatch>"))
line 42: 
line 43:  if has("unix")
line 44:   au BufReadCmd   zipfile:*/*^Icall zip#Read(expand("<amatch>"), 1)
line 45:   au FileReadCmd  zipfile:*/*^Icall zip#Read(expand("<amatch>"), 0)
line 46:   au BufWriteCmd  zipfile:*/*^Icall zip#Write(expand("<amatch>"))
line 47:   au FileWriteCmd zipfile:*/*^Icall zip#Write(expand("<amatch>"))
line 48:  endif
line 49: 
line 50:  exe "au BufReadCmd ".g:zipPlugin_ext.' call zip#Browse(expand("<amatch>"))'
line 50: au BufReadCmd *.aar,*.apk,*.celzip,*.crtx,*.docm,*.docx,*.dotm,*.dotx,*.ear,*.epub,*.gcsx,*.glox,*.gqsx,*.ja,*.jar,*.kmz,*.odb,*.odc,*.odf,*.odg,*.odi,*.odm,*.odp,*.ods,*.odt,*.otc,*.otf,*.otg,*.oth,*.oti,*.otp,*.ots,*.ott,*.oxt,*.potm,*.potx,*.ppam,*.ppsm,*.ppsx,*.pptm,*.pptx,*.sldx,*.thmx,*.vdw,*.war,*.wsz,*.xap,*.xlam,*.xlsb,*.xlsm,*.xlsx,*.xltm,*.xltx,*.xpi,*.zip call zip#Browse(expand("<amatch>"))
line 51: augroup END
line 52: 
line 53: " ---------------------------------------------------------------------
line 54: "  Restoration And Modelines: {{{1
line 55: "  vim: fdm=marker
line 56: let &cpo= s:keepcpo
line 57: unlet s:keepcpo
finished sourcing /usr/share/vim/vim91/plugin/zipPlugin.vim
Searching for "pack/*/start/*" in "/home/Dante/.vim,/usr/share/vim/vimfiles,/usr/share/vim/vim91,/usr/share/vim/vimfiles/after,/home/Dante/.vim/after"
Searching for "/home/Dante/.vim/pack/*/start/*"
Searching for "/usr/share/vim/vimfiles/pack/*/start/*"
Searching for "/usr/share/vim/vim91/pack/*/start/*"
Searching for "/usr/share/vim/vimfiles/after/pack/*/start/*"
Searching for "/home/Dante/.vim/after/pack/*/start/*"
not found in 'packpath': "pack/*/start/*"
Searching for "plugin/**/*.vim" in "/home/Dante/.vim,/home/Dante/.vim/plugged/onedark.vim,/home/Dante/.vim/plugged/onehalf/vim,/home/Dante/.vim/plugged/gruvbox,/home/Dante/.vim/plugged/lightline.vim,/home/Dante/.vim/plugged/vim-tmux-navigator,/home/Dante/.vim/plugged/vimtex,/home/Dante/.vim/plugged/nerdtree,/home/Dante/.vim/plugged/fzf,/home/Dante/.vim/plugged/fzf.vim,/home/Dante/.vim/plugged/vim-wayland-clipboard,/home/Dante/.vim/plugged/coc.nvim,/home/Dante/.vim/plugged/vim-obsession,/usr/share/vim/vimfiles,/usr/share/vim/vim91,/usr/share/vim/vim91/pack/dist/opt/netrw,/usr/share/vim/vimfiles/after,/home/Dante/.vim/plugged/vimtex/after,/home/Dante/.vim/after"
Searching for "/usr/share/vim/vimfiles/after/plugin/**/*.vim"
Searching for "/home/Dante/.vim/plugged/vimtex/after/plugin/**/*.vim"
Searching for "/home/Dante/.vim/after/plugin/**/*.vim"
not found in 'runtimepath': "plugin/**/*.vim"
Reading viminfo file "/home/Dante/.viminfo" info oldfiles
Opening the X display took 0 msec
Testing the X display failed
Executing BufWinEnter Autocommands for "*"
autocommand let g:fzf#vim#buffers[bufnr('')] = reltimefloat(reltime())

Executing: let g:fzf#vim#buffers[bufnr('')] = reltimefloat(reltime())
Executing BufWinEnter Autocommands for "*"
autocommand call s:Autocmd('BufWinEnter', +expand('<abuf>'), win_getid())

Executing: call s:Autocmd('BufWinEnter', +expand('<abuf>'), win_getid())
calling <SNR>46_Autocmd('BufWinEnter', 1, 1000)

line 1:   if !get(g:, 'coc_workspace_initialized', 0)
line 2:     return
<SNR>46_Autocmd returning #0

continuing in BufWinEnter Autocommands for "*"

Executing BufWinEnter Autocommands for "*"
autocommand autocmd SafeState * ++once call s:Highlight_Matching_Pair()

Executing: autocmd SafeState * ++once call s:Highlight_Matching_Pair()
Executing BufEnter Autocommands for "*"
autocommand call lightline#update()

Executing: call lightline#update()
Searching for "autoload/lightline.vim" in "/home/Dante/.vim,/home/Dante/.vim/plugged/onedark.vim,/home/Dante/.vim/plugged/onehalf/vim,/home/Dante/.vim/plugged/gruvbox,/home/Dante/.vim/plugged/lightline.vim,/home/Dante/.vim/plugged/vim-tmux-navigator,/home/Dante/.vim/plugged/vimtex,/home/Dante/.vim/plugged/nerdtree,/home/Dante/.vim/plugged/fzf,/home/Dante/.vim/plugged/fzf.vim,/home/Dante/.vim/plugged/vim-wayland-clipboard,/home/Dante/.vim/plugged/coc.nvim,/home/Dante/.vim/plugged/vim-obsession,/usr/share/vim/vimfiles,/usr/share/vim/vim91,/usr/share/vim/vim91/pack/dist/opt/netrw,/usr/share/vim/vimfiles/after,/home/Dante/.vim/plugged/vimtex/after,/home/Dante/.vim/after"
Searching for "/home/Dante/.vim/autoload/lightline.vim"
Searching for "/home/Dante/.vim/plugged/onedark.vim/autoload/lightline.vim"
Searching for "/home/Dante/.vim/plugged/onehalf/vim/autoload/lightline.vim"
Searching for "/home/Dante/.vim/plugged/gruvbox/autoload/lightline.vim"
Searching for "/home/Dante/.vim/plugged/lightline.vim/autoload/lightline.vim"
chdir(/home/Dante/.vim/plugged/lightline.vim/autoload)
fchdir() to previous dir
line 0: sourcing "/home/Dante/.vim/plugged/lightline.vim/autoload/lightline.vim"
line 1: " =============================================================================
line 2: " Filename: autoload/lightline.vim
line 3: " Author: itchyny
line 4: " License: MIT License
line 5: " Last Change: 2024/12/30 21:33:02.
line 6: " =============================================================================
line 7: 
line 8: let s:save_cpo = &cpo
line 9: set cpo&vim
line 10: 
line 11: let s:_ = 1 " 1: uninitialized, 2: disabled
line 12: 
line 13: function! lightline#update() abort
line 28: 
line 29: if exists('*nvim_win_get_config')
line 30:   function! s:skip() abort
line 33: elseif exists('*win_gettype')
line 34:   function! s:skip() abort " Vim 8.2.0257 (00f3b4e007), 8.2.0991 (0fe937fd86), 8.2.0996 (40a019f157)
line 37: else
line 38:   function! s:skip() abort
line 41: endif
line 42: 
line 43: function! lightline#update_disable() abort
line 48: 
line 49: function! lightline#enable() abort
line 67: 
line 68: function! lightline#disable() abort
line 85: 
line 86: function! lightline#toggle() abort
line 93: 
line 94: let s:_lightline = {   'active': {     'left': [['mode', 'paste'], ['readonly', 'filename', 'modified']],     'right': [['lineinfo'], ['percent'], ['fileformat', 'fileencoding', 'filetype']]   },   'inactive': {     'left': [['filename']],     'right': [['lineinfo'], ['percent']]   },   'tabline': {     'left': [['tabs']],     'right': [['close']]   },   'tab': {     'active': ['tabnum', 'filename', 'modified'],     'inactive': ['tabnum', 'filename', 'modified']   },   'component': {     'mode': '%{lightline#mode()}',     'absolutepath': '%F', 'relativepath': '%f', 'filename': '%t', 'modified': '%M', 'bufnum': '%n',     'paste': '%{&paste?"PASTE":""}', 'readonly': '%R', 'charvalue': '%b', 'charvaluehex': '%B',     'spell': '%{&spell?&spelllang:""}', 'fileencoding': '%{&fenc!=#""?&fenc:&enc}', 'fileformat': '%{&ff}',     'filetype': '%{&ft!=#""?&ft:"no ft"}', 'percent': '%3p%%', 'percentwin': '%P',     'lineinfo': '%3l:%-2c', 'line': '%l', 'column': '%c', 'close': '%999X X ', 'winnr': '%{winnr()}'   }
line 153: function! lightline#init() abort
line 194: 
line 195: function! lightline#colorscheme() abort
line 212: 
line 213: function! lightline#palette() abort
line 216: 
line 217: function! lightline#mode() abort
line 220: 
line 221: let s:mode = ''
line 222: function! lightline#link(...) abort
line 247: 
line 248: function! s:term(p) abort
line 251: 
line 252: if exists('*uniq')
line 253:   let s:uniq = function('uniq')
line 254: else
line 255:   function! s:uniq(xs) abort
line 265: endif
line 266: 
line 267: function! lightline#highlight(...) abort
line 299: 
line 300: function! s:subseparator(components, subseparator, expanded) abort
line 307: 
line 308: function! lightline#concatenate(xs, right) abort
line 312: 
line 313: function! lightline#statusline(inactive) abort
line 319: 
line 320: function! s:evaluate_expand(component) abort
line 328: 
line 329: function! s:convert(name, index) abort
line 340: 
line 341: function! s:expand(components) abort
line 373: 
line 374: function! s:func(name) abort
line 377: 
line 378: function! s:line(tabline, inactive) abort
line 418: 
line 419: let s:tabnr = -1
line 420: let s:tabcnt = -1
line 421: let s:columns = -1
line 422: let s:tabline = ''
line 423: function! lightline#tabline() abort
line 435: 
line 436: function! lightline#tabs() abort
line 457: 
line 458: function! lightline#onetab(n, active) abort
line 469: 
line 470: function! lightline#error(msg) abort
line 475: 
line 476: let &cpo = s:save_cpo
line 477: unlet s:save_cpo
finished sourcing /home/Dante/.vim/plugged/lightline.vim/autoload/lightline.vim
continuing in BufEnter Autocommands for "*"
calling lightline#update()

line 1:   if s:skip() | return | endif
calling <SNR>67_skip()

line 1:     return win_gettype() ==# 'popup' || win_gettype() ==# 'autocmd'
<SNR>67_skip returning #0

continuing in lightline#update

line 1:  return | endif
line 1:  endif
line 2:   if s:_
line 3:     if s:_ == 2 | return | endif
line 3:  return | endif
line 3:  endif
line 4:     call lightline#init()
calling lightline#init()

line 1:   let s:lightline = deepcopy(get(g:, 'lightline', {}))
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 13:   call extend(s:lightline.tabline_separator, s:lightline.separator, 'keep')
line 14:   call extend(s:lightline.tabline_subseparator, s:lightline.subseparator, 'keep')
line 15:   let s:lightline.tabline_configured = has_key(get(get(g:, 'lightline', {}), 'component_expand', {}), 'tabs')
line 16:   for components in deepcopy(s:lightline.tabline.left + s:lightline.tabline.right)
line 17:     if len(filter(components, 'v:val !=# "tabs" && v:val !=# "close"')) > 0
line 18:       let s:lightline.tabline_configured = 1
line 19:       break
line 20:     endif
line 21:   endfor
line 16:   for components in deepcopy(s:lightline.tabline.left + s:lightline.tabline.right)
line 17:     if len(filter(components, 'v:val !=# "tabs" && v:val !=# "close"')) > 0
line 18:       let s:lightline.tabline_configured = 1
line 19:       break
line 20:     endif
line 21:   endfor
line 16:   for components in deepcopy(s:lightline.tabline.left + s:lightline.tabline.right)
line 17:     if len(filter(components, 'v:val !=# "tabs" && v:val !=# "close"')) > 0
line 18:       let s:lightline.tabline_configured = 1
line 19:       break
line 20:     endif
line 21:   endfor
line 22:   if !exists('s:_statusline')
line 23:     let s:_statusline = &statusline
line 24:   endif
line 25:   if !exists('s:_tabline')
line 26:     let s:_tabline = &tabline
line 27:   endif
line 28:   if s:lightline.enable.tabline
line 29:     set tabline=%!lightline#tabline()
line 30:   else
line 31:     let &tabline = get(s:, '_tabline', '')
line 32:   endif
line 33:   for f in values(s:lightline.component_function)
line 34:     silent! call call(f, [])
line 35:   endfor
line 36:   for f in values(s:lightline.tab_component_function)
line 37:     silent! call call(f, [1])
Searching for "autoload/lightline/tab.vim" in "/home/Dante/.vim,/home/Dante/.vim/plugged/onedark.vim,/home/Dante/.vim/plugged/onehalf/vim,/home/Dante/.vim/plugged/gruvbox,/home/Dante/.vim/plugged/lightline.vim,/home/Dante/.vim/plugged/vim-tmux-navigator,/home/Dante/.vim/plugged/vimtex,/home/Dante/.vim/plugged/nerdtree,/home/Dante/.vim/plugged/fzf,/home/Dante/.vim/plugged/fzf.vim,/home/Dante/.vim/plugged/vim-wayland-clipboard,/home/Dante/.vim/plugged/coc.nvim,/home/Dante/.vim/plugged/vim-obsession,/usr/share/vim/vimfiles,/usr/share/vim/vim91,/usr/share/vim/vim91/pack/dist/opt/netrw,/usr/share/vim/vimfiles/after,/home/Dante/.vim/plugged/vimtex/after,/home/Dante/.vim/after"
Searching for "/home/Dante/.vim/autoload/lightline/tab.vim"
Searching for "/home/Dante/.vim/plugged/onedark.vim/autoload/lightline/tab.vim"
Searching for "/home/Dante/.vim/plugged/onehalf/vim/autoload/lightline/tab.vim"
Searching for "/home/Dante/.vim/plugged/gruvbox/autoload/lightline/tab.vim"
Searching for "/home/Dante/.vim/plugged/lightline.vim/autoload/lightline/tab.vim"
chdir(/home/Dante/.vim/plugged/lightline.vim/autoload/lightline)
fchdir() to previous dir
line 37: sourcing "/home/Dante/.vim/plugged/lightline.vim/autoload/lightline/tab.vim"
line 1: " =============================================================================
line 2: " Filename: autoload/lightline/tab.vim
line 3: " Author: itchyny
line 4: " License: MIT License
line 5: " Last Change: 2016/05/07 22:31:02.
line 6: " =============================================================================
line 7: 
line 8: let s:save_cpo = &cpo
line 9: set cpo&vim
line 10: 
line 11: function! lightline#tab#filename(n) abort
line 17: 
line 18: function! lightline#tab#modified(n) abort
line 22: 
line 23: function! lightline#tab#readonly(n) abort
line 27: 
line 28: function! lightline#tab#tabnum(n) abort
line 31: 
line 32: let &cpo = s:save_cpo
line 33: unlet s:save_cpo
finished sourcing /home/Dante/.vim/plugged/lightline.vim/autoload/lightline/tab.vim
continuing in lightline#init
calling lightline#tab#tabnum(1)

line 1:   return a:n
lightline#tab#tabnum returning #1

continuing in lightline#init

line 38:   endfor
line 36:   for f in values(s:lightline.tab_component_function)
line 37:     silent! call call(f, [1])
calling lightline#tab#filename(1)

line 1:   let buflist = tabpagebuflist(a:n)
line 2:   let winnr = tabpagewinnr(a:n)
line 3:   let _ = expand('#'.buflist[winnr - 1].':t')
line 4:   return _ !=# '' ? _ : '[No Name]'
lightline#tab#filename returning '[No Name]'

continuing in lightline#init

line 38:   endfor
line 36:   for f in values(s:lightline.tab_component_function)
line 37:     silent! call call(f, [1])
calling lightline#tab#readonly(1)

line 1:   let winnr = tabpagewinnr(a:n)
line 2:   return gettabwinvar(a:n, winnr, '&readonly') ? 'RO' : ''
lightline#tab#readonly returning ''

continuing in lightline#init

line 38:   endfor
line 36:   for f in values(s:lightline.tab_component_function)
line 37:     silent! call call(f, [1])
calling lightline#tab#modified(1)

line 1:   let winnr = tabpagewinnr(a:n)
line 2:   return gettabwinvar(a:n, winnr, '&modified') ? '+' : gettabwinvar(a:n, winnr, '&modifiable') ? '' : '-'
lightline#tab#modified returning ''

continuing in lightline#init

line 38:   endfor
line 36:   for f in values(s:lightline.tab_component_function)
line 37:     silent! call call(f, [1])
line 38:   endfor
line 39:   let s:mode = ''
lightline#init returning #0

continuing in lightline#update

line 5:     call lightline#colorscheme()
calling lightline#colorscheme()

line 1:   try
line 2:     let s:lightline.palette = g:lightline#colorscheme#{s:lightline.colorscheme}#palette
Searching for "autoload/lightline/colorscheme/onehalfdark.vim" in "/home/Dante/.vim,/home/Dante/.vim/plugged/onedark.vim,/home/Dante/.vim/plugged/onehalf/vim,/home/Dante/.vim/plugged/gruvbox,/home/Dante/.vim/plugged/lightline.vim,/home/Dante/.vim/plugged/vim-tmux-navigator,/home/Dante/.vim/plugged/vimtex,/home/Dante/.vim/plugged/nerdtree,/home/Dante/.vim/plugged/fzf,/home/Dante/.vim/plugged/fzf.vim,/home/Dante/.vim/plugged/vim-wayland-clipboard,/home/Dante/.vim/plugged/coc.nvim,/home/Dante/.vim/plugged/vim-obsession,/usr/share/vim/vimfiles,/usr/share/vim/vim91,/usr/share/vim/vim91/pack/dist/opt/netrw,/usr/share/vim/vimfiles/after,/home/Dante/.vim/plugged/vimtex/after,/home/Dante/.vim/after"
Searching for "/home/Dante/.vim/autoload/lightline/colorscheme/onehalfdark.vim"
Searching for "/home/Dante/.vim/plugged/onedark.vim/autoload/lightline/colorscheme/onehalfdark.vim"
Searching for "/home/Dante/.vim/plugged/onehalf/vim/autoload/lightline/colorscheme/onehalfdark.vim"
chdir(/home/Dante/.vim/plugged/onehalf/vim/autoload/lightline/colorscheme)
fchdir() to previous dir
line 2: sourcing "/home/Dante/.vim/plugged/onehalf/vim/autoload/lightline/colorscheme/onehalfdark.vim"
line 1: " =============================================================================
line 2: " Filename: autoload/lightline/colorscheme/onehalfdark.vim
line 3: " Author: sonph
line 4: " License: MIT License
line 5: " Last Change: 2019/12/01
line 6: " =============================================================================
line 7: 
line 8: let s:mono0 = [ '#282c34', 236 ]
line 9: let s:mono1 = [ '#313640', 238 ]
line 10: let s:mono2 = [ '#5d677a', 243 ]
line 11: let s:mono3 = [ '#dcdfe4', 255 ]
line 12: 
line 13: let s:yellow = [ '#e5c07b', 180 ]
line 14: let s:red = [ '#e06c75', 168 ]
line 15: let s:magenta = [ '#c678dd', 176 ]
line 16: let s:blue = [ '#61afef', 75 ]
line 17: let s:cyan = [ '#56b6c2', 73 ]
line 18: let s:green = [ '#98c379', 114 ]
line 19: 
line 20: let s:p = {'normal': {}, 'inactive': {}, 'insert': {}, 'replace': {}, 'visual': {}, 'tabline': {}}
line 21: 
line 22: let s:p.normal.left = [ [ s:mono0, s:green ], [ s:mono3, s:mono2 ] ]
line 23: let s:p.normal.middle = [ [ s:green, s:mono1 ] ]
line 24: let s:p.normal.right = [ [ s:mono0, s:green ], [ s:mono3, s:mono2 ] ]
line 25: 
line 26: let s:p.normal.error = [ [ s:mono0, s:red ] ]
line 27: let s:p.normal.warning = [ [ s:mono0, s:yellow ] ]
line 28: 
line 29: let s:p.inactive.left =  [ [ s:mono3, s:mono2 ], [ s:mono3, s:mono2 ] ]
line 30: let s:p.inactive.middle = [ [ s:mono3, s:mono1 ] ]
line 31: let s:p.inactive.right = [ [ s:mono0, s:mono3 ], [ s:mono3, s:mono2 ] ]
line 32: 
line 33: let s:p.insert.left = [ [ s:mono0, s:blue ], [ s:mono3, s:mono2 ] ]
line 34: let s:p.insert.middle = [ [ s:blue, s:mono1 ] ]
line 35: let s:p.insert.right = [ [ s:mono0, s:blue ], [ s:mono3, s:mono2 ] ]
line 36: 
line 37: let s:p.replace.left = [ [ s:mono0, s:red ], [ s:mono3, s:mono2 ] ]
line 38: let s:p.replace.middle = [ [ s:red, s:mono1 ] ]
line 39: let s:p.replace.right = [ [ s:mono0, s:red ], [ s:mono3, s:mono2 ] ]
line 40: 
line 41: let s:p.visual.left = [ [ s:mono0, s:yellow ], [ s:mono3, s:mono2 ] ]
line 42: let s:p.visual.middle = [ [ s:yellow, s:mono1 ] ]
line 43: let s:p.visual.right = [ [ s:mono0, s:yellow ], [ s:mono3, s:mono2 ] ]
line 44: 
line 45: let s:p.tabline.left = [ [ s:mono2, s:mono1] ]
line 46: let s:p.tabline.tabsel = [ [ s:mono3, s:mono2 ] ]
line 47: let s:p.tabline.middle = [ [ s:mono2, s:mono1] ]
line 48: let s:p.tabline.right = [ [ s:mono0, s:mono3 ] ]
line 49: 
line 50: let g:lightline#colorscheme#onehalfdark#palette = lightline#colorscheme#flatten(s:p)
Searching for "autoload/lightline/colorscheme.vim" in "/home/Dante/.vim,/home/Dante/.vim/plugged/onedark.vim,/home/Dante/.vim/plugged/onehalf/vim,/home/Dante/.vim/plugged/gruvbox,/home/Dante/.vim/plugged/lightline.vim,/home/Dante/.vim/plugged/vim-tmux-navigator,/home/Dante/.vim/plugged/vimtex,/home/Dante/.vim/plugged/nerdtree,/home/Dante/.vim/plugged/fzf,/home/Dante/.vim/plugged/fzf.vim,/home/Dante/.vim/plugged/vim-wayland-clipboard,/home/Dante/.vim/plugged/coc.nvim,/home/Dante/.vim/plugged/vim-obsession,/usr/share/vim/vimfiles,/usr/share/vim/vim91,/usr/share/vim/vim91/pack/dist/opt/netrw,/usr/share/vim/vimfiles/after,/home/Dante/.vim/plugged/vimtex/after,/home/Dante/.vim/after"
Searching for "/home/Dante/.vim/autoload/lightline/colorscheme.vim"
Searching for "/home/Dante/.vim/plugged/onedark.vim/autoload/lightline/colorscheme.vim"
Searching for "/home/Dante/.vim/plugged/onehalf/vim/autoload/lightline/colorscheme.vim"
Searching for "/home/Dante/.vim/plugged/gruvbox/autoload/lightline/colorscheme.vim"
Searching for "/home/Dante/.vim/plugged/lightline.vim/autoload/lightline/colorscheme.vim"
chdir(/home/Dante/.vim/plugged/lightline.vim/autoload/lightline)
fchdir() to previous dir
line 50: sourcing "/home/Dante/.vim/plugged/lightline.vim/autoload/lightline/colorscheme.vim"
line 1: " =============================================================================
line 2: " Filename: autoload/lightline/colorscheme.vim
line 3: " Author: itchyny
line 4: " License: MIT License
line 5: " Last Change: 2019/09/07 11:20:37.
line 6: " =============================================================================
line 7: 
line 8: let s:save_cpo = &cpo
line 9: set cpo&vim
line 10: 
line 11: let s:cuicolor = { 'black'          : 16, 'white'          : 231, 'darkestgreen'   : 22, 'darkgreen'      : 28, 'mediumgreen'    : 70, 'brightgreen'    : 148, 'darkestcyan'    : 23, 'mediumcyan'     : 117, 'darkestblue'    : 24, 'darkblue'       : 31, 'darkestred'     : 52, 'darkred'        : 88, 'mediumred'      : 124, 'brightred'      : 160, 'brightestred'   : 196, 'darkestpurple'  : 55, 'mediumpurple'   : 98, 'brightpurple'   : 189, 'brightorange'   : 208, 'brightestorange': 214, 'gray0'          : 233, 'gray1'          : 235, 'gray2'          : 236, 'gray3'          : 239, 'gray4'          : 240, 'gray5'          : 241, 'gray6'          : 244, 'gray7'          : 245, 'gray8'          : 247, 'gray9'          : 250, 'gray10'         : 252, 'yellow'         : 136, 'orange'         : 166, 'red'            : 160, 'magenta'        : 125, 'violet'         : 61, 'blue'           : 33, 'cyan'           : 37, 'green'          : 64, }
line 60: 
line 61: let s:guicolor = { 'black'          : '#000000', 'white'          : '#ffffff', 'darkestgreen'   : '#005f00', 'darkgreen'      : '#008700', 'mediumgreen'    : '#5faf00', 'brightgreen'    : '#afdf00', 'darkestcyan'    : '#005f5f', 'mediumcyan'     : '#87dfff', 'darkestblue'    : '#005f87', 'darkblue'       : '#0087af', 'darkestred'     : '#5f0000', 'darkred'        : '#870000', 'mediumred'      : '#af0000', 'brightred'      : '#df0000', 'brightestred'   : '#ff0000', 'darkestpurple'  : '#5f00af', 'mediumpurple'   : '#875fdf', 'brightpurple'   : '#dfdfff', 'brightorange'   : '#ff8700', 'brightestorange': '#ffaf00', 'gray0'          : '#121212', 'gray1'          : '#262626', 'gray2'          : '#303030', 'gray3'          : '#4e4e4e', 'gray4'          : '#585858', 'gray5'          : '#606060', 'gray6'          : '#808080', 'gray7'          : '#8a8a8a', 'gray8'          : '#9e9e9e', 'gray9'          : '#bcbcbc', 'gray10'         : '#d0d0d0', 'yellow'         : '#b58900', 'orange'         : '#cb4b16', 'red' 
line 110: 
line 111: function! s:convert(rgb) abort
line 128: 
line 129: function! s:black(x) abort
line 141: 
line 142: function! s:nr(x) abort
line 145: 
line 146: function! s:rgb(r, g, b) abort
line 149: 
line 150: function! s:upconvert(nr) abort
line 182: 
line 183: function! lightline#colorscheme#fill(p) abort
line 208: 
line 209: function! lightline#colorscheme#flatten(p) abort
line 226: 
line 227: if has('gui_running') || (has('termguicolors') && &termguicolors)
line 228:   function! lightline#colorscheme#background() abort
line 231: else
line 232:   " &background is set inappropriately when the colorscheme sets ctermbg of the Normal group
line 233:   function! lightline#colorscheme#background() abort
line 254: endif
line 255: 
line 256: let &cpo = s:save_cpo
line 257: unlet s:save_cpo
finished sourcing /home/Dante/.vim/plugged/lightline.vim/autoload/lightline/colorscheme.vim
continuing in /home/Dante/.vim/plugged/onehalf/vim/autoload/lightline/colorscheme/onehalfdark.vim
calling lightline#colorscheme#flatten({'inactive': {'right': [[['#282c34', 2...[['#dcdfe4', 255], ['#5d677a', 243]]]}})

line 1:   for k in values(a:p)
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 14:   endfor
line 1:   for k in values(a:p)
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 14:   endfor
line 1:   for k in values(a:p)
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 14:   endfor
line 1:   for k in values(a:p)
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 14:   endfor
line 1:   for k in values(a:p)
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 14:   endfor
line 1:   for k in values(a:p)
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 14:   endfor
line 1:   for k in values(a:p)
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 14:   endfor
line 15:   return a:p
lightline#colorscheme#flatten returning {'inactive': {'right': [['#282c34', '#...5], ['#dcdfe4', '#5d677a', 255, 243]]}}

continuing in /home/Dante/.vim/plugged/onehalf/vim/autoload/lightline/colorscheme/onehalfdark.vim

finished sourcing /home/Dante/.vim/plugged/onehalf/vim/autoload/lightline/colorscheme/onehalfdark.vim
continuing in lightline#colorscheme
line 3:   catch
line 4:     call lightline#error('Could not load colorscheme ' . s:lightline.colorscheme . '.')
line 5:     let s:lightline.colorscheme = 'default'
line 6:     let s:lightline.palette = g:lightline#colorscheme#{s:lightline.colorscheme}#palette
line 7:   finally
line 8:     if has('win32') && !has('gui_running') && &t_Co < 256
line 9:       call lightline#colortable#gui2cui_palette(s:lightline.palette)
line 10:     endif
line 11:     let s:highlight = {}
line 12:     call lightline#highlight('normal')
calling lightline#highlight('normal')

line 1:   let [c, f] = [s:lightline.palette, s:lightline.mode_fallback]
line 2:   let [s:lightline.llen, s:lightline.rlen] = [len(c.normal.left), len(c.normal.right)]
line 3:   let [s:lightline.tab_llen, s:lightline.tab_rlen] = [len(has_key(get(c, 'tabline', {}), 'left') ? c.tabline.left : c.normal.left), len(has_key(get(c, 'tabline', {}), 'right') ? c.tabline.right : c.normal.right)]
line 4:   let types = map(s:uniq(sort(filter(values(s:lightline.component_type), 'v:val !=# "raw"'))), '[v:val, 1]')
line 5:   let modes = a:0 ? [a:1] : extend(['normal', 'insert', 'replace', 'visual', 'inactive', 'command', 'select', 'tabline'], exists(':terminal') == 2 ? ['terminal'] : [])
line 6:   for mode in modes
line 7:     let s:highlight[mode] = 1
line 8:     let d = has_key(c, mode) ? mode : has_key(f, mode) && has_key(c, f[mode]) ? f[mode] : 'normal'
line 9:     let left = d ==# 'tabline' ? s:lightline.tabline.left : d ==# 'inactive' ? s:lightline.inactive.left : s:lightline.active.left
line 10:     let right = d ==# 'tabline' ? s:lightline.tabline.right : d ==# 'inactive' ? s:lightline.inactive.right : s:lightline.active.right
line 11:     let ls = has_key(get(c, d, {}), 'left') ? c[d].left : has_key(f, d) && has_key(get(c, f[d], {}), 'left') ? c[f[d]].left : c.normal.left
line 12:     let ms = has_key(get(c, d, {}), 'middle') ? c[d].middle[0] : has_key(f, d) && has_key(get(c, f[d], {}), 'middle') ? c[f[d]].middle[0] : c.normal.middle[0]
line 13:     let rs = has_key(get(c, d, {}), 'right') ? c[d].right : has_key(f, d) && has_key(get(c, f[d], {}), 'right') ? c[f[d]].right : c.normal.right
line 14:     for [p, l, zs] in [['Left', len(left), ls], ['Right', len(right), rs]]
line 15:       for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i < l || i < 1
line 17:           let r = t ? (has_key(get(c, d, []), i) ? c[d][i][0] : has_key(get(c, 'tabline', {}), i) ? c.tabline[i][0] : get(c.normal, i, zs)[0]) : get(zs, i, ms)
line 18:           exec printf('hi Lightline%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', p, mode, i, r[0], r[1], r[2], r[3], s:term(r))
calling <SNR>67_term(['#282c34', '#98c379', 236, 114])

line 1:   return get(a:p, 4) !=# '' ? 'term='.a:p[4].' cterm='.a:p[4].' gui='.a:p[4] : ''
<SNR>67_term returning ''

continuing in lightline#highlight

line 18: hi LightlineLeft_normal_0 guifg=#282c34 guibg=#98c379 ctermfg=236 ctermbg=114 
line 19:         endif
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineLeft_normal_0_1 guifg=#98c379 guibg=#5d677a ctermfg=114 ctermbg=243
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineLeft_normal_0_tabsel guifg=#98c379 guibg=#5d677a ctermfg=114 ctermbg=243
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 26:       endfor
line 15:       for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i < l || i < 1
line 17:           let r = t ? (has_key(get(c, d, []), i) ? c[d][i][0] : has_key(get(c, 'tabline', {}), i) ? c.tabline[i][0] : get(c.normal, i, zs)[0]) : get(zs, i, ms)
line 18:           exec printf('hi Lightline%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', p, mode, i, r[0], r[1], r[2], r[3], s:term(r))
calling <SNR>67_term(['#dcdfe4', '#5d677a', 255, 243])

line 1:   return get(a:p, 4) !=# '' ? 'term='.a:p[4].' cterm='.a:p[4].' gui='.a:p[4] : ''
<SNR>67_term returning ''

continuing in lightline#highlight

line 18: hi LightlineLeft_normal_1 guifg=#dcdfe4 guibg=#5d677a ctermfg=255 ctermbg=243 
line 19:         endif
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineLeft_normal_1_2 guifg=#5d677a guibg=#313640 ctermfg=243 ctermbg=238
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineLeft_normal_1_tabsel guifg=#5d677a guibg=#5d677a ctermfg=243 ctermbg=243
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 26:       endfor
line 15:       for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i < l || i < 1
line 17:           let r = t ? (has_key(get(c, d, []), i) ? c[d][i][0] : has_key(get(c, 'tabline', {}), i) ? c.tabline[i][0] : get(c.normal, i, zs)[0]) : get(zs, i, ms)
line 18:           exec printf('hi Lightline%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', p, mode, i, r[0], r[1], r[2], r[3], s:term(r))
line 19:         endif
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 26:       endfor
line 15:       for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i < l || i < 1
line 17:           let r = t ? (has_key(get(c, d, []), i) ? c[d][i][0] : has_key(get(c, 'tabline', {}), i) ? c.tabline[i][0] : get(c.normal, i, zs)[0]) : get(zs, i, ms)
line 18:           exec printf('hi Lightline%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', p, mode, i, r[0], r[1], r[2], r[3], s:term(r))
calling <SNR>67_term(['#dcdfe4', '#5d677a', 255, 243])

line 1:   return get(a:p, 4) !=# '' ? 'term='.a:p[4].' cterm='.a:p[4].' gui='.a:p[4] : ''
<SNR>67_term returning ''

continuing in lightline#highlight

line 18: hi LightlineLeft_normal_tabsel guifg=#dcdfe4 guibg=#5d677a ctermfg=255 ctermbg=243 
line 19:         endif
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineLeft_normal_tabsel_0 guifg=#5d677a guibg=#98c379 ctermfg=243 ctermbg=114
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineLeft_normal_tabsel_1 guifg=#5d677a guibg=#5d677a ctermfg=243 ctermbg=243
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineLeft_normal_tabsel_2 guifg=#5d677a guibg=#313640 ctermfg=243 ctermbg=238
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineLeft_normal_tabsel_tabsel guifg=#5d677a guibg=#5d677a ctermfg=243 ctermbg=243
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 26:       endfor
line 15:       for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i < l || i < 1
line 17:           let r = t ? (has_key(get(c, d, []), i) ? c[d][i][0] : has_key(get(c, 'tabline', {}), i) ? c.tabline[i][0] : get(c.normal, i, zs)[0]) : get(zs, i, ms)
line 18:           exec printf('hi Lightline%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', p, mode, i, r[0], r[1], r[2], r[3], s:term(r))
line 19:         endif
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 26:       endfor
line 27:     endfor
line 14:     for [p, l, zs] in [['Left', len(left), ls], ['Right', len(right), rs]]
line 15:       for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i < l || i < 1
line 17:           let r = t ? (has_key(get(c, d, []), i) ? c[d][i][0] : has_key(get(c, 'tabline', {}), i) ? c.tabline[i][0] : get(c.normal, i, zs)[0]) : get(zs, i, ms)
line 18:           exec printf('hi Lightline%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', p, mode, i, r[0], r[1], r[2], r[3], s:term(r))
calling <SNR>67_term(['#282c34', '#98c379', 236, 114])

line 1:   return get(a:p, 4) !=# '' ? 'term='.a:p[4].' cterm='.a:p[4].' gui='.a:p[4] : ''
<SNR>67_term returning ''

continuing in lightline#highlight

line 18: hi LightlineRight_normal_0 guifg=#282c34 guibg=#98c379 ctermfg=236 ctermbg=114 
line 19:         endif
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineRight_normal_0_1 guifg=#98c379 guibg=#5d677a ctermfg=114 ctermbg=243
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineRight_normal_0_tabsel guifg=#98c379 guibg=#5d677a ctermfg=114 ctermbg=243
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 26:       endfor
line 15:       for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i < l || i < 1
line 17:           let r = t ? (has_key(get(c, d, []), i) ? c[d][i][0] : has_key(get(c, 'tabline', {}), i) ? c.tabline[i][0] : get(c.normal, i, zs)[0]) : get(zs, i, ms)
line 18:           exec printf('hi Lightline%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', p, mode, i, r[0], r[1], r[2], r[3], s:term(r))
calling <SNR>67_term(['#dcdfe4', '#5d677a', 255, 243])

line 1:   return get(a:p, 4) !=# '' ? 'term='.a:p[4].' cterm='.a:p[4].' gui='.a:p[4] : ''
<SNR>67_term returning ''

continuing in lightline#highlight

line 18: hi LightlineRight_normal_1 guifg=#dcdfe4 guibg=#5d677a ctermfg=255 ctermbg=243 
line 19:         endif
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineRight_normal_1_2 guifg=#5d677a guibg=#313640 ctermfg=243 ctermbg=238
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineRight_normal_1_tabsel guifg=#5d677a guibg=#5d677a ctermfg=243 ctermbg=243
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 26:       endfor
line 15:       for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i < l || i < 1
line 17:           let r = t ? (has_key(get(c, d, []), i) ? c[d][i][0] : has_key(get(c, 'tabline', {}), i) ? c.tabline[i][0] : get(c.normal, i, zs)[0]) : get(zs, i, ms)
line 18:           exec printf('hi Lightline%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', p, mode, i, r[0], r[1], r[2], r[3], s:term(r))
calling <SNR>67_term(['#98c379', '#313640', 114, 238])

line 1:   return get(a:p, 4) !=# '' ? 'term='.a:p[4].' cterm='.a:p[4].' gui='.a:p[4] : ''
<SNR>67_term returning ''

continuing in lightline#highlight

line 18: hi LightlineRight_normal_2 guifg=#98c379 guibg=#313640 ctermfg=114 ctermbg=238 
line 19:         endif
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineRight_normal_2_3 guifg=#313640 guibg=#313640 ctermfg=238 ctermbg=238
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineRight_normal_2_tabsel guifg=#313640 guibg=#5d677a ctermfg=238 ctermbg=243
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 26:       endfor
line 15:       for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i < l || i < 1
line 17:           let r = t ? (has_key(get(c, d, []), i) ? c[d][i][0] : has_key(get(c, 'tabline', {}), i) ? c.tabline[i][0] : get(c.normal, i, zs)[0]) : get(zs, i, ms)
line 18:           exec printf('hi Lightline%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', p, mode, i, r[0], r[1], r[2], r[3], s:term(r))
line 19:         endif
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 26:       endfor
line 15:       for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i < l || i < 1
line 17:           let r = t ? (has_key(get(c, d, []), i) ? c[d][i][0] : has_key(get(c, 'tabline', {}), i) ? c.tabline[i][0] : get(c.normal, i, zs)[0]) : get(zs, i, ms)
line 18:           exec printf('hi Lightline%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', p, mode, i, r[0], r[1], r[2], r[3], s:term(r))
calling <SNR>67_term(['#dcdfe4', '#5d677a', 255, 243])

line 1:   return get(a:p, 4) !=# '' ? 'term='.a:p[4].' cterm='.a:p[4].' gui='.a:p[4] : ''
<SNR>67_term returning ''

continuing in lightline#highlight

line 18: hi LightlineRight_normal_tabsel guifg=#dcdfe4 guibg=#5d677a ctermfg=255 ctermbg=243 
line 19:         endif
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineRight_normal_tabsel_0 guifg=#5d677a guibg=#98c379 ctermfg=243 ctermbg=114
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineRight_normal_tabsel_1 guifg=#5d677a guibg=#5d677a ctermfg=243 ctermbg=243
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineRight_normal_tabsel_2 guifg=#5d677a guibg=#313640 ctermfg=243 ctermbg=238
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineRight_normal_tabsel_3 guifg=#5d677a guibg=#313640 ctermfg=243 ctermbg=238
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineRight_normal_tabsel_tabsel guifg=#5d677a guibg=#5d677a ctermfg=243 ctermbg=243
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 26:       endfor
line 15:       for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i < l || i < 1
line 17:           let r = t ? (has_key(get(c, d, []), i) ? c[d][i][0] : has_key(get(c, 'tabline', {}), i) ? c.tabline[i][0] : get(c.normal, i, zs)[0]) : get(zs, i, ms)
line 18:           exec printf('hi Lightline%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', p, mode, i, r[0], r[1], r[2], r[3], s:term(r))
line 19:         endif
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 26:       endfor
line 27:     endfor
line 14:     for [p, l, zs] in [['Left', len(left), ls], ['Right', len(right), rs]]
line 15:       for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i < l || i < 1
line 17:           let r = t ? (has_key(get(c, d, []), i) ? c[d][i][0] : has_key(get(c, 'tabline', {}), i) ? c.tabline[i][0] : get(c.normal, i, zs)[0]) : get(zs, i, ms)
line 18:           exec printf('hi Lightline%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', p, mode, i, r[0], r[1], r[2], r[3], s:term(r))
line 19:         endif
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 26:       endfor
line 27:     endfor
line 28:     exec printf('hi LightlineMiddle_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', mode, ms[0], ms[1], ms[2], ms[3], s:term(ms))
calling <SNR>67_term(['#98c379', '#313640', 114, 238])

line 1:   return get(a:p, 4) !=# '' ? 'term='.a:p[4].' cterm='.a:p[4].' gui='.a:p[4] : ''
<SNR>67_term returning ''

continuing in lightline#highlight

line 28: hi LightlineMiddle_normal guifg=#98c379 guibg=#313640 ctermfg=114 ctermbg=238 
line 29:   endfor
line 6:   for mode in modes
line 7:     let s:highlight[mode] = 1
line 8:     let d = has_key(c, mode) ? mode : has_key(f, mode) && has_key(c, f[mode]) ? f[mode] : 'normal'
line 9:     let left = d ==# 'tabline' ? s:lightline.tabline.left : d ==# 'inactive' ? s:lightline.inactive.left : s:lightline.active.left
line 10:     let right = d ==# 'tabline' ? s:lightline.tabline.right : d ==# 'inactive' ? s:lightline.inactive.right : s:lightline.active.right
line 11:     let ls = has_key(get(c, d, {}), 'left') ? c[d].left : has_key(f, d) && has_key(get(c, f[d], {}), 'left') ? c[f[d]].left : c.normal.left
line 12:     let ms = has_key(get(c, d, {}), 'middle') ? c[d].middle[0] : has_key(f, d) && has_key(get(c, f[d], {}), 'middle') ? c[f[d]].middle[0] : c.normal.middle[0]
line 13:     let rs = has_key(get(c, d, {}), 'right') ? c[d].right : has_key(f, d) && has_key(get(c, f[d], {}), 'right') ? c[f[d]].right : c.normal.right
line 14:     for [p, l, zs] in [['Left', len(left), ls], ['Right', len(right), rs]]
line 15:       for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i < l || i < 1
line 17:           let r = t ? (has_key(get(c, d, []), i) ? c[d][i][0] : has_key(get(c, 'tabline', {}), i) ? c.tabline[i][0] : get(c.normal, i, zs)[0]) : get(zs, i, ms)
line 18:           exec printf('hi Lightline%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', p, mode, i, r[0], r[1], r[2], r[3], s:term(r))
line 19:         endif
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 26:       endfor
line 27:     endfor
line 28:     exec printf('hi LightlineMiddle_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', mode, ms[0], ms[1], ms[2], ms[3], s:term(ms))
line 29:   endfor
line 30:   if !a:0 | let s:mode = '' | endif
line 30:  let s:mode = '' | endif
line 30:  endif
lightline#highlight returning #0

continuing in lightline#colorscheme

line 13:     call lightline#link()
calling lightline#link()

line 1:   let mode = get(s:lightline._mode_, a:0 ? a:1 : mode(), 'normal')
line 2:   if s:mode ==# mode
line 3:     return ''
line 4:   endif
line 5:   let s:mode = mode
line 6:   if !has_key(s:highlight, mode)
line 7:     call lightline#highlight(mode)
line 8:   endif
line 9:   let types = map(s:uniq(sort(filter(values(s:lightline.component_type), 'v:val !=# "raw"'))), '[v:val, 1]')
line 10:   for [p, l] in [['Left', len(s:lightline.active.left)], ['Right', len(s:lightline.active.right)]]
line 11:     for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 12:       if i != l
line 13:         exec printf('hi link Lightline%s_active_%s Lightline%s_%s_%s', p, i, p, mode, i)
line 13: hi link LightlineLeft_active_0 LightlineLeft_normal_0
line 14:       endif
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 17: hi link LightlineLeft_active_0_1 LightlineLeft_normal_0_1
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 17: hi link LightlineLeft_active_0_tabsel LightlineLeft_normal_0_tabsel
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 20:     endfor
line 11:     for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 12:       if i != l
line 13:         exec printf('hi link Lightline%s_active_%s Lightline%s_%s_%s', p, i, p, mode, i)
line 13: hi link LightlineLeft_active_1 LightlineLeft_normal_1
line 14:       endif
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 17: hi link LightlineLeft_active_1_2 LightlineLeft_normal_1_2
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 17: hi link LightlineLeft_active_1_tabsel LightlineLeft_normal_1_tabsel
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 20:     endfor
line 11:     for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 12:       if i != l
line 13:         exec printf('hi link Lightline%s_active_%s Lightline%s_%s_%s', p, i, p, mode, i)
line 14:       endif
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 20:     endfor
line 11:     for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 12:       if i != l
line 13:         exec printf('hi link Lightline%s_active_%s Lightline%s_%s_%s', p, i, p, mode, i)
line 13: hi link LightlineLeft_active_tabsel LightlineLeft_normal_tabsel
line 14:       endif
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 17: hi link LightlineLeft_active_tabsel_0 LightlineLeft_normal_tabsel_0
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 17: hi link LightlineLeft_active_tabsel_1 LightlineLeft_normal_tabsel_1
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 17: hi link LightlineLeft_active_tabsel_2 LightlineLeft_normal_tabsel_2
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 17: hi link LightlineLeft_active_tabsel_tabsel LightlineLeft_normal_tabsel_tabsel
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 20:     endfor
line 11:     for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 12:       if i != l
line 13:         exec printf('hi link Lightline%s_active_%s Lightline%s_%s_%s', p, i, p, mode, i)
line 14:       endif
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 20:     endfor
line 21:   endfor
line 10:   for [p, l] in [['Left', len(s:lightline.active.left)], ['Right', len(s:lightline.active.right)]]
line 11:     for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 12:       if i != l
line 13:         exec printf('hi link Lightline%s_active_%s Lightline%s_%s_%s', p, i, p, mode, i)
line 13: hi link LightlineRight_active_0 LightlineRight_normal_0
line 14:       endif
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 17: hi link LightlineRight_active_0_1 LightlineRight_normal_0_1
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 17: hi link LightlineRight_active_0_tabsel LightlineRight_normal_0_tabsel
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 20:     endfor
line 11:     for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 12:       if i != l
line 13:         exec printf('hi link Lightline%s_active_%s Lightline%s_%s_%s', p, i, p, mode, i)
line 13: hi link LightlineRight_active_1 LightlineRight_normal_1
line 14:       endif
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 17: hi link LightlineRight_active_1_2 LightlineRight_normal_1_2
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 17: hi link LightlineRight_active_1_tabsel LightlineRight_normal_1_tabsel
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 20:     endfor
line 11:     for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 12:       if i != l
line 13:         exec printf('hi link Lightline%s_active_%s Lightline%s_%s_%s', p, i, p, mode, i)
line 13: hi link LightlineRight_active_2 LightlineRight_normal_2
line 14:       endif
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 17: hi link LightlineRight_active_2_3 LightlineRight_normal_2_3
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 17: hi link LightlineRight_active_2_tabsel LightlineRight_normal_2_tabsel
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 20:     endfor
line 11:     for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 12:       if i != l
line 13:         exec printf('hi link Lightline%s_active_%s Lightline%s_%s_%s', p, i, p, mode, i)
line 14:       endif
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 20:     endfor
line 11:     for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 12:       if i != l
line 13:         exec printf('hi link Lightline%s_active_%s Lightline%s_%s_%s', p, i, p, mode, i)
line 13: hi link LightlineRight_active_tabsel LightlineRight_normal_tabsel
line 14:       endif
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 17: hi link LightlineRight_active_tabsel_0 LightlineRight_normal_tabsel_0
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 17: hi link LightlineRight_active_tabsel_1 LightlineRight_normal_tabsel_1
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 17: hi link LightlineRight_active_tabsel_2 LightlineRight_normal_tabsel_2
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 17: hi link LightlineRight_active_tabsel_3 LightlineRight_normal_tabsel_3
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 17: hi link LightlineRight_active_tabsel_tabsel LightlineRight_normal_tabsel_tabsel
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 20:     endfor
line 11:     for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 12:       if i != l
line 13:         exec printf('hi link Lightline%s_active_%s Lightline%s_%s_%s', p, i, p, mode, i)
line 14:       endif
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 20:     endfor
line 21:   endfor
line 10:   for [p, l] in [['Left', len(s:lightline.active.left)], ['Right', len(s:lightline.active.right)]]
line 11:     for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 12:       if i != l
line 13:         exec printf('hi link Lightline%s_active_%s Lightline%s_%s_%s', p, i, p, mode, i)
line 14:       endif
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 20:     endfor
line 21:   endfor
line 22:   exec printf('hi link LightlineMiddle_active LightlineMiddle_%s', mode)
line 22: hi link LightlineMiddle_active LightlineMiddle_normal
line 23:   return ''
lightline#link returning ''

continuing in lightline#colorscheme

line 14:     let s:_ = 0
line 15:   endtry
lightline#colorscheme returning #0

continuing in lightline#update

line 6:   endif
line 7:   if s:lightline.enable.statusline
line 8:     let w = winnr()
line 9:     let s = winnr('$') == 1 && w > 0 ? [lightline#statusline(0)] : [lightline#statusline(0), lightline#statusline(1)]
calling lightline#statusline(0)

line 1:   if a:inactive && !has_key(s:highlight, 'inactive')
line 2:     call lightline#highlight('inactive')
line 3:   endif
line 4:   return s:line(0, a:inactive)
calling <SNR>67_line(0, 0)

line 1:   let _ = a:tabline ? '' : '%{lightline#link()}'
line 2:   if s:lightline.palette == {}
line 3:     call lightline#colorscheme()
line 4:   endif
line 5:   let [l, r] = a:tabline ? [s:lightline.tab_llen, s:lightline.tab_rlen] : [s:lightline.llen, s:lightline.rlen]
line 6:   let [p, s] = a:tabline ? [s:lightline.tabline_separator, s:lightline.tabline_subseparator] : [s:lightline.separator, s:lightline.subseparator]
line 7:   let [c, f, t, w] = [s:lightline.component, s:lightline.component_function, s:lightline.component_type, s:lightline.component_raw]
line 8:   let mode = a:tabline ? 'tabline' : a:inactive ? 'inactive' : 'active'
line 9:   let ls = has_key(s:lightline, mode) ? s:lightline[mode].left : s:lightline.active.left
line 10:   let [lc, le, li] = s:expand(ls)
calling <SNR>67_expand([['mode', 'paste'], ['readonly', 'filename', 'modified']])

line 1:   let components = []
line 2:   let expanded = []
line 3:   let indices = []
line 4:   let prevtype = ''
line 5:   let previndex = -1
line 6:   let xs = []
line 7:   call map(deepcopy(a:components), 'map(v:val, "extend(xs, s:convert(v:val, ''" . v:key . "''))")')
calling <SNR>67_convert('mode', '0')

line 1:   if !has_key(s:lightline.component_expand, a:name)
line 2:     return [[[a:name], 0, a:index, a:index]]
<SNR>67_convert returning [[['mode'], 0, '0', '0']]

continuing in <SNR>67_expand

calling <SNR>67_convert('paste', '0')

line 1:   if !has_key(s:lightline.component_expand, a:name)
line 2:     return [[[a:name], 0, a:index, a:index]]
<SNR>67_convert returning [[['paste'], 0, '0', '0']]

continuing in <SNR>67_expand

calling <SNR>67_convert('readonly', '1')

line 1:   if !has_key(s:lightline.component_expand, a:name)
line 2:     return [[[a:name], 0, a:index, a:index]]
<SNR>67_convert returning [[['readonly'], 0, '1', '1']]

continuing in <SNR>67_expand

calling <SNR>67_convert('filename', '1')

line 1:   if !has_key(s:lightline.component_expand, a:name)
line 2:     return [[[a:name], 0, a:index, a:index]]
<SNR>67_convert returning [[['filename'], 0, '1', '1']]

continuing in <SNR>67_expand

calling <SNR>67_convert('modified', '1')

line 1:   if !has_key(s:lightline.component_expand, a:name)
line 2:     return [[[a:name], 0, a:index, a:index]]
<SNR>67_convert returning [[['modified'], 0, '1', '1']]

continuing in <SNR>67_expand

line 8:   for [component, expand, type, index] in xs
line 9:     if prevtype !=# type
line 10:       for i in range(previndex + 1, max([previndex, index - 1]))
line 11:         call add(indices, string(i))
line 12:         call add(components, [])
line 13:         call add(expanded, [])
line 14:       endfor
line 15:       call add(indices, type)
line 16:       call add(components, [])
line 17:       call add(expanded, [])
line 18:     endif
line 19:     call extend(components[-1], component)
line 20:     call extend(expanded[-1], repeat([expand], len(component)))
line 21:     let prevtype = type
line 22:     let previndex = index
line 23:   endfor
line 8:   for [component, expand, type, index] in xs
line 9:     if prevtype !=# type
line 10:       for i in range(previndex + 1, max([previndex, index - 1]))
line 11:         call add(indices, string(i))
line 12:         call add(components, [])
line 13:         call add(expanded, [])
line 14:       endfor
line 15:       call add(indices, type)
line 16:       call add(components, [])
line 17:       call add(expanded, [])
line 18:     endif
line 19:     call extend(components[-1], component)
line 20:     call extend(expanded[-1], repeat([expand], len(component)))
line 21:     let prevtype = type
line 22:     let previndex = index
line 23:   endfor
line 8:   for [component, expand, type, index] in xs
line 9:     if prevtype !=# type
line 10:       for i in range(previndex + 1, max([previndex, index - 1]))
line 11:         call add(indices, string(i))
line 12:         call add(components, [])
line 13:         call add(expanded, [])
line 14:       endfor
line 15:       call add(indices, type)
line 16:       call add(components, [])
line 17:       call add(expanded, [])
line 18:     endif
line 19:     call extend(components[-1], component)
line 20:     call extend(expanded[-1], repeat([expand], len(component)))
line 21:     let prevtype = type
line 22:     let previndex = index
line 23:   endfor
line 8:   for [component, expand, type, index] in xs
line 9:     if prevtype !=# type
line 10:       for i in range(previndex + 1, max([previndex, index - 1]))
line 11:         call add(indices, string(i))
line 12:         call add(components, [])
line 13:         call add(expanded, [])
line 14:       endfor
line 15:       call add(indices, type)
line 16:       call add(components, [])
line 17:       call add(expanded, [])
line 18:     endif
line 19:     call extend(components[-1], component)
line 20:     call extend(expanded[-1], repeat([expand], len(component)))
line 21:     let prevtype = type
line 22:     let previndex = index
line 23:   endfor
line 8:   for [component, expand, type, index] in xs
line 9:     if prevtype !=# type
line 10:       for i in range(previndex + 1, max([previndex, index - 1]))
line 11:         call add(indices, string(i))
line 12:         call add(components, [])
line 13:         call add(expanded, [])
line 14:       endfor
line 15:       call add(indices, type)
line 16:       call add(components, [])
line 17:       call add(expanded, [])
line 18:     endif
line 19:     call extend(components[-1], component)
line 20:     call extend(expanded[-1], repeat([expand], len(component)))
line 21:     let prevtype = type
line 22:     let previndex = index
line 23:   endfor
line 8:   for [component, expand, type, index] in xs
line 9:     if prevtype !=# type
line 10:       for i in range(previndex + 1, max([previndex, index - 1]))
line 11:         call add(indices, string(i))
line 12:         call add(components, [])
line 13:         call add(expanded, [])
line 14:       endfor
line 15:       call add(indices, type)
line 16:       call add(components, [])
line 17:       call add(expanded, [])
line 18:     endif
line 19:     call extend(components[-1], component)
line 20:     call extend(expanded[-1], repeat([expand], len(component)))
line 21:     let prevtype = type
line 22:     let previndex = index
line 23:   endfor
line 24:   for i in range(previndex + 1, max([previndex, len(a:components) - 1]))
line 25:     call add(indices, string(i))
line 26:     call add(components, [])
line 27:     call add(expanded, [])
line 28:   endfor
line 29:   call add(indices, string(len(a:components)))
line 30:   return [components, expanded, indices]
<SNR>67_expand returning [[['mode', 'paste'], ['readonly', 'fil..., [[0, 0], [0, 0, 0]], ['0', '1', '2']]

continuing in <SNR>67_line

line 11:   let rs = has_key(s:lightline, mode) ? s:lightline[mode].right : s:lightline.active.right
line 12:   let [rc, re, ri] = s:expand(rs)
calling <SNR>67_expand([['lineinfo'], ['percent'], ['fileformat', 'fileencoding', 'filetype']])

line 1:   let components = []
line 2:   let expanded = []
line 3:   let indices = []
line 4:   let prevtype = ''
line 5:   let previndex = -1
line 6:   let xs = []
line 7:   call map(deepcopy(a:components), 'map(v:val, "extend(xs, s:convert(v:val, ''" . v:key . "''))")')
calling <SNR>67_convert('lineinfo', '0')

line 1:   if !has_key(s:lightline.component_expand, a:name)
line 2:     return [[[a:name], 0, a:index, a:index]]
<SNR>67_convert returning [[['lineinfo'], 0, '0', '0']]

continuing in <SNR>67_expand

calling <SNR>67_convert('percent', '1')

line 1:   if !has_key(s:lightline.component_expand, a:name)
line 2:     return [[[a:name], 0, a:index, a:index]]
<SNR>67_convert returning [[['percent'], 0, '1', '1']]

continuing in <SNR>67_expand

calling <SNR>67_convert('fileformat', '2')

line 1:   if !has_key(s:lightline.component_expand, a:name)
line 2:     return [[[a:name], 0, a:index, a:index]]
<SNR>67_convert returning [[['fileformat'], 0, '2', '2']]

continuing in <SNR>67_expand

calling <SNR>67_convert('fileencoding', '2')

line 1:   if !has_key(s:lightline.component_expand, a:name)
line 2:     return [[[a:name], 0, a:index, a:index]]
<SNR>67_convert returning [[['fileencoding'], 0, '2', '2']]

continuing in <SNR>67_expand

calling <SNR>67_convert('filetype', '2')

line 1:   if !has_key(s:lightline.component_expand, a:name)
line 2:     return [[[a:name], 0, a:index, a:index]]
<SNR>67_convert returning [[['filetype'], 0, '2', '2']]

continuing in <SNR>67_expand

line 8:   for [component, expand, type, index] in xs
line 9:     if prevtype !=# type
line 10:       for i in range(previndex + 1, max([previndex, index - 1]))
line 11:         call add(indices, string(i))
line 12:         call add(components, [])
line 13:         call add(expanded, [])
line 14:       endfor
line 15:       call add(indices, type)
line 16:       call add(components, [])
line 17:       call add(expanded, [])
line 18:     endif
line 19:     call extend(components[-1], component)
line 20:     call extend(expanded[-1], repeat([expand], len(component)))
line 21:     let prevtype = type
line 22:     let previndex = index
line 23:   endfor
line 8:   for [component, expand, type, index] in xs
line 9:     if prevtype !=# type
line 10:       for i in range(previndex + 1, max([previndex, index - 1]))
line 11:         call add(indices, string(i))
line 12:         call add(components, [])
line 13:         call add(expanded, [])
line 14:       endfor
line 15:       call add(indices, type)
line 16:       call add(components, [])
line 17:       call add(expanded, [])
line 18:     endif
line 19:     call extend(components[-1], component)
line 20:     call extend(expanded[-1], repeat([expand], len(component)))
line 21:     let prevtype = type
line 22:     let previndex = index
line 23:   endfor
line 8:   for [component, expand, type, index] in xs
line 9:     if prevtype !=# type
line 10:       for i in range(previndex + 1, max([previndex, index - 1]))
line 11:         call add(indices, string(i))
line 12:         call add(components, [])
line 13:         call add(expanded, [])
line 14:       endfor
line 15:       call add(indices, type)
line 16:       call add(components, [])
line 17:       call add(expanded, [])
line 18:     endif
line 19:     call extend(components[-1], component)
line 20:     call extend(expanded[-1], repeat([expand], len(component)))
line 21:     let prevtype = type
line 22:     let previndex = index
line 23:   endfor
line 8:   for [component, expand, type, index] in xs
line 9:     if prevtype !=# type
line 10:       for i in range(previndex + 1, max([previndex, index - 1]))
line 11:         call add(indices, string(i))
line 12:         call add(components, [])
line 13:         call add(expanded, [])
line 14:       endfor
line 15:       call add(indices, type)
line 16:       call add(components, [])
line 17:       call add(expanded, [])
line 18:     endif
line 19:     call extend(components[-1], component)
line 20:     call extend(expanded[-1], repeat([expand], len(component)))
line 21:     let prevtype = type
line 22:     let previndex = index
line 23:   endfor
line 8:   for [component, expand, type, index] in xs
line 9:     if prevtype !=# type
line 10:       for i in range(previndex + 1, max([previndex, index - 1]))
line 11:         call add(indices, string(i))
line 12:         call add(components, [])
line 13:         call add(expanded, [])
line 14:       endfor
line 15:       call add(indices, type)
line 16:       call add(components, [])
line 17:       call add(expanded, [])
line 18:     endif
line 19:     call extend(components[-1], component)
line 20:     call extend(expanded[-1], repeat([expand], len(component)))
line 21:     let prevtype = type
line 22:     let previndex = index
line 23:   endfor
line 8:   for [component, expand, type, index] in xs
line 9:     if prevtype !=# type
line 10:       for i in range(previndex + 1, max([previndex, index - 1]))
line 11:         call add(indices, string(i))
line 12:         call add(components, [])
line 13:         call add(expanded, [])
line 14:       endfor
line 15:       call add(indices, type)
line 16:       call add(components, [])
line 17:       call add(expanded, [])
line 18:     endif
line 19:     call extend(components[-1], component)
line 20:     call extend(expanded[-1], repeat([expand], len(component)))
line 21:     let prevtype = type
line 22:     let previndex = index
line 23:   endfor
line 24:   for i in range(previndex + 1, max([previndex, len(a:components) - 1]))
line 25:     call add(indices, string(i))
line 26:     call add(components, [])
line 27:     call add(expanded, [])
line 28:   endfor
line 29:   call add(indices, string(len(a:components)))
line 30:   return [components, expanded, indices]
<SNR>67_expand returning [[['lineinfo'], ['percent'], ['filefor... [0], [0, 0, 0]], ['0', '1', '2', '3']]

continuing in <SNR>67_line

line 13:   for i in range(len(lc))
line 14:     let _ .= '%#LightlineLeft_' . mode . '_' . li[i] . '#'
line 15:     for j in range(len(lc[i]))
line 16:       let x = le[i][j] ? lc[i][j] : has_key(f, lc[i][j]) ? s:func(f[lc[i][j]]) : get(c, lc[i][j], '')
line 17:       let _ .= has_key(t, lc[i][j]) && t[lc[i][j]] ==# 'raw' || get(w, lc[i][j]) || le[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
line 18:       if j < len(lc[i]) - 1 && s.left !=# ''
line 19:         let _ .= s:subseparator(lc[i][(j):], s.left, le[i][(j):])
calling <SNR>67_subseparator(['mode', 'paste'], '|', [0, 0])

line 1:   let [a, c, f, v, u] = [a:components, s:lightline.component, s:lightline.component_function, s:lightline.component_visible_condition, s:lightline.component_function_visible_condition]
line 2:   let xs = map(range(len(a:components)), 'a:expanded[v:val] ? "1" : has_key(f, a[v:val]) ? (has_key(u, a[v:val]) ? "(".u[a[v:val]].")" : (exists("*".f[a[v:val]]) ? "" : "exists(\"*".f[a[v:val]]."\")&&").f[a[v:val]]."()!=#\"\"") : has_key(v, a[v:val]) ? "(".v[a[v:val]].")" : has_key(c, a[v:val]) ? "1" : "0"')
line 5:   return '%{' . (xs[0] ==# '1' || xs[0] ==# '(1)' ? '' : xs[0] . '&&(') . join(xs[1:], '||') . (xs[0] ==# '1' || xs[0] ==# '(1)' ? '' : ')') . '?"' . a:subseparator . '":""}'
<SNR>67_subseparator returning '%{(&paste)?"|":""}'

continuing in <SNR>67_line

line 20:       endif
line 21:     endfor
line 15:     for j in range(len(lc[i]))
line 16:       let x = le[i][j] ? lc[i][j] : has_key(f, lc[i][j]) ? s:func(f[lc[i][j]]) : get(c, lc[i][j], '')
line 17:       let _ .= has_key(t, lc[i][j]) && t[lc[i][j]] ==# 'raw' || get(w, lc[i][j]) || le[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
line 18:       if j < len(lc[i]) - 1 && s.left !=# ''
line 19:         let _ .= s:subseparator(lc[i][(j):], s.left, le[i][(j):])
line 20:       endif
line 21:     endfor
line 15:     for j in range(len(lc[i]))
line 16:       let x = le[i][j] ? lc[i][j] : has_key(f, lc[i][j]) ? s:func(f[lc[i][j]]) : get(c, lc[i][j], '')
line 17:       let _ .= has_key(t, lc[i][j]) && t[lc[i][j]] ==# 'raw' || get(w, lc[i][j]) || le[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
line 18:       if j < len(lc[i]) - 1 && s.left !=# ''
line 19:         let _ .= s:subseparator(lc[i][(j):], s.left, le[i][(j):])
line 20:       endif
line 21:     endfor
line 22:     let _ .= '%#LightlineLeft_' . mode . '_' . li[i] . '_' . li[i + 1] . '#'
line 23:     let _ .= i < l + len(lc) - len(ls) && li[i] < l || li[i] != li[i + 1] ? p.left : len(lc[i]) ? s.left : ''
line 24:   endfor
line 13:   for i in range(len(lc))
line 14:     let _ .= '%#LightlineLeft_' . mode . '_' . li[i] . '#'
line 15:     for j in range(len(lc[i]))
line 16:       let x = le[i][j] ? lc[i][j] : has_key(f, lc[i][j]) ? s:func(f[lc[i][j]]) : get(c, lc[i][j], '')
line 17:       let _ .= has_key(t, lc[i][j]) && t[lc[i][j]] ==# 'raw' || get(w, lc[i][j]) || le[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
line 18:       if j < len(lc[i]) - 1 && s.left !=# ''
line 19:         let _ .= s:subseparator(lc[i][(j):], s.left, le[i][(j):])
calling <SNR>67_subseparator(['readonly', 'filename', 'modified'], '|', [0, 0, 0])

line 1:   let [a, c, f, v, u] = [a:components, s:lightline.component, s:lightline.component_function, s:lightline.component_visible_condition, s:lightline.component_function_visible_condition]
line 2:   let xs = map(range(len(a:components)), 'a:expanded[v:val] ? "1" : has_key(f, a[v:val]) ? (has_key(u, a[v:val]) ? "(".u[a[v:val]].")" : (exists("*".f[a[v:val]]) ? "" : "exists(\"*".f[a[v:val]]."\")&&").f[a[v:val]]."()!=#\"\"") : has_key(v, a[v:val]) ? "(".v[a[v:val]].")" : has_key(c, a[v:val]) ? "1" : "0"')
line 5:   return '%{' . (xs[0] ==# '1' || xs[0] ==# '(1)' ? '' : xs[0] . '&&(') . join(xs[1:], '||') . (xs[0] ==# '1' || xs[0] ==# '(1)' ? '' : ')') . '?"' . a:subseparator . '":""}'
<SNR>67_subseparator returning '%{(&readonly)&&(1||(&modified||!&modifiable))?"|":""}'

continuing in <SNR>67_line

line 20:       endif
line 21:     endfor
line 15:     for j in range(len(lc[i]))
line 16:       let x = le[i][j] ? lc[i][j] : has_key(f, lc[i][j]) ? s:func(f[lc[i][j]]) : get(c, lc[i][j], '')
line 17:       let _ .= has_key(t, lc[i][j]) && t[lc[i][j]] ==# 'raw' || get(w, lc[i][j]) || le[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
line 18:       if j < len(lc[i]) - 1 && s.left !=# ''
line 19:         let _ .= s:subseparator(lc[i][(j):], s.left, le[i][(j):])
calling <SNR>67_subseparator(['filename', 'modified'], '|', [0, 0])

line 1:   let [a, c, f, v, u] = [a:components, s:lightline.component, s:lightline.component_function, s:lightline.component_visible_condition, s:lightline.component_function_visible_condition]
line 2:   let xs = map(range(len(a:components)), 'a:expanded[v:val] ? "1" : has_key(f, a[v:val]) ? (has_key(u, a[v:val]) ? "(".u[a[v:val]].")" : (exists("*".f[a[v:val]]) ? "" : "exists(\"*".f[a[v:val]]."\")&&").f[a[v:val]]."()!=#\"\"") : has_key(v, a[v:val]) ? "(".v[a[v:val]].")" : has_key(c, a[v:val]) ? "1" : "0"')
line 5:   return '%{' . (xs[0] ==# '1' || xs[0] ==# '(1)' ? '' : xs[0] . '&&(') . join(xs[1:], '||') . (xs[0] ==# '1' || xs[0] ==# '(1)' ? '' : ')') . '?"' . a:subseparator . '":""}'
<SNR>67_subseparator returning '%{(&modified||!&modifiable)?"|":""}'

continuing in <SNR>67_line

line 20:       endif
line 21:     endfor
line 15:     for j in range(len(lc[i]))
line 16:       let x = le[i][j] ? lc[i][j] : has_key(f, lc[i][j]) ? s:func(f[lc[i][j]]) : get(c, lc[i][j], '')
line 17:       let _ .= has_key(t, lc[i][j]) && t[lc[i][j]] ==# 'raw' || get(w, lc[i][j]) || le[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
line 18:       if j < len(lc[i]) - 1 && s.left !=# ''
line 19:         let _ .= s:subseparator(lc[i][(j):], s.left, le[i][(j):])
line 20:       endif
line 21:     endfor
line 15:     for j in range(len(lc[i]))
line 16:       let x = le[i][j] ? lc[i][j] : has_key(f, lc[i][j]) ? s:func(f[lc[i][j]]) : get(c, lc[i][j], '')
line 17:       let _ .= has_key(t, lc[i][j]) && t[lc[i][j]] ==# 'raw' || get(w, lc[i][j]) || le[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
line 18:       if j < len(lc[i]) - 1 && s.left !=# ''
line 19:         let _ .= s:subseparator(lc[i][(j):], s.left, le[i][(j):])
line 20:       endif
line 21:     endfor
line 22:     let _ .= '%#LightlineLeft_' . mode . '_' . li[i] . '_' . li[i + 1] . '#'
line 23:     let _ .= i < l + len(lc) - len(ls) && li[i] < l || li[i] != li[i + 1] ? p.left : len(lc[i]) ? s.left : ''
line 24:   endfor
line 13:   for i in range(len(lc))
line 14:     let _ .= '%#LightlineLeft_' . mode . '_' . li[i] . '#'
line 15:     for j in range(len(lc[i]))
line 16:       let x = le[i][j] ? lc[i][j] : has_key(f, lc[i][j]) ? s:func(f[lc[i][j]]) : get(c, lc[i][j], '')
line 17:       let _ .= has_key(t, lc[i][j]) && t[lc[i][j]] ==# 'raw' || get(w, lc[i][j]) || le[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
line 18:       if j < len(lc[i]) - 1 && s.left !=# ''
line 19:         let _ .= s:subseparator(lc[i][(j):], s.left, le[i][(j):])
line 20:       endif
line 21:     endfor
line 22:     let _ .= '%#LightlineLeft_' . mode . '_' . li[i] . '_' . li[i + 1] . '#'
line 23:     let _ .= i < l + len(lc) - len(ls) && li[i] < l || li[i] != li[i + 1] ? p.left : len(lc[i]) ? s.left : ''
line 24:   endfor
line 25:   let _ .= '%#LightlineMiddle_' . mode . '#%='
line 26:   for i in range(len(rc) - 1, 0, -1)
line 27:     let _ .= '%#LightlineRight_' . mode . '_' . ri[i] . '_' . ri[i + 1] . '#'
line 28:     let _ .= i < r + len(rc) - len(rs) && ri[i] < r || ri[i] != ri[i + 1] ? p.right : len(rc[i]) ? s.right : ''
line 29:     let _ .= '%#LightlineRight_' . mode . '_' . ri[i] . '#'
line 30:     for j in range(len(rc[i]))
line 31:       let x = re[i][j] ? rc[i][j] : has_key(f, rc[i][j]) ? s:func(f[rc[i][j]]) : get(c, rc[i][j], '')
line 32:       let _ .= has_key(t, rc[i][j]) && t[rc[i][j]] ==# 'raw' || get(w, rc[i][j]) || re[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
line 33:       if j < len(rc[i]) - 1 && s.right !=# ''
line 34:         let _ .= s:subseparator(rc[i][(j):], s.right, re[i][(j):])
calling <SNR>67_subseparator(['fileformat', 'fileencoding', 'filetype'], '|', [0, 0, 0])

line 1:   let [a, c, f, v, u] = [a:components, s:lightline.component, s:lightline.component_function, s:lightline.component_visible_condition, s:lightline.component_function_visible_condition]
line 2:   let xs = map(range(len(a:components)), 'a:expanded[v:val] ? "1" : has_key(f, a[v:val]) ? (has_key(u, a[v:val]) ? "(".u[a[v:val]].")" : (exists("*".f[a[v:val]]) ? "" : "exists(\"*".f[a[v:val]]."\")&&").f[a[v:val]]."()!=#\"\"") : has_key(v, a[v:val]) ? "(".v[a[v:val]].")" : has_key(c, a[v:val]) ? "1" : "0"')
line 5:   return '%{' . (xs[0] ==# '1' || xs[0] ==# '(1)' ? '' : xs[0] . '&&(') . join(xs[1:], '||') . (xs[0] ==# '1' || xs[0] ==# '(1)' ? '' : ')') . '?"' . a:subseparator . '":""}'
<SNR>67_subseparator returning '%{1||1?"|":""}'

continuing in <SNR>67_line

line 35:       endif
line 36:     endfor
line 30:     for j in range(len(rc[i]))
line 31:       let x = re[i][j] ? rc[i][j] : has_key(f, rc[i][j]) ? s:func(f[rc[i][j]]) : get(c, rc[i][j], '')
line 32:       let _ .= has_key(t, rc[i][j]) && t[rc[i][j]] ==# 'raw' || get(w, rc[i][j]) || re[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
line 33:       if j < len(rc[i]) - 1 && s.right !=# ''
line 34:         let _ .= s:subseparator(rc[i][(j):], s.right, re[i][(j):])
calling <SNR>67_subseparator(['fileencoding', 'filetype'], '|', [0, 0])

line 1:   let [a, c, f, v, u] = [a:components, s:lightline.component, s:lightline.component_function, s:lightline.component_visible_condition, s:lightline.component_function_visible_condition]
line 2:   let xs = map(range(len(a:components)), 'a:expanded[v:val] ? "1" : has_key(f, a[v:val]) ? (has_key(u, a[v:val]) ? "(".u[a[v:val]].")" : (exists("*".f[a[v:val]]) ? "" : "exists(\"*".f[a[v:val]]."\")&&").f[a[v:val]]."()!=#\"\"") : has_key(v, a[v:val]) ? "(".v[a[v:val]].")" : has_key(c, a[v:val]) ? "1" : "0"')
line 5:   return '%{' . (xs[0] ==# '1' || xs[0] ==# '(1)' ? '' : xs[0] . '&&(') . join(xs[1:], '||') . (xs[0] ==# '1' || xs[0] ==# '(1)' ? '' : ')') . '?"' . a:subseparator . '":""}'
<SNR>67_subseparator returning '%{1?"|":""}'

continuing in <SNR>67_line

line 35:       endif
line 36:     endfor
line 30:     for j in range(len(rc[i]))
line 31:       let x = re[i][j] ? rc[i][j] : has_key(f, rc[i][j]) ? s:func(f[rc[i][j]]) : get(c, rc[i][j], '')
line 32:       let _ .= has_key(t, rc[i][j]) && t[rc[i][j]] ==# 'raw' || get(w, rc[i][j]) || re[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
line 33:       if j < len(rc[i]) - 1 && s.right !=# ''
line 34:         let _ .= s:subseparator(rc[i][(j):], s.right, re[i][(j):])
line 35:       endif
line 36:     endfor
line 30:     for j in range(len(rc[i]))
line 31:       let x = re[i][j] ? rc[i][j] : has_key(f, rc[i][j]) ? s:func(f[rc[i][j]]) : get(c, rc[i][j], '')
line 32:       let _ .= has_key(t, rc[i][j]) && t[rc[i][j]] ==# 'raw' || get(w, rc[i][j]) || re[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
line 33:       if j < len(rc[i]) - 1 && s.right !=# ''
line 34:         let _ .= s:subseparator(rc[i][(j):], s.right, re[i][(j):])
line 35:       endif
line 36:     endfor
line 37:   endfor
line 26:   for i in range(len(rc) - 1, 0, -1)
line 27:     let _ .= '%#LightlineRight_' . mode . '_' . ri[i] . '_' . ri[i + 1] . '#'
line 28:     let _ .= i < r + len(rc) - len(rs) && ri[i] < r || ri[i] != ri[i + 1] ? p.right : len(rc[i]) ? s.right : ''
line 29:     let _ .= '%#LightlineRight_' . mode . '_' . ri[i] . '#'
line 30:     for j in range(len(rc[i]))
line 31:       let x = re[i][j] ? rc[i][j] : has_key(f, rc[i][j]) ? s:func(f[rc[i][j]]) : get(c, rc[i][j], '')
line 32:       let _ .= has_key(t, rc[i][j]) && t[rc[i][j]] ==# 'raw' || get(w, rc[i][j]) || re[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
line 33:       if j < len(rc[i]) - 1 && s.right !=# ''
line 34:         let _ .= s:subseparator(rc[i][(j):], s.right, re[i][(j):])
line 35:       endif
line 36:     endfor
line 30:     for j in range(len(rc[i]))
line 31:       let x = re[i][j] ? rc[i][j] : has_key(f, rc[i][j]) ? s:func(f[rc[i][j]]) : get(c, rc[i][j], '')
line 32:       let _ .= has_key(t, rc[i][j]) && t[rc[i][j]] ==# 'raw' || get(w, rc[i][j]) || re[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
line 33:       if j < len(rc[i]) - 1 && s.right !=# ''
line 34:         let _ .= s:subseparator(rc[i][(j):], s.right, re[i][(j):])
line 35:       endif
line 36:     endfor
line 37:   endfor
line 26:   for i in range(len(rc) - 1, 0, -1)
line 27:     let _ .= '%#LightlineRight_' . mode . '_' . ri[i] . '_' . ri[i + 1] . '#'
line 28:     let _ .= i < r + len(rc) - len(rs) && ri[i] < r || ri[i] != ri[i + 1] ? p.right : len(rc[i]) ? s.right : ''
line 29:     let _ .= '%#LightlineRight_' . mode . '_' . ri[i] . '#'
line 30:     for j in range(len(rc[i]))
line 31:       let x = re[i][j] ? rc[i][j] : has_key(f, rc[i][j]) ? s:func(f[rc[i][j]]) : get(c, rc[i][j], '')
line 32:       let _ .= has_key(t, rc[i][j]) && t[rc[i][j]] ==# 'raw' || get(w, rc[i][j]) || re[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
line 33:       if j < len(rc[i]) - 1 && s.right !=# ''
line 34:         let _ .= s:subseparator(rc[i][(j):], s.right, re[i][(j):])
line 35:       endif
line 36:     endfor
line 30:     for j in range(len(rc[i]))
line 31:       let x = re[i][j] ? rc[i][j] : has_key(f, rc[i][j]) ? s:func(f[rc[i][j]]) : get(c, rc[i][j], '')
line 32:       let _ .= has_key(t, rc[i][j]) && t[rc[i][j]] ==# 'raw' || get(w, rc[i][j]) || re[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
line 33:       if j < len(rc[i]) - 1 && s.right !=# ''
line 34:         let _ .= s:subseparator(rc[i][(j):], s.right, re[i][(j):])
line 35:       endif
line 36:     endfor
line 37:   endfor
line 26:   for i in range(len(rc) - 1, 0, -1)
line 27:     let _ .= '%#LightlineRight_' . mode . '_' . ri[i] . '_' . ri[i + 1] . '#'
line 28:     let _ .= i < r + len(rc) - len(rs) && ri[i] < r || ri[i] != ri[i + 1] ? p.right : len(rc[i]) ? s.right : ''
line 29:     let _ .= '%#LightlineRight_' . mode . '_' . ri[i] . '#'
line 30:     for j in range(len(rc[i]))
line 31:       let x = re[i][j] ? rc[i][j] : has_key(f, rc[i][j]) ? s:func(f[rc[i][j]]) : get(c, rc[i][j], '')
line 32:       let _ .= has_key(t, rc[i][j]) && t[rc[i][j]] ==# 'raw' || get(w, rc[i][j]) || re[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
line 33:       if j < len(rc[i]) - 1 && s.right !=# ''
line 34:         let _ .= s:subseparator(rc[i][(j):], s.right, re[i][(j):])
line 35:       endif
line 36:     endfor
line 37:   endfor
line 38:   return _
<SNR>67_line returning '%{lightline#link()}%#LightlineLeft_ac...LightlineRight_active_0#%( %3l:%-2c %)'

continuing in lightline#statusline

lightline#statusline returning '%{lightline#link()}%#LightlineLeft_ac...LightlineRight_active_0#%( %3l:%-2c %)'

continuing in lightline#update

line 10:     for n in range(1, winnr('$'))
line 11:       call setwinvar(n, '&statusline', s[n!=w])
line 12:     endfor
line 10:     for n in range(1, winnr('$'))
line 11:       call setwinvar(n, '&statusline', s[n!=w])
line 12:     endfor
line 13:   endif
lightline#update returning #0

continuing in BufEnter Autocommands for "*"

Executing BufEnter Autocommands for "*"
autocommand call nerdtree#checkForBrowse(expand('<amatch>'))

Executing: call nerdtree#checkForBrowse(expand('<amatch>'))
calling nerdtree#checkForBrowse('')

line 1:     if !isdirectory(a:dir)
line 2:         return
nerdtree#checkForBrowse returning #0

continuing in BufEnter Autocommands for "*"

Executing BufEnter Autocommands for "*"
autocommand call s:Autocmd('BufEnter', +expand('<abuf>'))

Executing: call s:Autocmd('BufEnter', +expand('<abuf>'))
calling <SNR>46_Autocmd('BufEnter', 1)

line 1:   if !get(g:, 'coc_workspace_initialized', 0)
line 2:     return
<SNR>46_Autocmd returning #0

continuing in BufEnter Autocommands for "*"

Executing BufEnter Autocommands for "*"
autocommand if !get(g:, 'obsession_no_bufenter') |   exe s:persist() | endif

Executing: if !get(g:, 'obsession_no_bufenter') |   exe s:persist() | endif
Executing:    exe s:persist() | endif
calling <SNR>51_persist()

line 1:   if exists('g:SessionLoad')
line 2:     return ''
line 3:   endif
line 4:   let sessionoptions = &sessionoptions
line 5:   if exists('g:this_obsession')
line 6:     let tmp = g:this_obsession . '.' . getpid() . '.obsession~'
line 7:     try
line 8:       set sessionoptions-=blank sessionoptions-=options sessionoptions+=tabpages
line 9:       exe s:doautocmd_user('ObsessionPre')
line 10:       execute 'mksession!' fnameescape(tmp)
line 11:       let v:this_session = g:this_obsession
line 12:       let body = readfile(tmp)
line 13:       call insert(body, 'let g:this_session = v:this_session', -3)
line 14:       call insert(body, 'let g:this_obsession = v:this_session', -3)
line 15:       if type(get(g:, 'obsession_append')) == type([])
line 16:         for line in g:obsession_append
line 17:           call insert(body, line, -3)
line 18:         endfor
line 19:       endif
line 20:       call writefile(body, tmp)
line 21:       call rename(tmp, g:this_obsession)
line 22:       let g:this_session = g:this_obsession
line 23:       exe s:doautocmd_user('Obsession')
line 24:     catch /^Vim(mksession):E11:/
line 25:       return ''
line 26:     catch
line 27:       unlet g:this_obsession
line 28:       let &l:readonly = &l:readonly
line 29:       return 'echoerr '.string(v:exception)
line 30:     finally
line 31:       let &sessionoptions = sessionoptions
line 32:       call delete(tmp)
line 33:     endtry
line 34:   endif
line 35:   return ''
<SNR>51_persist returning ''

continuing in BufEnter Autocommands for "*"

Executing: 
Executing:  endif
Executing BufEnter Autocommands for "*"
autocommand sil call s:LocalBrowse(expand("<amatch>"))

Executing: sil call s:LocalBrowse(expand("<amatch>"))
calling <SNR>59_LocalBrowse('')

line 1:     " do not trigger in the terminal
line 2:     " https://github.com/vim/vim/issues/16463
line 3:     if &buftype ==# 'terminal'
line 4:         return
line 5:     endif
line 6: 
line 7:     if !exists("s:vimentered")
line 8:         " If s:vimentered doesn't exist, then the VimEnter event hasn't fired.  It will,
line 9:         " and so s:VimEnter() will then be calling this routine, but this time with s:vimentered defined.
line 10:         return
<SNR>59_LocalBrowse returning #0

continuing in BufEnter Autocommands for "*"

Executing VimEnter Autocommands for "*"
autocommand silent! autocmd! FileExplorer

Executing: silent! autocmd! FileExplorer
autocommand call nerdtree#checkForBrowse(expand('<amatch>'))

Executing: call nerdtree#checkForBrowse(expand('<amatch>'))
calling nerdtree#checkForBrowse('')

line 1:     if !isdirectory(a:dir)
line 2:         return
nerdtree#checkForBrowse returning #0

continuing in VimEnter Autocommands for "*"

Executing VimEnter Autocommands for "*"
autocommand call s:VimEnter()

Executing: call s:VimEnter()
calling <SNR>46_VimEnter()

line 1:   if coc#rpc#started()
calling coc#rpc#started()

line 1:   return !empty(s:client)
coc#rpc#started returning #1

continuing in <SNR>46_VimEnter

line 2:     if !exists('$COC_NVIM_REMOTE_ADDRESS')
line 3:       call coc#rpc#notify('VimEnter', [coc#util#path_replace_patterns(), join(globpath(&runtimepath, "", 0, 1), ",")])
calling coc#util#path_replace_patterns()

line 1:   if has('win32unix') && exists('g:coc_cygqwin_path_prefixes')
line 2:     echohl WarningMsg
line 3:     echon 'g:coc_cygqwin_path_prefixes is deprecated, use g:coc_uri_prefix_replace_patterns instead'
line 4:     echohl None
line 5:     return g:coc_cygqwin_path_prefixes
line 6:   endif
line 7:   if exists('g:coc_uri_prefix_replace_patterns')
line 8:     return g:coc_uri_prefix_replace_patterns
line 9:   endif
line 10:   return v:null
coc#util#path_replace_patterns returning v:null

continuing in <SNR>46_VimEnter

calling coc#rpc#notify('VimEnter', [v:null, '/home/Dante/.vim/,/home/Dant...home/Dante/.vim/plugged/vimtex/after/'])

line 1:   if !coc#rpc#ready()
calling coc#rpc#ready()

line 1:   if empty(s:client) || s:client['running'] == 0
line 2:     return 0
line 3:   endif
line 4:   return 1
coc#rpc#ready returning #1

continuing in coc#rpc#notify

line 2:     return ''
line 3:   endif
line 4:   call s:client['notify'](a:method, a:args)
calling <SNR>49_notify('VimEnter', [v:null, '/home/Dante/.vim/,/home/Dant...home/Dante/.vim/plugged/vimtex/after/'])

line 1:   let channel = coc#client#get_channel(self)
calling coc#client#get_channel()

line 1:   if s:is_vim
line 2:     return a:client['channel']
coc#client#get_channel returning channel 0 open

continuing in <SNR>49_notify

line 2:   if empty(channel)
line 3:     return ''
line 4:   endif
line 5:   try
line 6:     if s:is_vim
line 7:       call ch_sendraw(channel, json_encode([0, [a:method, a:args]])."\n")
line 8:     else
line 9:       call call('rpcnotify', [channel, a:method] + a:args)
line 10:     endif
line 11:   catch /.*/
line 12:     if v:exception =~# 'E475'
line 13:       if get(g:, 'coc_vim_leaving', 0)
line 14:         return
line 15:       endif
line 16:       echohl Error | echom '['.self.name.'] server connection lost' | echohl None
line 16:  echom '['.self.name.'] server connection lost' | echohl None
line 16:  echohl None
line 17:       let name = self.name
line 18:       call s:on_exit(name, 0)
line 19:       execute 'silent do User ConnectionLost'.toupper(name[0]).name[1:]
line 20:     elseif v:exception =~# 'E12'
line 21:       " neovim's bug, ignore it
line 22:     else
line 23:       echohl Error | echo 'Error on notify ('.a:method.'): '.v:exception | echohl None
line 23:  echo 'Error on notify ('.a:method.'): '.v:exception | echohl None
line 23:  echohl None
line 24:     endif
line 25:   endtry
<SNR>49_notify returning #0

continuing in coc#rpc#notify

line 5:   return ''
coc#rpc#notify returning ''

continuing in <SNR>46_VimEnter

line 4:     endif
line 5:   elseif get(g:, 'coc_start_at_startup', 1)
line 6:     call coc#rpc#start_server()
line 7:   endif
line 8:   call s:Highlight()
calling <SNR>46_Highlight()

line 1:   if coc#highlight#get_contrast('Normal', has('nvim') ? 'NormalFloat' : 'Pmenu') > 2.0
Searching for "autoload/coc/highlight.vim" in "/home/Dante/.vim,/home/Dante/.vim/plugged/onedark.vim,/home/Dante/.vim/plugged/onehalf/vim,/home/Dante/.vim/plugged/gruvbox,/home/Dante/.vim/plugged/lightline.vim,/home/Dante/.vim/plugged/vim-tmux-navigator,/home/Dante/.vim/plugged/vimtex,/home/Dante/.vim/plugged/nerdtree,/home/Dante/.vim/plugged/fzf,/home/Dante/.vim/plugged/fzf.vim,/home/Dante/.vim/plugged/vim-wayland-clipboard,/home/Dante/.vim/plugged/coc.nvim,/home/Dante/.vim/plugged/vim-obsession,/usr/share/vim/vimfiles,/usr/share/vim/vim91,/usr/share/vim/vim91/pack/dist/opt/netrw,/usr/share/vim/vimfiles/after,/home/Dante/.vim/plugged/vimtex/after,/home/Dante/.vim/after"
Searching for "/home/Dante/.vim/autoload/coc/highlight.vim"
Searching for "/home/Dante/.vim/plugged/onedark.vim/autoload/coc/highlight.vim"
Searching for "/home/Dante/.vim/plugged/onehalf/vim/autoload/coc/highlight.vim"
Searching for "/home/Dante/.vim/plugged/gruvbox/autoload/coc/highlight.vim"
Searching for "/home/Dante/.vim/plugged/lightline.vim/autoload/coc/highlight.vim"
Searching for "/home/Dante/.vim/plugged/vim-tmux-navigator/autoload/coc/highlight.vim"
Searching for "/home/Dante/.vim/plugged/vimtex/autoload/coc/highlight.vim"
Searching for "/home/Dante/.vim/plugged/nerdtree/autoload/coc/highlight.vim"
Searching for "/home/Dante/.vim/plugged/fzf/autoload/coc/highlight.vim"
Searching for "/home/Dante/.vim/plugged/fzf.vim/autoload/coc/highlight.vim"
Searching for "/home/Dante/.vim/plugged/vim-wayland-clipboard/autoload/coc/highlight.vim"
Searching for "/home/Dante/.vim/plugged/coc.nvim/autoload/coc/highlight.vim"
chdir(/home/Dante/.vim/plugged/coc.nvim/autoload/coc)
fchdir() to previous dir
line 1: sourcing "/home/Dante/.vim/plugged/coc.nvim/autoload/coc/highlight.vim"
line 1: scriptencoding utf-8
line 2: let s:is_vim = !has('nvim')
line 3: let s:set_extmark = has('nvim') && exists('*nvim_buf_set_extmark')
line 4: let s:namespace_map = {}
line 5: let s:ns_id = 1
line 6: let s:diagnostic_hlgroups = ['CocErrorHighlight', 'CocWarningHighlight', 'CocInfoHighlight', 'CocHintHighlight', 'CocDeprecatedHighlight', 'CocUnusedHighlight']
line 7: " Maximum count to highlight each time.
line 8: let g:coc_highlight_maximum_count = get(g:, 'coc_highlight_maximum_count', 500)
line 9: let s:term = &termguicolors == 0 && !has('gui_running')
line 10: 
line 11: " Update buffer region by region.
line 12: function! coc#highlight#buffer_update(bufnr, key, highlights, ...) abort
line 34: 
line 35: " Update highlights by check exists highlights.
line 36: " 0 based, end exclusive start and end
line 37: function! coc#highlight#update_highlights(bufnr, key, highlights, ...) abort
line 131: 
line 132: " Get list of highlights by range or all buffer.
line 133: " 0 based line, start_col and end_col
line 134: " 0 based start & end line, end inclusive.
line 135: function! coc#highlight#get_highlights(bufnr, key, ...) abort
line 168: 
line 169: " Add multiple highlights to buffer.
line 170: " type HighlightItem = [hlGroup, lnum, colStart, colEnd, combine?, start_incl?, end_incl?]
line 171: function! coc#highlight#set(bufnr, key, highlights, priority) abort
line 187: 
line 188: " Clear highlights by 0 based line numbers.
line 189: function! coc#highlight#clear(bufnr, key, lnums) abort
line 207: 
line 208: function! coc#highlight#del_markers(bufnr, key, ids) abort
line 221: 
line 222: " highlight LSP range, opts contains 'combine' 'priority' 'start_incl' 'end_incl'
line 223: function! coc#highlight#ranges(bufnr, key, hlGroup, ranges, ...) abort
line 256: 
line 257: function! coc#highlight#add_highlight(bufnr, src_id, hl_group, line, col_start, col_end, ...) abort
line 284: 
line 285: function! coc#highlight#clear_highlight(bufnr, key, start_line, end_line) abort
line 297: 
line 298: " highlight buffer in winid with CodeBlock &HighlightItems
line 299: " export interface HighlightItem {
line 300: "   lnum: number // 0 based
line 301: "   hlGroup: string
line 302: "   colStart: number // 0 based
line 303: "   colEnd: number
line 304: " }
line 305: " export interface CodeBlock {
line 306: "   filetype?: string
line 307: "   hlGroup?: string
line 308: "   startLine: number // 0 based
line 309: "   endLine: number
line 310: " }
line 311: function! coc#highlight#add_highlights(winid, codes, highlights) abort
line 330: 
line 331: 
line 332: " Add highlights to line groups of winid, support hlGroup and filetype
line 333: " config should have startLine, endLine (0 based, end excluded) and filetype or hlGroup
line 334: " endLine should > startLine and endLine is excluded
line 335: "
line 336: " export interface CodeBlock {
line 337: "   filetype?: string
line 338: "   hlGroup?: string
line 339: "   startLine: number // 0 based
line 340: "   endLine: number
line 341: " }
line 342: function! coc#highlight#highlight_lines(winid, blocks) abort
line 371: 
line 372: function! coc#highlight#compose(fg, bg) abort
line 410: 
line 411: function! coc#highlight#valid(hlGroup) abort
line 414: 
line 415: " Compose hlGroups with foreground and background colors.
line 416: function! coc#highlight#compose_hlgroup(fgGroup, bgGroup) abort
line 431: 
line 432: " hlGroup id, key => 'fg' | 'bg', kind => 'cterm' | 'gui'
line 433: function! coc#highlight#get_color(id, key, kind) abort
line 439: 
line 440: function! coc#highlight#get_hl_command(id, key, cterm, gui) abort
line 447: 
line 448: function! coc#highlight#reversed(id) abort
line 455: 
line 456: function! coc#highlight#get_contrast(group1, group2) abort
line 462: 
line 463: " Darken or lighten background
line 464: function! coc#highlight#create_bg_command(group, amount) abort
line 476: 
line 477: function! coc#highlight#get_hex_color(id, kind, fallback) abort
line 486: 
line 487: function! s:check_ctermbg(id, cterm) abort
line 497: 
line 498: function! s:to_hex_color(color, term) abort
line 511: 
line 512: " add matches for winid, use 0 for current window.
line 513: function! coc#highlight#match_ranges(winid, bufnr, ranges, hlGroup, priority) abort
line 559: 
line 560: " Clear matches by hlGroup regexp.
line 561: function! coc#highlight#clear_match_group(winid, match) abort
line 572: 
line 573: " Clear matches by match ids, use 0 for current win.
line 574: function! coc#highlight#clear_matches(winid, ids)
line 588: 
line 589: function! coc#highlight#clear_all() abort
line 600: 
line 601: function! coc#highlight#create_namespace(key) abort
line 616: 
line 617: function! coc#highlight#get_syntax_name(lnum, col)
line 620: 
line 621: function! s:prop_type_hlgroup(type) abort
line 624: 
line 625: function! s:update_highlights_timer(bufnr, changedtick, key, priority, groups, idx) abort
line 642: 
line 643: function! s:add_highlights_timer(bufnr, ns, highlights, priority) abort
line 658: 
line 659: function! s:add_highlights(bufnr, ns, highlights, priority) abort
line 673: 
line 674: function! s:to_group(items) abort
line 687: 
line 688: function! s:get_priority(key, hlGroup, priority) abort
line 700: 
line 701: function! s:group_hls(hls, linecount) abort
finished sourcing /home/Dante/.vim/plugged/coc.nvim/autoload/coc/highlight.vim
continuing in <SNR>46_Highlight
calling coc#highlight#get_contrast('Normal', 'Pmenu')

line 1:   let normal = coc#highlight#get_hex_color(synIDtrans(hlID('Normal')), 'bg', '#000000')
calling coc#highlight#get_hex_color(61, 'bg', '#000000')

line 1:   let attr = coc#highlight#get_color(a:id, a:kind, s:term ? 'cterm' : 'gui')
calling coc#highlight#get_color(61, 'bg', 'gui')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning ''

continuing in coc#highlight#get_hex_color

line 2:   let hex = s:to_hex_color(attr, s:term)
calling <SNR>71_to_hex_color('', 0)

line 1:   if empty(a:color)
line 2:     return ''
<SNR>71_to_hex_color returning ''

continuing in coc#highlight#get_hex_color

line 3:   if empty(hex) && !s:term
line 4:     let attr = coc#highlight#get_color(a:id, a:kind, 'cterm')
calling coc#highlight#get_color(61, 'bg', 'cterm')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning ''

continuing in coc#highlight#get_hex_color

line 5:     let hex = s:to_hex_color(attr, 1)
calling <SNR>71_to_hex_color('', 1)

line 1:   if empty(a:color)
line 2:     return ''
<SNR>71_to_hex_color returning ''

continuing in coc#highlight#get_hex_color

line 6:   endif
line 7:   return empty(hex) ? a:fallback : hex
coc#highlight#get_hex_color returning '#000000'

continuing in coc#highlight#get_contrast

line 2:   let bg1 = coc#highlight#get_hex_color(synIDtrans(hlID(a:group1)), 'bg', normal)
calling coc#highlight#get_hex_color(61, 'bg', '#000000')

line 1:   let attr = coc#highlight#get_color(a:id, a:kind, s:term ? 'cterm' : 'gui')
calling coc#highlight#get_color(61, 'bg', 'gui')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning ''

continuing in coc#highlight#get_hex_color

line 2:   let hex = s:to_hex_color(attr, s:term)
calling <SNR>71_to_hex_color('', 0)

line 1:   if empty(a:color)
line 2:     return ''
<SNR>71_to_hex_color returning ''

continuing in coc#highlight#get_hex_color

line 3:   if empty(hex) && !s:term
line 4:     let attr = coc#highlight#get_color(a:id, a:kind, 'cterm')
calling coc#highlight#get_color(61, 'bg', 'cterm')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning ''

continuing in coc#highlight#get_hex_color

line 5:     let hex = s:to_hex_color(attr, 1)
calling <SNR>71_to_hex_color('', 1)

line 1:   if empty(a:color)
line 2:     return ''
<SNR>71_to_hex_color returning ''

continuing in coc#highlight#get_hex_color

line 6:   endif
line 7:   return empty(hex) ? a:fallback : hex
coc#highlight#get_hex_color returning '#000000'

continuing in coc#highlight#get_contrast

line 3:   let bg2 = coc#highlight#get_hex_color(synIDtrans(hlID(a:group2)), 'bg', normal)
calling coc#highlight#get_hex_color(38, 'bg', '#000000')

line 1:   let attr = coc#highlight#get_color(a:id, a:kind, s:term ? 'cterm' : 'gui')
calling coc#highlight#get_color(38, 'bg', 'gui')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning '#dcdfe4'

continuing in coc#highlight#get_hex_color

line 2:   let hex = s:to_hex_color(attr, s:term)
calling <SNR>71_to_hex_color('#dcdfe4', 0)

line 1:   if empty(a:color)
line 2:     return ''
line 3:   endif
line 4:   if a:color =~# '^#\x\+$'
line 5:     return a:color
<SNR>71_to_hex_color returning '#dcdfe4'

continuing in coc#highlight#get_hex_color

line 3:   if empty(hex) && !s:term
line 4:     let attr = coc#highlight#get_color(a:id, a:kind, 'cterm')
line 5:     let hex = s:to_hex_color(attr, 1)
line 6:   endif
line 7:   return empty(hex) ? a:fallback : hex
coc#highlight#get_hex_color returning '#dcdfe4'

continuing in coc#highlight#get_contrast

line 4:   return coc#color#hex_contrast(bg1, bg2)
Searching for "autoload/coc/color.vim" in "/home/Dante/.vim,/home/Dante/.vim/plugged/onedark.vim,/home/Dante/.vim/plugged/onehalf/vim,/home/Dante/.vim/plugged/gruvbox,/home/Dante/.vim/plugged/lightline.vim,/home/Dante/.vim/plugged/vim-tmux-navigator,/home/Dante/.vim/plugged/vimtex,/home/Dante/.vim/plugged/nerdtree,/home/Dante/.vim/plugged/fzf,/home/Dante/.vim/plugged/fzf.vim,/home/Dante/.vim/plugged/vim-wayland-clipboard,/home/Dante/.vim/plugged/coc.nvim,/home/Dante/.vim/plugged/vim-obsession,/usr/share/vim/vimfiles,/usr/share/vim/vim91,/usr/share/vim/vim91/pack/dist/opt/netrw,/usr/share/vim/vimfiles/after,/home/Dante/.vim/plugged/vimtex/after,/home/Dante/.vim/after"
Searching for "/home/Dante/.vim/autoload/coc/color.vim"
Searching for "/home/Dante/.vim/plugged/onedark.vim/autoload/coc/color.vim"
Searching for "/home/Dante/.vim/plugged/onehalf/vim/autoload/coc/color.vim"
Searching for "/home/Dante/.vim/plugged/gruvbox/autoload/coc/color.vim"
Searching for "/home/Dante/.vim/plugged/lightline.vim/autoload/coc/color.vim"
Searching for "/home/Dante/.vim/plugged/vim-tmux-navigator/autoload/coc/color.vim"
Searching for "/home/Dante/.vim/plugged/vimtex/autoload/coc/color.vim"
Searching for "/home/Dante/.vim/plugged/nerdtree/autoload/coc/color.vim"
Searching for "/home/Dante/.vim/plugged/fzf/autoload/coc/color.vim"
Searching for "/home/Dante/.vim/plugged/fzf.vim/autoload/coc/color.vim"
Searching for "/home/Dante/.vim/plugged/vim-wayland-clipboard/autoload/coc/color.vim"
Searching for "/home/Dante/.vim/plugged/coc.nvim/autoload/coc/color.vim"
chdir(/home/Dante/.vim/plugged/coc.nvim/autoload/coc)
fchdir() to previous dir
line 4: sourcing "/home/Dante/.vim/plugged/coc.nvim/autoload/coc/color.vim"
line 1: scriptencoding utf-8
line 2: 
line 3: let s:activate = ""
line 4: let s:quit = ""
line 5: if has("gui_macvim") && has('gui_running')
line 6:   let s:app = "MacVim"
line 7: elseif $TERM_PROGRAM ==# "Apple_Terminal"
line 8:   let s:app = "Terminal"
line 9: elseif $TERM_PROGRAM ==# "iTerm.app"
line 10:   let s:app = "iTerm2"
line 11: elseif has('mac')
line 12:   let s:app = "System Events"
line 13:   let s:quit = "quit"
line 14:   let s:activate = 'activate'
line 15: endif
line 16: 
line 17: let s:patterns = {}
line 18: let s:patterns['hex']      = '\v#?(\x{2})(\x{2})(\x{2})'
line 19: let s:patterns['shortHex'] = '\v#(\x{1})(\x{1})(\x{1})'
line 20: 
line 21: let s:xterm_colors = { '0':   '#000000', '1':   '#800000', '2':   '#008000', '3':   '#808000', '4':   '#000080', '5':   '#800080', '6':   '#008080', '7':   '#c0c0c0', '8':   '#808080', '9':   '#ff0000', '10':  '#00ff00', '11':  '#ffff00', '12':  '#0000ff', '13':  '#ff00ff', '14':  '#00ffff', '15':  '#ffffff', '16':  '#000000', '17':  '#00005f', '18':  '#000087', '19':  '#0000af', '20':  '#0000df', '21':  '#0000ff', '22':  '#005f00', '23':  '#005f5f', '24':  '#005f87', '25':  '#005faf', '26':  '#005fdf', '27':  '#005fff', '28':  '#008700', '29':  '#00875f', '30':  '#008787', '31':  '#0087af', '32':  '#0087df', '33':  '#0087ff', '34':  '#00af00', '35':  '#00af5f', '36':  '#00af87', '37':  '#00afaf', '38':  '#00afdf', '39':  '#00afff', '40':  '#00df00', '41':  '#00df5f', '42':  '#00df87', '43':  '#00dfaf', '44':  '#00dfdf', '45':  '#00dfff', '46':  '#00ff00', '47':  '#00ff5f', '48':  '#00ff87', '49':  '#00ffaf', '50':  '#00ffdf', '51':  '#00ffff', '52':  '#5f0000', '53':  '#5f005f', '54':  '#5f0087', '5
line 74: 
line 75: let s:xterm_16colors = { 'black':          '#000000', 'darkblue':       '#00008B', 'darkgreen':      '#00CD00', 'darkcyan':       '#00CDCD', 'darkred':        '#CD0000', 'darkmagenta':    '#8B008B', 'brown':          '#CDCD00', 'darkyellow':     '#CDCD00', 'lightgrey':      '#E5E5E5', 'lightgray':      '#E5E5E5', 'gray':           '#E5E5E5', 'grey':           '#E5E5E5', 'darkgrey':       '#7F7F7F', 'darkgray':       '#7F7F7F', 'blue':           '#5C5CFF', 'lightblue':      '#5C5CFF', 'green':          '#00FF00', 'lightgreen':     '#00FF00', 'cyan':           '#00FFFF', 'lightcyan':      '#00FFFF', 'red':            '#FF0000', 'lightred':       '#FF0000', 'magenta':        '#FF00FF', 'lightmagenta':   '#FF00FF', 'yellow':         '#FFFF00', 'lightyellow':    '#FFFF00', 'white':          '#FFFFFF', }
line 104: 
line 105: let s:w3c_color_names = { 'aliceblue': '#F0F8FF', 'antiquewhite': '#FAEBD7', 'aqua': '#00FFFF', 'aquamarine': '#7FFFD4', 'azure': '#F0FFFF', 'beige': '#F5F5DC', 'bisque': '#FFE4C4', 'black': '#000000', 'blanchedalmond': '#FFEBCD', 'blue': '#0000FF', 'blueviolet': '#8A2BE2', 'brown': '#A52A2A', 'burlywood': '#DEB887', 'cadetblue': '#5F9EA0', 'chartreuse': '#7FFF00', 'chocolate': '#D2691E', 'coral': '#FF7F50', 'cornflowerblue': '#6495ED', 'cornsilk': '#FFF8DC', 'crimson': '#DC143C', 'cyan': '#00FFFF', 'darkblue': '#00008B', 'darkcyan': '#008B8B', 'darkgoldenrod': '#B8860B', 'darkgray': '#A9A9A9', 'darkgreen': '#006400', 'darkkhaki': '#BDB76B', 'darkmagenta': '#8B008B', 'darkolivegreen': '#556B2F', 'darkorange': '#FF8C00', 'darkorchid': '#9932CC', 'darkred': '#8B0000', 'darksalmon': '#E9967A', 'darkseagreen': '#8FBC8F', 'darkslateblue': '#483D8B', 'darkslategray': '#2F4F4F', 'darkturquoise': '#00CED1', 'darkviolet': '#9400D3', 'deeppink': '#FF1493', 'deepskyblue': '#00BFFF', 'dimgray': '#696969', 'dodg
line 247: 
line 248: " Returns an approximate grey index for the given grey level
line 249: fun! s:grey_number(x)
line 286: 
line 287: " Returns the actual grey level represented by the grey index
line 288: fun! s:grey_level(n)
line 319: 
line 320: " Returns the palette index for the given grey index
line 321: fun! s:grey_colour(n)
line 340: 
line 341: " Returns an approximate colour index for the given colour level
line 342: fun! s:rgb_number(x)
line 367: 
line 368: " Returns the palette index for the given R/G/B colour indices
line 369: fun! s:rgb_colour(x, y, z)
line 376: 
line 377: " Returns the actual colour level for the given colour index
line 378: fun! s:rgb_level(n)
line 397: 
line 398: " Returns the palette index to approximate the given R/G/B colour levels
line 399: fun! s:colour(r, g, b)
line 432: 
line 433: function! coc#color#term2rgb(term) abort
line 439: 
line 440: function! coc#color#rgb2term(rgb)
line 446: 
line 447: function! coc#color#rgbToHex(...)
line 454: 
line 455: function! coc#color#hexToRgb(color)
line 478: 
line 479: function! coc#color#lighten(color, ...)
line 491: 
line 492: function! coc#color#darken(color, ...)
line 504: 
line 505: function! coc#color#luminance(rgb) abort
line 517: 
line 518: function! coc#color#contrast(rgb1, rgb2) abort
line 525: 
line 526: function! coc#color#hex_contrast(hex1, hex2) abort
line 529: 
line 530: function! coc#color#nameToHex(name, term) abort
line 536: 
line 537: " [r, g, b] ['255', '255', '255']
line 538: " return ['65535', '65535', '65535'] or return v:false to cancel
line 539: function! coc#color#pick_color(default_color)
finished sourcing /home/Dante/.vim/plugged/coc.nvim/autoload/coc/color.vim
continuing in coc#highlight#get_contrast
calling coc#color#hex_contrast('#000000', '#dcdfe4')

line 1:   return  coc#color#contrast(coc#color#hexToRgb(a:hex1), coc#color#hexToRgb(a:hex2))
calling coc#color#hexToRgb('#000000')

line 1:   if type(a:color) == 2
line 2:     let color = printf('%x', a:color)
line 3:   else
line 4:     let color = a:color
line 5:   end
line 6:   let matches = matchlist(color, s:patterns['hex'])
line 7:   let factor  = 0x1
line 8:   if empty(matches)
line 9:     let matches = matchlist(color, s:patterns['shortHex'])
line 10:     let factor  = 0x10
line 11:     end
line 12:     if len(matches) < 4
line 13:       echohl Error
line 14:       echom 'Couldnt parse ' . string(color) . ' ' .  string(matches)
line 15:       echohl None
line 16:       return
line 17:     end
line 18:     let r = str2nr(matches[1], 16) * factor
line 19:     let g = str2nr(matches[2], 16) * factor
line 20:     let b = str2nr(matches[3], 16) * factor
line 21:   return [r, g, b]
coc#color#hexToRgb returning [0, 0, 0]

continuing in coc#color#hex_contrast

calling coc#color#hexToRgb('#dcdfe4')

line 1:   if type(a:color) == 2
line 2:     let color = printf('%x', a:color)
line 3:   else
line 4:     let color = a:color
line 5:   end
line 6:   let matches = matchlist(color, s:patterns['hex'])
line 7:   let factor  = 0x1
line 8:   if empty(matches)
line 9:     let matches = matchlist(color, s:patterns['shortHex'])
line 10:     let factor  = 0x10
line 11:     end
line 12:     if len(matches) < 4
line 13:       echohl Error
line 14:       echom 'Couldnt parse ' . string(color) . ' ' .  string(matches)
line 15:       echohl None
line 16:       return
line 17:     end
line 18:     let r = str2nr(matches[1], 16) * factor
line 19:     let g = str2nr(matches[2], 16) * factor
line 20:     let b = str2nr(matches[3], 16) * factor
line 21:   return [r, g, b]
coc#color#hexToRgb returning [220, 223, 228]

continuing in coc#color#hex_contrast

calling coc#color#contrast([0, 0, 0], [220, 223, 228])

line 1:   let lnum1 = coc#color#luminance(a:rgb1)
calling coc#color#luminance([0, 0, 0])

line 1:   let vals = []
line 2:   for val in a:rgb
line 3:     let val = (val + 0.0)/255
line 4:     if val <= 0.03928
line 5:       call add(vals, val/12.92)
line 6:     else
line 7:       call add(vals, pow((val + 0.055)/1.055, 2.4))
line 8:     endif
line 9:   endfor
line 2:   for val in a:rgb
line 3:     let val = (val + 0.0)/255
line 4:     if val <= 0.03928
line 5:       call add(vals, val/12.92)
line 6:     else
line 7:       call add(vals, pow((val + 0.055)/1.055, 2.4))
line 8:     endif
line 9:   endfor
line 2:   for val in a:rgb
line 3:     let val = (val + 0.0)/255
line 4:     if val <= 0.03928
line 5:       call add(vals, val/12.92)
line 6:     else
line 7:       call add(vals, pow((val + 0.055)/1.055, 2.4))
line 8:     endif
line 9:   endfor
line 2:   for val in a:rgb
line 3:     let val = (val + 0.0)/255
line 4:     if val <= 0.03928
line 5:       call add(vals, val/12.92)
line 6:     else
line 7:       call add(vals, pow((val + 0.055)/1.055, 2.4))
line 8:     endif
line 9:   endfor
line 10:   return vals[0] * 0.2126 + vals[1] * 0.7152 + vals[2] * 0.0722
coc#color#luminance returning 0.0

continuing in coc#color#contrast

line 2:   let lnum2 = coc#color#luminance(a:rgb2)
calling coc#color#luminance([220, 223, 228])

line 1:   let vals = []
line 2:   for val in a:rgb
line 3:     let val = (val + 0.0)/255
line 4:     if val <= 0.03928
line 5:       call add(vals, val/12.92)
line 6:     else
line 7:       call add(vals, pow((val + 0.055)/1.055, 2.4))
line 8:     endif
line 9:   endfor
line 2:   for val in a:rgb
line 3:     let val = (val + 0.0)/255
line 4:     if val <= 0.03928
line 5:       call add(vals, val/12.92)
line 6:     else
line 7:       call add(vals, pow((val + 0.055)/1.055, 2.4))
line 8:     endif
line 9:   endfor
line 2:   for val in a:rgb
line 3:     let val = (val + 0.0)/255
line 4:     if val <= 0.03928
line 5:       call add(vals, val/12.92)
line 6:     else
line 7:       call add(vals, pow((val + 0.055)/1.055, 2.4))
line 8:     endif
line 9:   endfor
line 2:   for val in a:rgb
line 3:     let val = (val + 0.0)/255
line 4:     if val <= 0.03928
line 5:       call add(vals, val/12.92)
line 6:     else
line 7:       call add(vals, pow((val + 0.055)/1.055, 2.4))
line 8:     endif
line 9:   endfor
line 10:   return vals[0] * 0.2126 + vals[1] * 0.7152 + vals[2] * 0.0722
coc#color#luminance returning 0.735924

continuing in coc#color#contrast

line 3:   let brightest = lnum1 > lnum2 ? lnum1 : lnum2
line 4:   let darkest = lnum1 < lnum2 ? lnum1 : lnum2
line 5:   return (brightest + 0.05) / (darkest + 0.05)
coc#color#contrast returning 15.718487

continuing in coc#color#hex_contrast

coc#color#hex_contrast returning 15.718487

continuing in coc#highlight#get_contrast

coc#highlight#get_contrast returning 15.718487

continuing in <SNR>46_Highlight

line 2:     exe 'hi default CocFloating '.coc#highlight#create_bg_command('Normal', &background ==# 'dark' ? -30 : 30)
calling coc#highlight#create_bg_command('Normal', -30)

line 1:   let id = synIDtrans(hlID(a:group))
line 2:   let normal = coc#highlight#get_hex_color(synIDtrans(hlID('Normal')), 'bg', &background ==# 'dark' ? '#282828' : '#fefefe')
calling coc#highlight#get_hex_color(61, 'bg', '#282828')

line 1:   let attr = coc#highlight#get_color(a:id, a:kind, s:term ? 'cterm' : 'gui')
calling coc#highlight#get_color(61, 'bg', 'gui')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning ''

continuing in coc#highlight#get_hex_color

line 2:   let hex = s:to_hex_color(attr, s:term)
calling <SNR>71_to_hex_color('', 0)

line 1:   if empty(a:color)
line 2:     return ''
<SNR>71_to_hex_color returning ''

continuing in coc#highlight#get_hex_color

line 3:   if empty(hex) && !s:term
line 4:     let attr = coc#highlight#get_color(a:id, a:kind, 'cterm')
calling coc#highlight#get_color(61, 'bg', 'cterm')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning ''

continuing in coc#highlight#get_hex_color

line 5:     let hex = s:to_hex_color(attr, 1)
calling <SNR>71_to_hex_color('', 1)

line 1:   if empty(a:color)
line 2:     return ''
<SNR>71_to_hex_color returning ''

continuing in coc#highlight#get_hex_color

line 6:   endif
line 7:   return empty(hex) ? a:fallback : hex
coc#highlight#get_hex_color returning '#282828'

continuing in coc#highlight#create_bg_command

line 3:   let bg = coc#highlight#get_hex_color(id, 'bg', normal)
calling coc#highlight#get_hex_color(61, 'bg', '#282828')

line 1:   let attr = coc#highlight#get_color(a:id, a:kind, s:term ? 'cterm' : 'gui')
calling coc#highlight#get_color(61, 'bg', 'gui')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning ''

continuing in coc#highlight#get_hex_color

line 2:   let hex = s:to_hex_color(attr, s:term)
calling <SNR>71_to_hex_color('', 0)

line 1:   if empty(a:color)
line 2:     return ''
<SNR>71_to_hex_color returning ''

continuing in coc#highlight#get_hex_color

line 3:   if empty(hex) && !s:term
line 4:     let attr = coc#highlight#get_color(a:id, a:kind, 'cterm')
calling coc#highlight#get_color(61, 'bg', 'cterm')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning ''

continuing in coc#highlight#get_hex_color

line 5:     let hex = s:to_hex_color(attr, 1)
calling <SNR>71_to_hex_color('', 1)

line 1:   if empty(a:color)
line 2:     return ''
<SNR>71_to_hex_color returning ''

continuing in coc#highlight#get_hex_color

line 6:   endif
line 7:   return empty(hex) ? a:fallback : hex
coc#highlight#get_hex_color returning '#282828'

continuing in coc#highlight#create_bg_command

line 4:   let hex = a:amount > 0 ? coc#color#darken(bg, a:amount) : coc#color#lighten(bg, -a:amount)
calling coc#color#lighten('#282828', 30)

line 1:   let amount = a:0 ?(type(a:1) < 2 ?str2float(a:1) : a:1 ): 5
line 5:   let rgb = coc#color#hexToRgb(a:color)
calling coc#color#hexToRgb('#282828')

line 1:   if type(a:color) == 2
line 2:     let color = printf('%x', a:color)
line 3:   else
line 4:     let color = a:color
line 5:   end
line 6:   let matches = matchlist(color, s:patterns['hex'])
line 7:   let factor  = 0x1
line 8:   if empty(matches)
line 9:     let matches = matchlist(color, s:patterns['shortHex'])
line 10:     let factor  = 0x10
line 11:     end
line 12:     if len(matches) < 4
line 13:       echohl Error
line 14:       echom 'Couldnt parse ' . string(color) . ' ' .  string(matches)
line 15:       echohl None
line 16:       return
line 17:     end
line 18:     let r = str2nr(matches[1], 16) * factor
line 19:     let g = str2nr(matches[2], 16) * factor
line 20:     let b = str2nr(matches[3], 16) * factor
line 21:   return [r, g, b]
coc#color#hexToRgb returning [40, 40, 40]

continuing in coc#color#lighten

line 6:   let rgb = map(rgb, 'v:val + amount*(255 - v:val)/255')
line 7:   let rgb = map(rgb, 'v:val > 255.0 ? 255.0 : v:val')
line 8:   let rgb = map(rgb, 'float2nr(v:val)')
line 9:   let hex = coc#color#rgbToHex(rgb)
calling coc#color#rgbToHex([65, 65, 65])

line 1:   let [r, g, b] = ( a:0==1 ? a:1 : a:000 )
line 2:   let num = printf('%02x', float2nr(r)) . '' . printf('%02x', float2nr(g)) . '' . printf('%02x', float2nr(b)) . ''
line 5:   return '#' . num
coc#color#rgbToHex returning '#414141'

continuing in coc#color#lighten

line 10:   return hex
coc#color#lighten returning '#414141'

continuing in coc#highlight#create_bg_command

line 5: 
line 6:   let ctermbg = coc#color#rgb2term(strpart(hex, 1))
calling coc#color#rgb2term('414141')

line 1:   let l:r = ("0x" . strpart(a:rgb, 0, 2)) + 0
line 2:   let l:g = ("0x" . strpart(a:rgb, 2, 2)) + 0
line 3:   let l:b = ("0x" . strpart(a:rgb, 4, 2)) + 0
line 4:   return s:colour(l:r, l:g, l:b)
calling <SNR>72_colour(65, 65, 65)

line 1:   " Get the closest grey
line 2:   let l:gx = s:grey_number(a:r)
calling <SNR>72_grey_number(65)

line 1:   if &t_Co == 88
line 2:     if a:x < 23
line 3:       return 0
line 4:     elseif a:x < 69
line 5:       return 1
line 6:     elseif a:x < 103
line 7:       return 2
line 8:     elseif a:x < 127
line 9:       return 3
line 10:     elseif a:x < 150
line 11:       return 4
line 12:     elseif a:x < 173
line 13:       return 5
line 14:     elseif a:x < 196
line 15:       return 6
line 16:     elseif a:x < 219
line 17:       return 7
line 18:     elseif a:x < 243
line 19:       return 8
line 20:     else
line 21:       return 9
line 22:     endif
line 23:   else
line 24:     if a:x < 14
line 25:       return 0
line 26:     else
line 27:       let l:n = (a:x - 8) / 10
line 28:       let l:m = (a:x - 8) % 10
line 29:       if l:m < 5
line 30:         return l:n
line 31:       else
line 32:         return l:n + 1
<SNR>72_grey_number returning #6

continuing in <SNR>72_colour

line 3:   let l:gy = s:grey_number(a:g)
calling <SNR>72_grey_number(65)

line 1:   if &t_Co == 88
line 2:     if a:x < 23
line 3:       return 0
line 4:     elseif a:x < 69
line 5:       return 1
line 6:     elseif a:x < 103
line 7:       return 2
line 8:     elseif a:x < 127
line 9:       return 3
line 10:     elseif a:x < 150
line 11:       return 4
line 12:     elseif a:x < 173
line 13:       return 5
line 14:     elseif a:x < 196
line 15:       return 6
line 16:     elseif a:x < 219
line 17:       return 7
line 18:     elseif a:x < 243
line 19:       return 8
line 20:     else
line 21:       return 9
line 22:     endif
line 23:   else
line 24:     if a:x < 14
line 25:       return 0
line 26:     else
line 27:       let l:n = (a:x - 8) / 10
line 28:       let l:m = (a:x - 8) % 10
line 29:       if l:m < 5
line 30:         return l:n
line 31:       else
line 32:         return l:n + 1
<SNR>72_grey_number returning #6

continuing in <SNR>72_colour

line 4:   let l:gz = s:grey_number(a:b)
calling <SNR>72_grey_number(65)

line 1:   if &t_Co == 88
line 2:     if a:x < 23
line 3:       return 0
line 4:     elseif a:x < 69
line 5:       return 1
line 6:     elseif a:x < 103
line 7:       return 2
line 8:     elseif a:x < 127
line 9:       return 3
line 10:     elseif a:x < 150
line 11:       return 4
line 12:     elseif a:x < 173
line 13:       return 5
line 14:     elseif a:x < 196
line 15:       return 6
line 16:     elseif a:x < 219
line 17:       return 7
line 18:     elseif a:x < 243
line 19:       return 8
line 20:     else
line 21:       return 9
line 22:     endif
line 23:   else
line 24:     if a:x < 14
line 25:       return 0
line 26:     else
line 27:       let l:n = (a:x - 8) / 10
line 28:       let l:m = (a:x - 8) % 10
line 29:       if l:m < 5
line 30:         return l:n
line 31:       else
line 32:         return l:n + 1
<SNR>72_grey_number returning #6

continuing in <SNR>72_colour

line 5: 
line 6:   " Get the closest colour
line 7:   let l:x = s:rgb_number(a:r)
calling <SNR>72_rgb_number(65)

line 1:   if &t_Co == 88
line 2:     if a:x < 69
line 3:       return 0
line 4:     elseif a:x < 172
line 5:       return 1
line 6:     elseif a:x < 230
line 7:       return 2
line 8:     else
line 9:       return 3
line 10:     endif
line 11:   else
line 12:     if a:x < 75
line 13:       return 0
<SNR>72_rgb_number returning #0

continuing in <SNR>72_colour

line 8:   let l:y = s:rgb_number(a:g)
calling <SNR>72_rgb_number(65)

line 1:   if &t_Co == 88
line 2:     if a:x < 69
line 3:       return 0
line 4:     elseif a:x < 172
line 5:       return 1
line 6:     elseif a:x < 230
line 7:       return 2
line 8:     else
line 9:       return 3
line 10:     endif
line 11:   else
line 12:     if a:x < 75
line 13:       return 0
<SNR>72_rgb_number returning #0

continuing in <SNR>72_colour

line 9:   let l:z = s:rgb_number(a:b)
calling <SNR>72_rgb_number(65)

line 1:   if &t_Co == 88
line 2:     if a:x < 69
line 3:       return 0
line 4:     elseif a:x < 172
line 5:       return 1
line 6:     elseif a:x < 230
line 7:       return 2
line 8:     else
line 9:       return 3
line 10:     endif
line 11:   else
line 12:     if a:x < 75
line 13:       return 0
<SNR>72_rgb_number returning #0

continuing in <SNR>72_colour

line 10: 
line 11:   if l:gx == l:gy && l:gy == l:gz
line 12:     " There are two possibilities
line 13:     let l:dgr = s:grey_level(l:gx) - a:r
calling <SNR>72_grey_level(6)

line 1:   if &t_Co == 88
line 2:     if a:n == 0
line 3:       return 0
line 4:     elseif a:n == 1
line 5:       return 46
line 6:     elseif a:n == 2
line 7:       return 92
line 8:     elseif a:n == 3
line 9:       return 115
line 10:     elseif a:n == 4
line 11:       return 139
line 12:     elseif a:n == 5
line 13:       return 162
line 14:     elseif a:n == 6
line 15:       return 185
line 16:     elseif a:n == 7
line 17:       return 208
line 18:     elseif a:n == 8
line 19:       return 231
line 20:     else
line 21:       return 255
line 22:     endif
line 23:   else
line 24:     if a:n == 0
line 25:       return 0
line 26:     else
line 27:       return 8 + (a:n * 10)
<SNR>72_grey_level returning #68

continuing in <SNR>72_colour

line 14:     let l:dgg = s:grey_level(l:gy) - a:g
calling <SNR>72_grey_level(6)

line 1:   if &t_Co == 88
line 2:     if a:n == 0
line 3:       return 0
line 4:     elseif a:n == 1
line 5:       return 46
line 6:     elseif a:n == 2
line 7:       return 92
line 8:     elseif a:n == 3
line 9:       return 115
line 10:     elseif a:n == 4
line 11:       return 139
line 12:     elseif a:n == 5
line 13:       return 162
line 14:     elseif a:n == 6
line 15:       return 185
line 16:     elseif a:n == 7
line 17:       return 208
line 18:     elseif a:n == 8
line 19:       return 231
line 20:     else
line 21:       return 255
line 22:     endif
line 23:   else
line 24:     if a:n == 0
line 25:       return 0
line 26:     else
line 27:       return 8 + (a:n * 10)
<SNR>72_grey_level returning #68

continuing in <SNR>72_colour

line 15:     let l:dgb = s:grey_level(l:gz) - a:b
calling <SNR>72_grey_level(6)

line 1:   if &t_Co == 88
line 2:     if a:n == 0
line 3:       return 0
line 4:     elseif a:n == 1
line 5:       return 46
line 6:     elseif a:n == 2
line 7:       return 92
line 8:     elseif a:n == 3
line 9:       return 115
line 10:     elseif a:n == 4
line 11:       return 139
line 12:     elseif a:n == 5
line 13:       return 162
line 14:     elseif a:n == 6
line 15:       return 185
line 16:     elseif a:n == 7
line 17:       return 208
line 18:     elseif a:n == 8
line 19:       return 231
line 20:     else
line 21:       return 255
line 22:     endif
line 23:   else
line 24:     if a:n == 0
line 25:       return 0
line 26:     else
line 27:       return 8 + (a:n * 10)
<SNR>72_grey_level returning #68

continuing in <SNR>72_colour

line 16:     let l:dgrey = (l:dgr * l:dgr) + (l:dgg * l:dgg) + (l:dgb * l:dgb)
line 17:     let l:dr = s:rgb_level(l:gx) - a:r
calling <SNR>72_rgb_level(6)

line 1:   if &t_Co == 88
line 2:     if a:n == 0
line 3:       return 0
line 4:     elseif a:n == 1
line 5:       return 139
line 6:     elseif a:n == 2
line 7:       return 205
line 8:     else
line 9:       return 255
line 10:     endif
line 11:   else
line 12:     if a:n == 0
line 13:       return 0
line 14:     else
line 15:       return 55 + (a:n * 40)
<SNR>72_rgb_level returning #295

continuing in <SNR>72_colour

line 18:     let l:dg = s:rgb_level(l:gy) - a:g
calling <SNR>72_rgb_level(6)

line 1:   if &t_Co == 88
line 2:     if a:n == 0
line 3:       return 0
line 4:     elseif a:n == 1
line 5:       return 139
line 6:     elseif a:n == 2
line 7:       return 205
line 8:     else
line 9:       return 255
line 10:     endif
line 11:   else
line 12:     if a:n == 0
line 13:       return 0
line 14:     else
line 15:       return 55 + (a:n * 40)
<SNR>72_rgb_level returning #295

continuing in <SNR>72_colour

line 19:     let l:db = s:rgb_level(l:gz) - a:b
calling <SNR>72_rgb_level(6)

line 1:   if &t_Co == 88
line 2:     if a:n == 0
line 3:       return 0
line 4:     elseif a:n == 1
line 5:       return 139
line 6:     elseif a:n == 2
line 7:       return 205
line 8:     else
line 9:       return 255
line 10:     endif
line 11:   else
line 12:     if a:n == 0
line 13:       return 0
line 14:     else
line 15:       return 55 + (a:n * 40)
<SNR>72_rgb_level returning #295

continuing in <SNR>72_colour

line 20:     let l:drgb = (l:dr * l:dr) + (l:dg * l:dg) + (l:db * l:db)
line 21:     if l:dgrey < l:drgb
line 22:       " Use the grey
line 23:       return s:grey_colour(l:gx)
calling <SNR>72_grey_colour(6)

line 1:   if &t_Co == 88
line 2:     if a:n == 0
line 3:       return 16
line 4:     elseif a:n == 9
line 5:       return 79
line 6:     else
line 7:       return 79 + a:n
line 8:     endif
line 9:   else
line 10:     if a:n == 0
line 11:       return 16
line 12:     elseif a:n == 25
line 13:       return 231
line 14:     else
line 15:       return 231 + a:n
<SNR>72_grey_colour returning #237

continuing in <SNR>72_colour

<SNR>72_colour returning #237

continuing in coc#color#rgb2term

coc#color#rgb2term returning #237

continuing in coc#highlight#create_bg_command

line 7:   if s:term && !s:check_ctermbg(id, ctermbg) && abs(a:amount) < 20.0
line 8:     return coc#highlight#create_bg_command(a:group, a:amount * 2)
line 9:   endif
line 10:   return 'ctermbg=' . ctermbg.' guibg=' . hex
coc#highlight#create_bg_command returning 'ctermbg=237 guibg=#414141'

continuing in <SNR>46_Highlight

line 2: hi default CocFloating ctermbg=237 guibg=#414141
line 3:     exe 'hi default CocMenuSel '.coc#highlight#create_bg_command('CocFloating', &background ==# 'dark' ? -20 : 20)
calling coc#highlight#create_bg_command('CocFloating', -20)

line 1:   let id = synIDtrans(hlID(a:group))
line 2:   let normal = coc#highlight#get_hex_color(synIDtrans(hlID('Normal')), 'bg', &background ==# 'dark' ? '#282828' : '#fefefe')
calling coc#highlight#get_hex_color(61, 'bg', '#282828')

line 1:   let attr = coc#highlight#get_color(a:id, a:kind, s:term ? 'cterm' : 'gui')
calling coc#highlight#get_color(61, 'bg', 'gui')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning ''

continuing in coc#highlight#get_hex_color

line 2:   let hex = s:to_hex_color(attr, s:term)
calling <SNR>71_to_hex_color('', 0)

line 1:   if empty(a:color)
line 2:     return ''
<SNR>71_to_hex_color returning ''

continuing in coc#highlight#get_hex_color

line 3:   if empty(hex) && !s:term
line 4:     let attr = coc#highlight#get_color(a:id, a:kind, 'cterm')
calling coc#highlight#get_color(61, 'bg', 'cterm')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning ''

continuing in coc#highlight#get_hex_color

line 5:     let hex = s:to_hex_color(attr, 1)
calling <SNR>71_to_hex_color('', 1)

line 1:   if empty(a:color)
line 2:     return ''
<SNR>71_to_hex_color returning ''

continuing in coc#highlight#get_hex_color

line 6:   endif
line 7:   return empty(hex) ? a:fallback : hex
coc#highlight#get_hex_color returning '#282828'

continuing in coc#highlight#create_bg_command

line 3:   let bg = coc#highlight#get_hex_color(id, 'bg', normal)
calling coc#highlight#get_hex_color(174, 'bg', '#282828')

line 1:   let attr = coc#highlight#get_color(a:id, a:kind, s:term ? 'cterm' : 'gui')
calling coc#highlight#get_color(174, 'bg', 'gui')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning '#414141'

continuing in coc#highlight#get_hex_color

line 2:   let hex = s:to_hex_color(attr, s:term)
calling <SNR>71_to_hex_color('#414141', 0)

line 1:   if empty(a:color)
line 2:     return ''
line 3:   endif
line 4:   if a:color =~# '^#\x\+$'
line 5:     return a:color
<SNR>71_to_hex_color returning '#414141'

continuing in coc#highlight#get_hex_color

line 3:   if empty(hex) && !s:term
line 4:     let attr = coc#highlight#get_color(a:id, a:kind, 'cterm')
line 5:     let hex = s:to_hex_color(attr, 1)
line 6:   endif
line 7:   return empty(hex) ? a:fallback : hex
coc#highlight#get_hex_color returning '#414141'

continuing in coc#highlight#create_bg_command

line 4:   let hex = a:amount > 0 ? coc#color#darken(bg, a:amount) : coc#color#lighten(bg, -a:amount)
calling coc#color#lighten('#414141', 20)

line 1:   let amount = a:0 ?(type(a:1) < 2 ?str2float(a:1) : a:1 ): 5
line 5:   let rgb = coc#color#hexToRgb(a:color)
calling coc#color#hexToRgb('#414141')

line 1:   if type(a:color) == 2
line 2:     let color = printf('%x', a:color)
line 3:   else
line 4:     let color = a:color
line 5:   end
line 6:   let matches = matchlist(color, s:patterns['hex'])
line 7:   let factor  = 0x1
line 8:   if empty(matches)
line 9:     let matches = matchlist(color, s:patterns['shortHex'])
line 10:     let factor  = 0x10
line 11:     end
line 12:     if len(matches) < 4
line 13:       echohl Error
line 14:       echom 'Couldnt parse ' . string(color) . ' ' .  string(matches)
line 15:       echohl None
line 16:       return
line 17:     end
line 18:     let r = str2nr(matches[1], 16) * factor
line 19:     let g = str2nr(matches[2], 16) * factor
line 20:     let b = str2nr(matches[3], 16) * factor
line 21:   return [r, g, b]
coc#color#hexToRgb returning [65, 65, 65]

continuing in coc#color#lighten

line 6:   let rgb = map(rgb, 'v:val + amount*(255 - v:val)/255')
line 7:   let rgb = map(rgb, 'v:val > 255.0 ? 255.0 : v:val')
line 8:   let rgb = map(rgb, 'float2nr(v:val)')
line 9:   let hex = coc#color#rgbToHex(rgb)
calling coc#color#rgbToHex([79, 79, 79])

line 1:   let [r, g, b] = ( a:0==1 ? a:1 : a:000 )
line 2:   let num = printf('%02x', float2nr(r)) . '' . printf('%02x', float2nr(g)) . '' . printf('%02x', float2nr(b)) . ''
line 5:   return '#' . num
coc#color#rgbToHex returning '#4f4f4f'

continuing in coc#color#lighten

line 10:   return hex
coc#color#lighten returning '#4f4f4f'

continuing in coc#highlight#create_bg_command

line 5: 
line 6:   let ctermbg = coc#color#rgb2term(strpart(hex, 1))
calling coc#color#rgb2term('4f4f4f')

line 1:   let l:r = ("0x" . strpart(a:rgb, 0, 2)) + 0
line 2:   let l:g = ("0x" . strpart(a:rgb, 2, 2)) + 0
line 3:   let l:b = ("0x" . strpart(a:rgb, 4, 2)) + 0
line 4:   return s:colour(l:r, l:g, l:b)
calling <SNR>72_colour(79, 79, 79)

line 1:   " Get the closest grey
line 2:   let l:gx = s:grey_number(a:r)
calling <SNR>72_grey_number(79)

line 1:   if &t_Co == 88
line 2:     if a:x < 23
line 3:       return 0
line 4:     elseif a:x < 69
line 5:       return 1
line 6:     elseif a:x < 103
line 7:       return 2
line 8:     elseif a:x < 127
line 9:       return 3
line 10:     elseif a:x < 150
line 11:       return 4
line 12:     elseif a:x < 173
line 13:       return 5
line 14:     elseif a:x < 196
line 15:       return 6
line 16:     elseif a:x < 219
line 17:       return 7
line 18:     elseif a:x < 243
line 19:       return 8
line 20:     else
line 21:       return 9
line 22:     endif
line 23:   else
line 24:     if a:x < 14
line 25:       return 0
line 26:     else
line 27:       let l:n = (a:x - 8) / 10
line 28:       let l:m = (a:x - 8) % 10
line 29:       if l:m < 5
line 30:         return l:n
<SNR>72_grey_number returning #7

continuing in <SNR>72_colour

line 3:   let l:gy = s:grey_number(a:g)
calling <SNR>72_grey_number(79)

line 1:   if &t_Co == 88
line 2:     if a:x < 23
line 3:       return 0
line 4:     elseif a:x < 69
line 5:       return 1
line 6:     elseif a:x < 103
line 7:       return 2
line 8:     elseif a:x < 127
line 9:       return 3
line 10:     elseif a:x < 150
line 11:       return 4
line 12:     elseif a:x < 173
line 13:       return 5
line 14:     elseif a:x < 196
line 15:       return 6
line 16:     elseif a:x < 219
line 17:       return 7
line 18:     elseif a:x < 243
line 19:       return 8
line 20:     else
line 21:       return 9
line 22:     endif
line 23:   else
line 24:     if a:x < 14
line 25:       return 0
line 26:     else
line 27:       let l:n = (a:x - 8) / 10
line 28:       let l:m = (a:x - 8) % 10
line 29:       if l:m < 5
line 30:         return l:n
<SNR>72_grey_number returning #7

continuing in <SNR>72_colour

line 4:   let l:gz = s:grey_number(a:b)
calling <SNR>72_grey_number(79)

line 1:   if &t_Co == 88
line 2:     if a:x < 23
line 3:       return 0
line 4:     elseif a:x < 69
line 5:       return 1
line 6:     elseif a:x < 103
line 7:       return 2
line 8:     elseif a:x < 127
line 9:       return 3
line 10:     elseif a:x < 150
line 11:       return 4
line 12:     elseif a:x < 173
line 13:       return 5
line 14:     elseif a:x < 196
line 15:       return 6
line 16:     elseif a:x < 219
line 17:       return 7
line 18:     elseif a:x < 243
line 19:       return 8
line 20:     else
line 21:       return 9
line 22:     endif
line 23:   else
line 24:     if a:x < 14
line 25:       return 0
line 26:     else
line 27:       let l:n = (a:x - 8) / 10
line 28:       let l:m = (a:x - 8) % 10
line 29:       if l:m < 5
line 30:         return l:n
<SNR>72_grey_number returning #7

continuing in <SNR>72_colour

line 5: 
line 6:   " Get the closest colour
line 7:   let l:x = s:rgb_number(a:r)
calling <SNR>72_rgb_number(79)

line 1:   if &t_Co == 88
line 2:     if a:x < 69
line 3:       return 0
line 4:     elseif a:x < 172
line 5:       return 1
line 6:     elseif a:x < 230
line 7:       return 2
line 8:     else
line 9:       return 3
line 10:     endif
line 11:   else
line 12:     if a:x < 75
line 13:       return 0
line 14:     else
line 15:       let l:n = (a:x - 55) / 40
line 16:       let l:m = (a:x - 55) % 40
line 17:       if l:m < 20
line 18:         return l:n
line 19:       else
line 20:         return l:n + 1
<SNR>72_rgb_number returning #1

continuing in <SNR>72_colour

line 8:   let l:y = s:rgb_number(a:g)
calling <SNR>72_rgb_number(79)

line 1:   if &t_Co == 88
line 2:     if a:x < 69
line 3:       return 0
line 4:     elseif a:x < 172
line 5:       return 1
line 6:     elseif a:x < 230
line 7:       return 2
line 8:     else
line 9:       return 3
line 10:     endif
line 11:   else
line 12:     if a:x < 75
line 13:       return 0
line 14:     else
line 15:       let l:n = (a:x - 55) / 40
line 16:       let l:m = (a:x - 55) % 40
line 17:       if l:m < 20
line 18:         return l:n
line 19:       else
line 20:         return l:n + 1
<SNR>72_rgb_number returning #1

continuing in <SNR>72_colour

line 9:   let l:z = s:rgb_number(a:b)
calling <SNR>72_rgb_number(79)

line 1:   if &t_Co == 88
line 2:     if a:x < 69
line 3:       return 0
line 4:     elseif a:x < 172
line 5:       return 1
line 6:     elseif a:x < 230
line 7:       return 2
line 8:     else
line 9:       return 3
line 10:     endif
line 11:   else
line 12:     if a:x < 75
line 13:       return 0
line 14:     else
line 15:       let l:n = (a:x - 55) / 40
line 16:       let l:m = (a:x - 55) % 40
line 17:       if l:m < 20
line 18:         return l:n
line 19:       else
line 20:         return l:n + 1
<SNR>72_rgb_number returning #1

continuing in <SNR>72_colour

line 10: 
line 11:   if l:gx == l:gy && l:gy == l:gz
line 12:     " There are two possibilities
line 13:     let l:dgr = s:grey_level(l:gx) - a:r
calling <SNR>72_grey_level(7)

line 1:   if &t_Co == 88
line 2:     if a:n == 0
line 3:       return 0
line 4:     elseif a:n == 1
line 5:       return 46
line 6:     elseif a:n == 2
line 7:       return 92
line 8:     elseif a:n == 3
line 9:       return 115
line 10:     elseif a:n == 4
line 11:       return 139
line 12:     elseif a:n == 5
line 13:       return 162
line 14:     elseif a:n == 6
line 15:       return 185
line 16:     elseif a:n == 7
line 17:       return 208
line 18:     elseif a:n == 8
line 19:       return 231
line 20:     else
line 21:       return 255
line 22:     endif
line 23:   else
line 24:     if a:n == 0
line 25:       return 0
line 26:     else
line 27:       return 8 + (a:n * 10)
<SNR>72_grey_level returning #78

continuing in <SNR>72_colour

line 14:     let l:dgg = s:grey_level(l:gy) - a:g
calling <SNR>72_grey_level(7)

line 1:   if &t_Co == 88
line 2:     if a:n == 0
line 3:       return 0
line 4:     elseif a:n == 1
line 5:       return 46
line 6:     elseif a:n == 2
line 7:       return 92
line 8:     elseif a:n == 3
line 9:       return 115
line 10:     elseif a:n == 4
line 11:       return 139
line 12:     elseif a:n == 5
line 13:       return 162
line 14:     elseif a:n == 6
line 15:       return 185
line 16:     elseif a:n == 7
line 17:       return 208
line 18:     elseif a:n == 8
line 19:       return 231
line 20:     else
line 21:       return 255
line 22:     endif
line 23:   else
line 24:     if a:n == 0
line 25:       return 0
line 26:     else
line 27:       return 8 + (a:n * 10)
<SNR>72_grey_level returning #78

continuing in <SNR>72_colour

line 15:     let l:dgb = s:grey_level(l:gz) - a:b
calling <SNR>72_grey_level(7)

line 1:   if &t_Co == 88
line 2:     if a:n == 0
line 3:       return 0
line 4:     elseif a:n == 1
line 5:       return 46
line 6:     elseif a:n == 2
line 7:       return 92
line 8:     elseif a:n == 3
line 9:       return 115
line 10:     elseif a:n == 4
line 11:       return 139
line 12:     elseif a:n == 5
line 13:       return 162
line 14:     elseif a:n == 6
line 15:       return 185
line 16:     elseif a:n == 7
line 17:       return 208
line 18:     elseif a:n == 8
line 19:       return 231
line 20:     else
line 21:       return 255
line 22:     endif
line 23:   else
line 24:     if a:n == 0
line 25:       return 0
line 26:     else
line 27:       return 8 + (a:n * 10)
<SNR>72_grey_level returning #78

continuing in <SNR>72_colour

line 16:     let l:dgrey = (l:dgr * l:dgr) + (l:dgg * l:dgg) + (l:dgb * l:dgb)
line 17:     let l:dr = s:rgb_level(l:gx) - a:r
calling <SNR>72_rgb_level(7)

line 1:   if &t_Co == 88
line 2:     if a:n == 0
line 3:       return 0
line 4:     elseif a:n == 1
line 5:       return 139
line 6:     elseif a:n == 2
line 7:       return 205
line 8:     else
line 9:       return 255
line 10:     endif
line 11:   else
line 12:     if a:n == 0
line 13:       return 0
line 14:     else
line 15:       return 55 + (a:n * 40)
<SNR>72_rgb_level returning #335

continuing in <SNR>72_colour

line 18:     let l:dg = s:rgb_level(l:gy) - a:g
calling <SNR>72_rgb_level(7)

line 1:   if &t_Co == 88
line 2:     if a:n == 0
line 3:       return 0
line 4:     elseif a:n == 1
line 5:       return 139
line 6:     elseif a:n == 2
line 7:       return 205
line 8:     else
line 9:       return 255
line 10:     endif
line 11:   else
line 12:     if a:n == 0
line 13:       return 0
line 14:     else
line 15:       return 55 + (a:n * 40)
<SNR>72_rgb_level returning #335

continuing in <SNR>72_colour

line 19:     let l:db = s:rgb_level(l:gz) - a:b
calling <SNR>72_rgb_level(7)

line 1:   if &t_Co == 88
line 2:     if a:n == 0
line 3:       return 0
line 4:     elseif a:n == 1
line 5:       return 139
line 6:     elseif a:n == 2
line 7:       return 205
line 8:     else
line 9:       return 255
line 10:     endif
line 11:   else
line 12:     if a:n == 0
line 13:       return 0
line 14:     else
line 15:       return 55 + (a:n * 40)
<SNR>72_rgb_level returning #335

continuing in <SNR>72_colour

line 20:     let l:drgb = (l:dr * l:dr) + (l:dg * l:dg) + (l:db * l:db)
line 21:     if l:dgrey < l:drgb
line 22:       " Use the grey
line 23:       return s:grey_colour(l:gx)
calling <SNR>72_grey_colour(7)

line 1:   if &t_Co == 88
line 2:     if a:n == 0
line 3:       return 16
line 4:     elseif a:n == 9
line 5:       return 79
line 6:     else
line 7:       return 79 + a:n
line 8:     endif
line 9:   else
line 10:     if a:n == 0
line 11:       return 16
line 12:     elseif a:n == 25
line 13:       return 231
line 14:     else
line 15:       return 231 + a:n
<SNR>72_grey_colour returning #238

continuing in <SNR>72_colour

<SNR>72_colour returning #238

continuing in coc#color#rgb2term

coc#color#rgb2term returning #238

continuing in coc#highlight#create_bg_command

line 7:   if s:term && !s:check_ctermbg(id, ctermbg) && abs(a:amount) < 20.0
line 8:     return coc#highlight#create_bg_command(a:group, a:amount * 2)
line 9:   endif
line 10:   return 'ctermbg=' . ctermbg.' guibg=' . hex
coc#highlight#create_bg_command returning 'ctermbg=238 guibg=#4f4f4f'

continuing in <SNR>46_Highlight

line 3: hi default CocMenuSel ctermbg=238 guibg=#4f4f4f
line 4:     exe 'hi default CocFloatThumb '.coc#highlight#create_bg_command('CocFloating', &background ==# 'dark' ? -40 : 40)
calling coc#highlight#create_bg_command('CocFloating', -40)

line 1:   let id = synIDtrans(hlID(a:group))
line 2:   let normal = coc#highlight#get_hex_color(synIDtrans(hlID('Normal')), 'bg', &background ==# 'dark' ? '#282828' : '#fefefe')
calling coc#highlight#get_hex_color(61, 'bg', '#282828')

line 1:   let attr = coc#highlight#get_color(a:id, a:kind, s:term ? 'cterm' : 'gui')
calling coc#highlight#get_color(61, 'bg', 'gui')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning ''

continuing in coc#highlight#get_hex_color

line 2:   let hex = s:to_hex_color(attr, s:term)
calling <SNR>71_to_hex_color('', 0)

line 1:   if empty(a:color)
line 2:     return ''
<SNR>71_to_hex_color returning ''

continuing in coc#highlight#get_hex_color

line 3:   if empty(hex) && !s:term
line 4:     let attr = coc#highlight#get_color(a:id, a:kind, 'cterm')
calling coc#highlight#get_color(61, 'bg', 'cterm')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning ''

continuing in coc#highlight#get_hex_color

line 5:     let hex = s:to_hex_color(attr, 1)
calling <SNR>71_to_hex_color('', 1)

line 1:   if empty(a:color)
line 2:     return ''
<SNR>71_to_hex_color returning ''

continuing in coc#highlight#get_hex_color

line 6:   endif
line 7:   return empty(hex) ? a:fallback : hex
coc#highlight#get_hex_color returning '#282828'

continuing in coc#highlight#create_bg_command

line 3:   let bg = coc#highlight#get_hex_color(id, 'bg', normal)
calling coc#highlight#get_hex_color(174, 'bg', '#282828')

line 1:   let attr = coc#highlight#get_color(a:id, a:kind, s:term ? 'cterm' : 'gui')
calling coc#highlight#get_color(174, 'bg', 'gui')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning '#414141'

continuing in coc#highlight#get_hex_color

line 2:   let hex = s:to_hex_color(attr, s:term)
calling <SNR>71_to_hex_color('#414141', 0)

line 1:   if empty(a:color)
line 2:     return ''
line 3:   endif
line 4:   if a:color =~# '^#\x\+$'
line 5:     return a:color
<SNR>71_to_hex_color returning '#414141'

continuing in coc#highlight#get_hex_color

line 3:   if empty(hex) && !s:term
line 4:     let attr = coc#highlight#get_color(a:id, a:kind, 'cterm')
line 5:     let hex = s:to_hex_color(attr, 1)
line 6:   endif
line 7:   return empty(hex) ? a:fallback : hex
coc#highlight#get_hex_color returning '#414141'

continuing in coc#highlight#create_bg_command

line 4:   let hex = a:amount > 0 ? coc#color#darken(bg, a:amount) : coc#color#lighten(bg, -a:amount)
calling coc#color#lighten('#414141', 40)

line 1:   let amount = a:0 ?(type(a:1) < 2 ?str2float(a:1) : a:1 ): 5
line 5:   let rgb = coc#color#hexToRgb(a:color)
calling coc#color#hexToRgb('#414141')

line 1:   if type(a:color) == 2
line 2:     let color = printf('%x', a:color)
line 3:   else
line 4:     let color = a:color
line 5:   end
line 6:   let matches = matchlist(color, s:patterns['hex'])
line 7:   let factor  = 0x1
line 8:   if empty(matches)
line 9:     let matches = matchlist(color, s:patterns['shortHex'])
line 10:     let factor  = 0x10
line 11:     end
line 12:     if len(matches) < 4
line 13:       echohl Error
line 14:       echom 'Couldnt parse ' . string(color) . ' ' .  string(matches)
line 15:       echohl None
line 16:       return
line 17:     end
line 18:     let r = str2nr(matches[1], 16) * factor
line 19:     let g = str2nr(matches[2], 16) * factor
line 20:     let b = str2nr(matches[3], 16) * factor
line 21:   return [r, g, b]
coc#color#hexToRgb returning [65, 65, 65]

continuing in coc#color#lighten

line 6:   let rgb = map(rgb, 'v:val + amount*(255 - v:val)/255')
line 7:   let rgb = map(rgb, 'v:val > 255.0 ? 255.0 : v:val')
line 8:   let rgb = map(rgb, 'float2nr(v:val)')
line 9:   let hex = coc#color#rgbToHex(rgb)
calling coc#color#rgbToHex([94, 94, 94])

line 1:   let [r, g, b] = ( a:0==1 ? a:1 : a:000 )
line 2:   let num = printf('%02x', float2nr(r)) . '' . printf('%02x', float2nr(g)) . '' . printf('%02x', float2nr(b)) . ''
line 5:   return '#' . num
coc#color#rgbToHex returning '#5e5e5e'

continuing in coc#color#lighten

line 10:   return hex
coc#color#lighten returning '#5e5e5e'

continuing in coc#highlight#create_bg_command

line 5: 
line 6:   let ctermbg = coc#color#rgb2term(strpart(hex, 1))
calling coc#color#rgb2term('5e5e5e')

line 1:   let l:r = ("0x" . strpart(a:rgb, 0, 2)) + 0
line 2:   let l:g = ("0x" . strpart(a:rgb, 2, 2)) + 0
line 3:   let l:b = ("0x" . strpart(a:rgb, 4, 2)) + 0
line 4:   return s:colour(l:r, l:g, l:b)
calling <SNR>72_colour(94, 94, 94)

line 1:   " Get the closest grey
line 2:   let l:gx = s:grey_number(a:r)
calling <SNR>72_grey_number(94)

line 1:   if &t_Co == 88
line 2:     if a:x < 23
line 3:       return 0
line 4:     elseif a:x < 69
line 5:       return 1
line 6:     elseif a:x < 103
line 7:       return 2
line 8:     elseif a:x < 127
line 9:       return 3
line 10:     elseif a:x < 150
line 11:       return 4
line 12:     elseif a:x < 173
line 13:       return 5
line 14:     elseif a:x < 196
line 15:       return 6
line 16:     elseif a:x < 219
line 17:       return 7
line 18:     elseif a:x < 243
line 19:       return 8
line 20:     else
line 21:       return 9
line 22:     endif
line 23:   else
line 24:     if a:x < 14
line 25:       return 0
line 26:     else
line 27:       let l:n = (a:x - 8) / 10
line 28:       let l:m = (a:x - 8) % 10
line 29:       if l:m < 5
line 30:         return l:n
line 31:       else
line 32:         return l:n + 1
<SNR>72_grey_number returning #9

continuing in <SNR>72_colour

line 3:   let l:gy = s:grey_number(a:g)
calling <SNR>72_grey_number(94)

line 1:   if &t_Co == 88
line 2:     if a:x < 23
line 3:       return 0
line 4:     elseif a:x < 69
line 5:       return 1
line 6:     elseif a:x < 103
line 7:       return 2
line 8:     elseif a:x < 127
line 9:       return 3
line 10:     elseif a:x < 150
line 11:       return 4
line 12:     elseif a:x < 173
line 13:       return 5
line 14:     elseif a:x < 196
line 15:       return 6
line 16:     elseif a:x < 219
line 17:       return 7
line 18:     elseif a:x < 243
line 19:       return 8
line 20:     else
line 21:       return 9
line 22:     endif
line 23:   else
line 24:     if a:x < 14
line 25:       return 0
line 26:     else
line 27:       let l:n = (a:x - 8) / 10
line 28:       let l:m = (a:x - 8) % 10
line 29:       if l:m < 5
line 30:         return l:n
line 31:       else
line 32:         return l:n + 1
<SNR>72_grey_number returning #9

continuing in <SNR>72_colour

line 4:   let l:gz = s:grey_number(a:b)
calling <SNR>72_grey_number(94)

line 1:   if &t_Co == 88
line 2:     if a:x < 23
line 3:       return 0
line 4:     elseif a:x < 69
line 5:       return 1
line 6:     elseif a:x < 103
line 7:       return 2
line 8:     elseif a:x < 127
line 9:       return 3
line 10:     elseif a:x < 150
line 11:       return 4
line 12:     elseif a:x < 173
line 13:       return 5
line 14:     elseif a:x < 196
line 15:       return 6
line 16:     elseif a:x < 219
line 17:       return 7
line 18:     elseif a:x < 243
line 19:       return 8
line 20:     else
line 21:       return 9
line 22:     endif
line 23:   else
line 24:     if a:x < 14
line 25:       return 0
line 26:     else
line 27:       let l:n = (a:x - 8) / 10
line 28:       let l:m = (a:x - 8) % 10
line 29:       if l:m < 5
line 30:         return l:n
line 31:       else
line 32:         return l:n + 1
<SNR>72_grey_number returning #9

continuing in <SNR>72_colour

line 5: 
line 6:   " Get the closest colour
line 7:   let l:x = s:rgb_number(a:r)
calling <SNR>72_rgb_number(94)

line 1:   if &t_Co == 88
line 2:     if a:x < 69
line 3:       return 0
line 4:     elseif a:x < 172
line 5:       return 1
line 6:     elseif a:x < 230
line 7:       return 2
line 8:     else
line 9:       return 3
line 10:     endif
line 11:   else
line 12:     if a:x < 75
line 13:       return 0
line 14:     else
line 15:       let l:n = (a:x - 55) / 40
line 16:       let l:m = (a:x - 55) % 40
line 17:       if l:m < 20
line 18:         return l:n
line 19:       else
line 20:         return l:n + 1
<SNR>72_rgb_number returning #1

continuing in <SNR>72_colour

line 8:   let l:y = s:rgb_number(a:g)
calling <SNR>72_rgb_number(94)

line 1:   if &t_Co == 88
line 2:     if a:x < 69
line 3:       return 0
line 4:     elseif a:x < 172
line 5:       return 1
line 6:     elseif a:x < 230
line 7:       return 2
line 8:     else
line 9:       return 3
line 10:     endif
line 11:   else
line 12:     if a:x < 75
line 13:       return 0
line 14:     else
line 15:       let l:n = (a:x - 55) / 40
line 16:       let l:m = (a:x - 55) % 40
line 17:       if l:m < 20
line 18:         return l:n
line 19:       else
line 20:         return l:n + 1
<SNR>72_rgb_number returning #1

continuing in <SNR>72_colour

line 9:   let l:z = s:rgb_number(a:b)
calling <SNR>72_rgb_number(94)

line 1:   if &t_Co == 88
line 2:     if a:x < 69
line 3:       return 0
line 4:     elseif a:x < 172
line 5:       return 1
line 6:     elseif a:x < 230
line 7:       return 2
line 8:     else
line 9:       return 3
line 10:     endif
line 11:   else
line 12:     if a:x < 75
line 13:       return 0
line 14:     else
line 15:       let l:n = (a:x - 55) / 40
line 16:       let l:m = (a:x - 55) % 40
line 17:       if l:m < 20
line 18:         return l:n
line 19:       else
line 20:         return l:n + 1
<SNR>72_rgb_number returning #1

continuing in <SNR>72_colour

line 10: 
line 11:   if l:gx == l:gy && l:gy == l:gz
line 12:     " There are two possibilities
line 13:     let l:dgr = s:grey_level(l:gx) - a:r
calling <SNR>72_grey_level(9)

line 1:   if &t_Co == 88
line 2:     if a:n == 0
line 3:       return 0
line 4:     elseif a:n == 1
line 5:       return 46
line 6:     elseif a:n == 2
line 7:       return 92
line 8:     elseif a:n == 3
line 9:       return 115
line 10:     elseif a:n == 4
line 11:       return 139
line 12:     elseif a:n == 5
line 13:       return 162
line 14:     elseif a:n == 6
line 15:       return 185
line 16:     elseif a:n == 7
line 17:       return 208
line 18:     elseif a:n == 8
line 19:       return 231
line 20:     else
line 21:       return 255
line 22:     endif
line 23:   else
line 24:     if a:n == 0
line 25:       return 0
line 26:     else
line 27:       return 8 + (a:n * 10)
<SNR>72_grey_level returning #98

continuing in <SNR>72_colour

line 14:     let l:dgg = s:grey_level(l:gy) - a:g
calling <SNR>72_grey_level(9)

line 1:   if &t_Co == 88
line 2:     if a:n == 0
line 3:       return 0
line 4:     elseif a:n == 1
line 5:       return 46
line 6:     elseif a:n == 2
line 7:       return 92
line 8:     elseif a:n == 3
line 9:       return 115
line 10:     elseif a:n == 4
line 11:       return 139
line 12:     elseif a:n == 5
line 13:       return 162
line 14:     elseif a:n == 6
line 15:       return 185
line 16:     elseif a:n == 7
line 17:       return 208
line 18:     elseif a:n == 8
line 19:       return 231
line 20:     else
line 21:       return 255
line 22:     endif
line 23:   else
line 24:     if a:n == 0
line 25:       return 0
line 26:     else
line 27:       return 8 + (a:n * 10)
<SNR>72_grey_level returning #98

continuing in <SNR>72_colour

line 15:     let l:dgb = s:grey_level(l:gz) - a:b
calling <SNR>72_grey_level(9)

line 1:   if &t_Co == 88
line 2:     if a:n == 0
line 3:       return 0
line 4:     elseif a:n == 1
line 5:       return 46
line 6:     elseif a:n == 2
line 7:       return 92
line 8:     elseif a:n == 3
line 9:       return 115
line 10:     elseif a:n == 4
line 11:       return 139
line 12:     elseif a:n == 5
line 13:       return 162
line 14:     elseif a:n == 6
line 15:       return 185
line 16:     elseif a:n == 7
line 17:       return 208
line 18:     elseif a:n == 8
line 19:       return 231
line 20:     else
line 21:       return 255
line 22:     endif
line 23:   else
line 24:     if a:n == 0
line 25:       return 0
line 26:     else
line 27:       return 8 + (a:n * 10)
<SNR>72_grey_level returning #98

continuing in <SNR>72_colour

line 16:     let l:dgrey = (l:dgr * l:dgr) + (l:dgg * l:dgg) + (l:dgb * l:dgb)
line 17:     let l:dr = s:rgb_level(l:gx) - a:r
calling <SNR>72_rgb_level(9)

line 1:   if &t_Co == 88
line 2:     if a:n == 0
line 3:       return 0
line 4:     elseif a:n == 1
line 5:       return 139
line 6:     elseif a:n == 2
line 7:       return 205
line 8:     else
line 9:       return 255
line 10:     endif
line 11:   else
line 12:     if a:n == 0
line 13:       return 0
line 14:     else
line 15:       return 55 + (a:n * 40)
<SNR>72_rgb_level returning #415

continuing in <SNR>72_colour

line 18:     let l:dg = s:rgb_level(l:gy) - a:g
calling <SNR>72_rgb_level(9)

line 1:   if &t_Co == 88
line 2:     if a:n == 0
line 3:       return 0
line 4:     elseif a:n == 1
line 5:       return 139
line 6:     elseif a:n == 2
line 7:       return 205
line 8:     else
line 9:       return 255
line 10:     endif
line 11:   else
line 12:     if a:n == 0
line 13:       return 0
line 14:     else
line 15:       return 55 + (a:n * 40)
<SNR>72_rgb_level returning #415

continuing in <SNR>72_colour

line 19:     let l:db = s:rgb_level(l:gz) - a:b
calling <SNR>72_rgb_level(9)

line 1:   if &t_Co == 88
line 2:     if a:n == 0
line 3:       return 0
line 4:     elseif a:n == 1
line 5:       return 139
line 6:     elseif a:n == 2
line 7:       return 205
line 8:     else
line 9:       return 255
line 10:     endif
line 11:   else
line 12:     if a:n == 0
line 13:       return 0
line 14:     else
line 15:       return 55 + (a:n * 40)
<SNR>72_rgb_level returning #415

continuing in <SNR>72_colour

line 20:     let l:drgb = (l:dr * l:dr) + (l:dg * l:dg) + (l:db * l:db)
line 21:     if l:dgrey < l:drgb
line 22:       " Use the grey
line 23:       return s:grey_colour(l:gx)
calling <SNR>72_grey_colour(9)

line 1:   if &t_Co == 88
line 2:     if a:n == 0
line 3:       return 16
line 4:     elseif a:n == 9
line 5:       return 79
line 6:     else
line 7:       return 79 + a:n
line 8:     endif
line 9:   else
line 10:     if a:n == 0
line 11:       return 16
line 12:     elseif a:n == 25
line 13:       return 231
line 14:     else
line 15:       return 231 + a:n
<SNR>72_grey_colour returning #240

continuing in <SNR>72_colour

<SNR>72_colour returning #240

continuing in coc#color#rgb2term

coc#color#rgb2term returning #240

continuing in coc#highlight#create_bg_command

line 7:   if s:term && !s:check_ctermbg(id, ctermbg) && abs(a:amount) < 20.0
line 8:     return coc#highlight#create_bg_command(a:group, a:amount * 2)
line 9:   endif
line 10:   return 'ctermbg=' . ctermbg.' guibg=' . hex
coc#highlight#create_bg_command returning 'ctermbg=240 guibg=#5e5e5e'

continuing in <SNR>46_Highlight

line 4: hi default CocFloatThumb ctermbg=240 guibg=#5e5e5e
line 5:     hi default link CocFloatSbar CocFloating
line 6:   else
line 7:     exe 'hi default link CocFloating '.(has('nvim') ? 'NormalFloat' : 'Pmenu')
line 8:     if coc#highlight#get_contrast('CocFloating', 'PmenuSel') > 2.0
line 9:       exe 'hi default CocMenuSel '.coc#highlight#create_bg_command('CocFloating', &background ==# 'dark' ? -30 : 30)
line 10:     else
line 11:       exe 'hi default CocMenuSel '.coc#highlight#get_hl_command(synIDtrans(hlID('PmenuSel')), 'bg', '237', '#13354A')
line 12:     endif
line 13:     hi default link CocFloatThumb        PmenuThumb
line 14:     hi default link CocFloatSbar         PmenuSbar
line 15:   endif
line 16:   if coc#highlight#get_contrast('Normal', 'CursorLine') < 1.3
calling coc#highlight#get_contrast('Normal', 'CursorLine')

line 1:   let normal = coc#highlight#get_hex_color(synIDtrans(hlID('Normal')), 'bg', '#000000')
calling coc#highlight#get_hex_color(61, 'bg', '#000000')

line 1:   let attr = coc#highlight#get_color(a:id, a:kind, s:term ? 'cterm' : 'gui')
calling coc#highlight#get_color(61, 'bg', 'gui')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning ''

continuing in coc#highlight#get_hex_color

line 2:   let hex = s:to_hex_color(attr, s:term)
calling <SNR>71_to_hex_color('', 0)

line 1:   if empty(a:color)
line 2:     return ''
<SNR>71_to_hex_color returning ''

continuing in coc#highlight#get_hex_color

line 3:   if empty(hex) && !s:term
line 4:     let attr = coc#highlight#get_color(a:id, a:kind, 'cterm')
calling coc#highlight#get_color(61, 'bg', 'cterm')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning ''

continuing in coc#highlight#get_hex_color

line 5:     let hex = s:to_hex_color(attr, 1)
calling <SNR>71_to_hex_color('', 1)

line 1:   if empty(a:color)
line 2:     return ''
<SNR>71_to_hex_color returning ''

continuing in coc#highlight#get_hex_color

line 6:   endif
line 7:   return empty(hex) ? a:fallback : hex
coc#highlight#get_hex_color returning '#000000'

continuing in coc#highlight#get_contrast

line 2:   let bg1 = coc#highlight#get_hex_color(synIDtrans(hlID(a:group1)), 'bg', normal)
calling coc#highlight#get_hex_color(61, 'bg', '#000000')

line 1:   let attr = coc#highlight#get_color(a:id, a:kind, s:term ? 'cterm' : 'gui')
calling coc#highlight#get_color(61, 'bg', 'gui')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning ''

continuing in coc#highlight#get_hex_color

line 2:   let hex = s:to_hex_color(attr, s:term)
calling <SNR>71_to_hex_color('', 0)

line 1:   if empty(a:color)
line 2:     return ''
<SNR>71_to_hex_color returning ''

continuing in coc#highlight#get_hex_color

line 3:   if empty(hex) && !s:term
line 4:     let attr = coc#highlight#get_color(a:id, a:kind, 'cterm')
calling coc#highlight#get_color(61, 'bg', 'cterm')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning ''

continuing in coc#highlight#get_hex_color

line 5:     let hex = s:to_hex_color(attr, 1)
calling <SNR>71_to_hex_color('', 1)

line 1:   if empty(a:color)
line 2:     return ''
<SNR>71_to_hex_color returning ''

continuing in coc#highlight#get_hex_color

line 6:   endif
line 7:   return empty(hex) ? a:fallback : hex
coc#highlight#get_hex_color returning '#000000'

continuing in coc#highlight#get_contrast

line 3:   let bg2 = coc#highlight#get_hex_color(synIDtrans(hlID(a:group2)), 'bg', normal)
calling coc#highlight#get_hex_color(52, 'bg', '#000000')

line 1:   let attr = coc#highlight#get_color(a:id, a:kind, s:term ? 'cterm' : 'gui')
calling coc#highlight#get_color(52, 'bg', 'gui')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning '#313640'

continuing in coc#highlight#get_hex_color

line 2:   let hex = s:to_hex_color(attr, s:term)
calling <SNR>71_to_hex_color('#313640', 0)

line 1:   if empty(a:color)
line 2:     return ''
line 3:   endif
line 4:   if a:color =~# '^#\x\+$'
line 5:     return a:color
<SNR>71_to_hex_color returning '#313640'

continuing in coc#highlight#get_hex_color

line 3:   if empty(hex) && !s:term
line 4:     let attr = coc#highlight#get_color(a:id, a:kind, 'cterm')
line 5:     let hex = s:to_hex_color(attr, 1)
line 6:   endif
line 7:   return empty(hex) ? a:fallback : hex
coc#highlight#get_hex_color returning '#313640'

continuing in coc#highlight#get_contrast

line 4:   return coc#color#hex_contrast(bg1, bg2)
calling coc#color#hex_contrast('#000000', '#313640')

line 1:   return  coc#color#contrast(coc#color#hexToRgb(a:hex1), coc#color#hexToRgb(a:hex2))
calling coc#color#hexToRgb('#000000')

line 1:   if type(a:color) == 2
line 2:     let color = printf('%x', a:color)
line 3:   else
line 4:     let color = a:color
line 5:   end
line 6:   let matches = matchlist(color, s:patterns['hex'])
line 7:   let factor  = 0x1
line 8:   if empty(matches)
line 9:     let matches = matchlist(color, s:patterns['shortHex'])
line 10:     let factor  = 0x10
line 11:     end
line 12:     if len(matches) < 4
line 13:       echohl Error
line 14:       echom 'Couldnt parse ' . string(color) . ' ' .  string(matches)
line 15:       echohl None
line 16:       return
line 17:     end
line 18:     let r = str2nr(matches[1], 16) * factor
line 19:     let g = str2nr(matches[2], 16) * factor
line 20:     let b = str2nr(matches[3], 16) * factor
line 21:   return [r, g, b]
coc#color#hexToRgb returning [0, 0, 0]

continuing in coc#color#hex_contrast

calling coc#color#hexToRgb('#313640')

line 1:   if type(a:color) == 2
line 2:     let color = printf('%x', a:color)
line 3:   else
line 4:     let color = a:color
line 5:   end
line 6:   let matches = matchlist(color, s:patterns['hex'])
line 7:   let factor  = 0x1
line 8:   if empty(matches)
line 9:     let matches = matchlist(color, s:patterns['shortHex'])
line 10:     let factor  = 0x10
line 11:     end
line 12:     if len(matches) < 4
line 13:       echohl Error
line 14:       echom 'Couldnt parse ' . string(color) . ' ' .  string(matches)
line 15:       echohl None
line 16:       return
line 17:     end
line 18:     let r = str2nr(matches[1], 16) * factor
line 19:     let g = str2nr(matches[2], 16) * factor
line 20:     let b = str2nr(matches[3], 16) * factor
line 21:   return [r, g, b]
coc#color#hexToRgb returning [49, 54, 64]

continuing in coc#color#hex_contrast

calling coc#color#contrast([0, 0, 0], [49, 54, 64])

line 1:   let lnum1 = coc#color#luminance(a:rgb1)
calling coc#color#luminance([0, 0, 0])

line 1:   let vals = []
line 2:   for val in a:rgb
line 3:     let val = (val + 0.0)/255
line 4:     if val <= 0.03928
line 5:       call add(vals, val/12.92)
line 6:     else
line 7:       call add(vals, pow((val + 0.055)/1.055, 2.4))
line 8:     endif
line 9:   endfor
line 2:   for val in a:rgb
line 3:     let val = (val + 0.0)/255
line 4:     if val <= 0.03928
line 5:       call add(vals, val/12.92)
line 6:     else
line 7:       call add(vals, pow((val + 0.055)/1.055, 2.4))
line 8:     endif
line 9:   endfor
line 2:   for val in a:rgb
line 3:     let val = (val + 0.0)/255
line 4:     if val <= 0.03928
line 5:       call add(vals, val/12.92)
line 6:     else
line 7:       call add(vals, pow((val + 0.055)/1.055, 2.4))
line 8:     endif
line 9:   endfor
line 2:   for val in a:rgb
line 3:     let val = (val + 0.0)/255
line 4:     if val <= 0.03928
line 5:       call add(vals, val/12.92)
line 6:     else
line 7:       call add(vals, pow((val + 0.055)/1.055, 2.4))
line 8:     endif
line 9:   endfor
line 10:   return vals[0] * 0.2126 + vals[1] * 0.7152 + vals[2] * 0.0722
coc#color#luminance returning 0.0

continuing in coc#color#contrast

line 2:   let lnum2 = coc#color#luminance(a:rgb2)
calling coc#color#luminance([49, 54, 64])

line 1:   let vals = []
line 2:   for val in a:rgb
line 3:     let val = (val + 0.0)/255
line 4:     if val <= 0.03928
line 5:       call add(vals, val/12.92)
line 6:     else
line 7:       call add(vals, pow((val + 0.055)/1.055, 2.4))
line 8:     endif
line 9:   endfor
line 2:   for val in a:rgb
line 3:     let val = (val + 0.0)/255
line 4:     if val <= 0.03928
line 5:       call add(vals, val/12.92)
line 6:     else
line 7:       call add(vals, pow((val + 0.055)/1.055, 2.4))
line 8:     endif
line 9:   endfor
line 2:   for val in a:rgb
line 3:     let val = (val + 0.0)/255
line 4:     if val <= 0.03928
line 5:       call add(vals, val/12.92)
line 6:     else
line 7:       call add(vals, pow((val + 0.055)/1.055, 2.4))
line 8:     endif
line 9:   endfor
line 2:   for val in a:rgb
line 3:     let val = (val + 0.0)/255
line 4:     if val <= 0.03928
line 5:       call add(vals, val/12.92)
line 6:     else
line 7:       call add(vals, pow((val + 0.055)/1.055, 2.4))
line 8:     endif
line 9:   endfor
line 10:   return vals[0] * 0.2126 + vals[1] * 0.7152 + vals[2] * 0.0722
coc#color#luminance returning 0.036615

continuing in coc#color#contrast

line 3:   let brightest = lnum1 > lnum2 ? lnum1 : lnum2
line 4:   let darkest = lnum1 < lnum2 ? lnum1 : lnum2
line 5:   return (brightest + 0.05) / (darkest + 0.05)
coc#color#contrast returning 1.732293

continuing in coc#color#hex_contrast

coc#color#hex_contrast returning 1.732293

continuing in coc#highlight#get_contrast

coc#highlight#get_contrast returning 1.732293

continuing in <SNR>46_Highlight

line 17:     " Avoid color too close
line 18:     exe 'hi default CocListLine '.coc#highlight#create_bg_command('Normal', &background ==# 'dark' ? -20 : 20)
line 19:   else
line 20:     hi default link CocListLine            CursorLine
line 21:   endif
line 22: 
line 23:   if has('nvim')
line 24:     hi default CocCursorTransparent gui=strikethrough blend=100
line 25:   endif
line 26: 
line 27:   let sign_colors = { 'Error': ['Red', '#ff0000'], 'Warn': ['Brown', '#ff922b'], 'Info': ['Yellow', '#fab005'], 'Hint': ['Blue', '#15aabf'] }
line 33:   for name in ['Error', 'Warning', 'Info', 'Hint']
line 34:     let suffix = name ==# 'Warning' ? 'Warn' : name
line 35:     if hlexists('DiagnosticUnderline'.suffix)
line 36:       exe 'hi default link Coc'.name.'Highlight DiagnosticUnderline'.suffix
line 37:     else
line 38:       exe 'hi default link Coc'.name.'Highlight CocUnderline'
line 38: hi default link CocErrorHighlight CocUnderline
line 39:     endif
line 40:     if hlexists('DiagnosticSign'.suffix)
line 41:       exe 'hi default link Coc'.name.'Sign DiagnosticSign'.suffix
line 42:     else
line 43:       exe 'hi default Coc'.name.'Sign ctermfg='.sign_colors[suffix][0].' guifg='.sign_colors[suffix][1]
line 43: hi default CocErrorSign ctermfg=Red guifg=#ff0000
line 44:     endif
line 45:     if hlexists('DiagnosticVirtualText'.suffix)
line 46:       exe 'hi default link Coc'.name.'VirtualText DiagnosticVirtualText'.suffix
line 47:     else
line 48:       call s:CreateHighlight('Coc'.name.'VirtualText', 'Coc'.name.'Sign', 'Normal')
calling <SNR>46_CreateHighlight('CocErrorVirtualText', 'CocErrorSign', 'Normal')

line 1:   let cmd = coc#highlight#compose(a:fg, a:bg)
calling coc#highlight#compose('CocErrorSign', 'Normal')

line 1:   let fgId = synIDtrans(hlID(a:fg))
line 2:   let bgId = synIDtrans(hlID(a:bg))
line 3:   let isGuiReversed = synIDattr(fgId, 'reverse', 'gui') !=# '1' || synIDattr(bgId, 'reverse', 'gui') !=# '1'
line 4:   let guifg = isGuiReversed ? synIDattr(fgId, 'fg', 'gui') : synIDattr(fgId, 'bg', 'gui')
line 5:   let guibg = isGuiReversed ? synIDattr(bgId, 'bg', 'gui') : synIDattr(bgId, 'fg', 'gui')
line 6:   let isCtermReversed = synIDattr(fgId, 'reverse', 'cterm') !=# '1' || synIDattr(bgId, 'reverse', 'cterm') !=# '1'
line 7:   let ctermfg = isCtermReversed ? synIDattr(fgId, 'fg', 'cterm') : synIDattr(fgId, 'bg', 'cterm')
line 8:   let ctermbg = isCtermReversed ? synIDattr(bgId, 'bg', 'cterm') : synIDattr(bgId, 'fg', 'cterm')
line 9:   let bold = synIDattr(fgId, 'bold') ==# '1'
line 10:   let italic = synIDattr(fgId, 'italic') ==# '1'
line 11:   let underline = synIDattr(fgId, 'underline') ==# '1'
line 12:   let cmd = ''
line 13:   if !empty(guifg)
line 14:     let cmd .= ' guifg=' . guifg
line 15:   endif
line 16:   if !empty(ctermfg)
line 17:     let cmd .= ' ctermfg=' . ctermfg
line 18:   elseif guifg =~# '^#'
line 19:     let cmd .= ' ctermfg=' . coc#color#rgb2term(strpart(guifg, 1))
line 20:   endif
line 21:   if !empty(guibg)
line 22:     let cmd .= ' guibg=' . guibg
line 23:   endif
line 24:   if !empty(ctermbg)
line 25:     let cmd .= ' ctermbg=' . ctermbg
line 26:   elseif guibg =~# '^#'
line 27:     let cmd .= ' ctermbg=' . coc#color#rgb2term(strpart(guibg, 1))
line 28:   endif
line 29:   if bold
line 30:     let cmd .= ' cterm=bold gui=bold'
line 31:   elseif italic
line 32:     let cmd .= ' cterm=italic gui=italic'
line 33:   elseif underline
line 34:     let cmd .= ' cterm=underline gui=underline'
line 35:   endif
line 36:   return cmd
coc#highlight#compose returning ' guifg=#ff0000 ctermfg=9'

continuing in <SNR>46_CreateHighlight

line 2:   if !empty(trim(cmd))
line 3:     exe 'hi default '.a:group.' '.cmd
line 3: hi default CocErrorVirtualText  guifg=#ff0000 ctermfg=9
line 4:   else
line 5:     exe 'hi default link '.a:group.' '.a:fg
line 6:   endif
<SNR>46_CreateHighlight returning #0

continuing in <SNR>46_Highlight

line 49:     endif
line 50:     if hlexists('Diagnostic'.suffix)
line 51:       exe 'hi default link Coc'.name.'Float Diagnostic'.suffix
line 52:     else
line 53:       call s:CreateHighlight('Coc'.name.'Float', 'Coc'.name.'Sign', 'CocFloating')
calling <SNR>46_CreateHighlight('CocErrorFloat', 'CocErrorSign', 'CocFloating')

line 1:   let cmd = coc#highlight#compose(a:fg, a:bg)
calling coc#highlight#compose('CocErrorSign', 'CocFloating')

line 1:   let fgId = synIDtrans(hlID(a:fg))
line 2:   let bgId = synIDtrans(hlID(a:bg))
line 3:   let isGuiReversed = synIDattr(fgId, 'reverse', 'gui') !=# '1' || synIDattr(bgId, 'reverse', 'gui') !=# '1'
line 4:   let guifg = isGuiReversed ? synIDattr(fgId, 'fg', 'gui') : synIDattr(fgId, 'bg', 'gui')
line 5:   let guibg = isGuiReversed ? synIDattr(bgId, 'bg', 'gui') : synIDattr(bgId, 'fg', 'gui')
line 6:   let isCtermReversed = synIDattr(fgId, 'reverse', 'cterm') !=# '1' || synIDattr(bgId, 'reverse', 'cterm') !=# '1'
line 7:   let ctermfg = isCtermReversed ? synIDattr(fgId, 'fg', 'cterm') : synIDattr(fgId, 'bg', 'cterm')
line 8:   let ctermbg = isCtermReversed ? synIDattr(bgId, 'bg', 'cterm') : synIDattr(bgId, 'fg', 'cterm')
line 9:   let bold = synIDattr(fgId, 'bold') ==# '1'
line 10:   let italic = synIDattr(fgId, 'italic') ==# '1'
line 11:   let underline = synIDattr(fgId, 'underline') ==# '1'
line 12:   let cmd = ''
line 13:   if !empty(guifg)
line 14:     let cmd .= ' guifg=' . guifg
line 15:   endif
line 16:   if !empty(ctermfg)
line 17:     let cmd .= ' ctermfg=' . ctermfg
line 18:   elseif guifg =~# '^#'
line 19:     let cmd .= ' ctermfg=' . coc#color#rgb2term(strpart(guifg, 1))
line 20:   endif
line 21:   if !empty(guibg)
line 22:     let cmd .= ' guibg=' . guibg
line 23:   endif
line 24:   if !empty(ctermbg)
line 25:     let cmd .= ' ctermbg=' . ctermbg
line 26:   elseif guibg =~# '^#'
line 27:     let cmd .= ' ctermbg=' . coc#color#rgb2term(strpart(guibg, 1))
line 28:   endif
line 29:   if bold
line 30:     let cmd .= ' cterm=bold gui=bold'
line 31:   elseif italic
line 32:     let cmd .= ' cterm=italic gui=italic'
line 33:   elseif underline
line 34:     let cmd .= ' cterm=underline gui=underline'
line 35:   endif
line 36:   return cmd
coc#highlight#compose returning ' guifg=#ff0000 ctermfg=9 guibg=#414141 ctermbg=237'

continuing in <SNR>46_CreateHighlight

line 2:   if !empty(trim(cmd))
line 3:     exe 'hi default '.a:group.' '.cmd
line 3: hi default CocErrorFloat  guifg=#ff0000 ctermfg=9 guibg=#414141 ctermbg=237
line 4:   else
line 5:     exe 'hi default link '.a:group.' '.a:fg
line 6:   endif
<SNR>46_CreateHighlight returning #0

continuing in <SNR>46_Highlight

line 54:     endif
line 55:   endfor
line 33:   for name in ['Error', 'Warning', 'Info', 'Hint']
line 34:     let suffix = name ==# 'Warning' ? 'Warn' : name
line 35:     if hlexists('DiagnosticUnderline'.suffix)
line 36:       exe 'hi default link Coc'.name.'Highlight DiagnosticUnderline'.suffix
line 37:     else
line 38:       exe 'hi default link Coc'.name.'Highlight CocUnderline'
line 38: hi default link CocWarningHighlight CocUnderline
line 39:     endif
line 40:     if hlexists('DiagnosticSign'.suffix)
line 41:       exe 'hi default link Coc'.name.'Sign DiagnosticSign'.suffix
line 42:     else
line 43:       exe 'hi default Coc'.name.'Sign ctermfg='.sign_colors[suffix][0].' guifg='.sign_colors[suffix][1]
line 43: hi default CocWarningSign ctermfg=Brown guifg=#ff922b
line 44:     endif
line 45:     if hlexists('DiagnosticVirtualText'.suffix)
line 46:       exe 'hi default link Coc'.name.'VirtualText DiagnosticVirtualText'.suffix
line 47:     else
line 48:       call s:CreateHighlight('Coc'.name.'VirtualText', 'Coc'.name.'Sign', 'Normal')
calling <SNR>46_CreateHighlight('CocWarningVirtualText', 'CocWarningSign', 'Normal')

line 1:   let cmd = coc#highlight#compose(a:fg, a:bg)
calling coc#highlight#compose('CocWarningSign', 'Normal')

line 1:   let fgId = synIDtrans(hlID(a:fg))
line 2:   let bgId = synIDtrans(hlID(a:bg))
line 3:   let isGuiReversed = synIDattr(fgId, 'reverse', 'gui') !=# '1' || synIDattr(bgId, 'reverse', 'gui') !=# '1'
line 4:   let guifg = isGuiReversed ? synIDattr(fgId, 'fg', 'gui') : synIDattr(fgId, 'bg', 'gui')
line 5:   let guibg = isGuiReversed ? synIDattr(bgId, 'bg', 'gui') : synIDattr(bgId, 'fg', 'gui')
line 6:   let isCtermReversed = synIDattr(fgId, 'reverse', 'cterm') !=# '1' || synIDattr(bgId, 'reverse', 'cterm') !=# '1'
line 7:   let ctermfg = isCtermReversed ? synIDattr(fgId, 'fg', 'cterm') : synIDattr(fgId, 'bg', 'cterm')
line 8:   let ctermbg = isCtermReversed ? synIDattr(bgId, 'bg', 'cterm') : synIDattr(bgId, 'fg', 'cterm')
line 9:   let bold = synIDattr(fgId, 'bold') ==# '1'
line 10:   let italic = synIDattr(fgId, 'italic') ==# '1'
line 11:   let underline = synIDattr(fgId, 'underline') ==# '1'
line 12:   let cmd = ''
line 13:   if !empty(guifg)
line 14:     let cmd .= ' guifg=' . guifg
line 15:   endif
line 16:   if !empty(ctermfg)
line 17:     let cmd .= ' ctermfg=' . ctermfg
line 18:   elseif guifg =~# '^#'
line 19:     let cmd .= ' ctermfg=' . coc#color#rgb2term(strpart(guifg, 1))
line 20:   endif
line 21:   if !empty(guibg)
line 22:     let cmd .= ' guibg=' . guibg
line 23:   endif
line 24:   if !empty(ctermbg)
line 25:     let cmd .= ' ctermbg=' . ctermbg
line 26:   elseif guibg =~# '^#'
line 27:     let cmd .= ' ctermbg=' . coc#color#rgb2term(strpart(guibg, 1))
line 28:   endif
line 29:   if bold
line 30:     let cmd .= ' cterm=bold gui=bold'
line 31:   elseif italic
line 32:     let cmd .= ' cterm=italic gui=italic'
line 33:   elseif underline
line 34:     let cmd .= ' cterm=underline gui=underline'
line 35:   endif
line 36:   return cmd
coc#highlight#compose returning ' guifg=#ff922b ctermfg=130'

continuing in <SNR>46_CreateHighlight

line 2:   if !empty(trim(cmd))
line 3:     exe 'hi default '.a:group.' '.cmd
line 3: hi default CocWarningVirtualText  guifg=#ff922b ctermfg=130
line 4:   else
line 5:     exe 'hi default link '.a:group.' '.a:fg
line 6:   endif
<SNR>46_CreateHighlight returning #0

continuing in <SNR>46_Highlight

line 49:     endif
line 50:     if hlexists('Diagnostic'.suffix)
line 51:       exe 'hi default link Coc'.name.'Float Diagnostic'.suffix
line 52:     else
line 53:       call s:CreateHighlight('Coc'.name.'Float', 'Coc'.name.'Sign', 'CocFloating')
calling <SNR>46_CreateHighlight('CocWarningFloat', 'CocWarningSign', 'CocFloating')

line 1:   let cmd = coc#highlight#compose(a:fg, a:bg)
calling coc#highlight#compose('CocWarningSign', 'CocFloating')

line 1:   let fgId = synIDtrans(hlID(a:fg))
line 2:   let bgId = synIDtrans(hlID(a:bg))
line 3:   let isGuiReversed = synIDattr(fgId, 'reverse', 'gui') !=# '1' || synIDattr(bgId, 'reverse', 'gui') !=# '1'
line 4:   let guifg = isGuiReversed ? synIDattr(fgId, 'fg', 'gui') : synIDattr(fgId, 'bg', 'gui')
line 5:   let guibg = isGuiReversed ? synIDattr(bgId, 'bg', 'gui') : synIDattr(bgId, 'fg', 'gui')
line 6:   let isCtermReversed = synIDattr(fgId, 'reverse', 'cterm') !=# '1' || synIDattr(bgId, 'reverse', 'cterm') !=# '1'
line 7:   let ctermfg = isCtermReversed ? synIDattr(fgId, 'fg', 'cterm') : synIDattr(fgId, 'bg', 'cterm')
line 8:   let ctermbg = isCtermReversed ? synIDattr(bgId, 'bg', 'cterm') : synIDattr(bgId, 'fg', 'cterm')
line 9:   let bold = synIDattr(fgId, 'bold') ==# '1'
line 10:   let italic = synIDattr(fgId, 'italic') ==# '1'
line 11:   let underline = synIDattr(fgId, 'underline') ==# '1'
line 12:   let cmd = ''
line 13:   if !empty(guifg)
line 14:     let cmd .= ' guifg=' . guifg
line 15:   endif
line 16:   if !empty(ctermfg)
line 17:     let cmd .= ' ctermfg=' . ctermfg
line 18:   elseif guifg =~# '^#'
line 19:     let cmd .= ' ctermfg=' . coc#color#rgb2term(strpart(guifg, 1))
line 20:   endif
line 21:   if !empty(guibg)
line 22:     let cmd .= ' guibg=' . guibg
line 23:   endif
line 24:   if !empty(ctermbg)
line 25:     let cmd .= ' ctermbg=' . ctermbg
line 26:   elseif guibg =~# '^#'
line 27:     let cmd .= ' ctermbg=' . coc#color#rgb2term(strpart(guibg, 1))
line 28:   endif
line 29:   if bold
line 30:     let cmd .= ' cterm=bold gui=bold'
line 31:   elseif italic
line 32:     let cmd .= ' cterm=italic gui=italic'
line 33:   elseif underline
line 34:     let cmd .= ' cterm=underline gui=underline'
line 35:   endif
line 36:   return cmd
coc#highlight#compose returning ' guifg=#ff922b ctermfg=130 guibg=#414141 ctermbg=237'

continuing in <SNR>46_CreateHighlight

line 2:   if !empty(trim(cmd))
line 3:     exe 'hi default '.a:group.' '.cmd
line 3: hi default CocWarningFloat  guifg=#ff922b ctermfg=130 guibg=#414141 ctermbg=237
line 4:   else
line 5:     exe 'hi default link '.a:group.' '.a:fg
line 6:   endif
<SNR>46_CreateHighlight returning #0

continuing in <SNR>46_Highlight

line 54:     endif
line 55:   endfor
line 33:   for name in ['Error', 'Warning', 'Info', 'Hint']
line 34:     let suffix = name ==# 'Warning' ? 'Warn' : name
line 35:     if hlexists('DiagnosticUnderline'.suffix)
line 36:       exe 'hi default link Coc'.name.'Highlight DiagnosticUnderline'.suffix
line 37:     else
line 38:       exe 'hi default link Coc'.name.'Highlight CocUnderline'
line 38: hi default link CocInfoHighlight CocUnderline
line 39:     endif
line 40:     if hlexists('DiagnosticSign'.suffix)
line 41:       exe 'hi default link Coc'.name.'Sign DiagnosticSign'.suffix
line 42:     else
line 43:       exe 'hi default Coc'.name.'Sign ctermfg='.sign_colors[suffix][0].' guifg='.sign_colors[suffix][1]
line 43: hi default CocInfoSign ctermfg=Yellow guifg=#fab005
line 44:     endif
line 45:     if hlexists('DiagnosticVirtualText'.suffix)
line 46:       exe 'hi default link Coc'.name.'VirtualText DiagnosticVirtualText'.suffix
line 47:     else
line 48:       call s:CreateHighlight('Coc'.name.'VirtualText', 'Coc'.name.'Sign', 'Normal')
calling <SNR>46_CreateHighlight('CocInfoVirtualText', 'CocInfoSign', 'Normal')

line 1:   let cmd = coc#highlight#compose(a:fg, a:bg)
calling coc#highlight#compose('CocInfoSign', 'Normal')

line 1:   let fgId = synIDtrans(hlID(a:fg))
line 2:   let bgId = synIDtrans(hlID(a:bg))
line 3:   let isGuiReversed = synIDattr(fgId, 'reverse', 'gui') !=# '1' || synIDattr(bgId, 'reverse', 'gui') !=# '1'
line 4:   let guifg = isGuiReversed ? synIDattr(fgId, 'fg', 'gui') : synIDattr(fgId, 'bg', 'gui')
line 5:   let guibg = isGuiReversed ? synIDattr(bgId, 'bg', 'gui') : synIDattr(bgId, 'fg', 'gui')
line 6:   let isCtermReversed = synIDattr(fgId, 'reverse', 'cterm') !=# '1' || synIDattr(bgId, 'reverse', 'cterm') !=# '1'
line 7:   let ctermfg = isCtermReversed ? synIDattr(fgId, 'fg', 'cterm') : synIDattr(fgId, 'bg', 'cterm')
line 8:   let ctermbg = isCtermReversed ? synIDattr(bgId, 'bg', 'cterm') : synIDattr(bgId, 'fg', 'cterm')
line 9:   let bold = synIDattr(fgId, 'bold') ==# '1'
line 10:   let italic = synIDattr(fgId, 'italic') ==# '1'
line 11:   let underline = synIDattr(fgId, 'underline') ==# '1'
line 12:   let cmd = ''
line 13:   if !empty(guifg)
line 14:     let cmd .= ' guifg=' . guifg
line 15:   endif
line 16:   if !empty(ctermfg)
line 17:     let cmd .= ' ctermfg=' . ctermfg
line 18:   elseif guifg =~# '^#'
line 19:     let cmd .= ' ctermfg=' . coc#color#rgb2term(strpart(guifg, 1))
line 20:   endif
line 21:   if !empty(guibg)
line 22:     let cmd .= ' guibg=' . guibg
line 23:   endif
line 24:   if !empty(ctermbg)
line 25:     let cmd .= ' ctermbg=' . ctermbg
line 26:   elseif guibg =~# '^#'
line 27:     let cmd .= ' ctermbg=' . coc#color#rgb2term(strpart(guibg, 1))
line 28:   endif
line 29:   if bold
line 30:     let cmd .= ' cterm=bold gui=bold'
line 31:   elseif italic
line 32:     let cmd .= ' cterm=italic gui=italic'
line 33:   elseif underline
line 34:     let cmd .= ' cterm=underline gui=underline'
line 35:   endif
line 36:   return cmd
coc#highlight#compose returning ' guifg=#fab005 ctermfg=11'

continuing in <SNR>46_CreateHighlight

line 2:   if !empty(trim(cmd))
line 3:     exe 'hi default '.a:group.' '.cmd
line 3: hi default CocInfoVirtualText  guifg=#fab005 ctermfg=11
line 4:   else
line 5:     exe 'hi default link '.a:group.' '.a:fg
line 6:   endif
<SNR>46_CreateHighlight returning #0

continuing in <SNR>46_Highlight

line 49:     endif
line 50:     if hlexists('Diagnostic'.suffix)
line 51:       exe 'hi default link Coc'.name.'Float Diagnostic'.suffix
line 52:     else
line 53:       call s:CreateHighlight('Coc'.name.'Float', 'Coc'.name.'Sign', 'CocFloating')
calling <SNR>46_CreateHighlight('CocInfoFloat', 'CocInfoSign', 'CocFloating')

line 1:   let cmd = coc#highlight#compose(a:fg, a:bg)
calling coc#highlight#compose('CocInfoSign', 'CocFloating')

line 1:   let fgId = synIDtrans(hlID(a:fg))
line 2:   let bgId = synIDtrans(hlID(a:bg))
line 3:   let isGuiReversed = synIDattr(fgId, 'reverse', 'gui') !=# '1' || synIDattr(bgId, 'reverse', 'gui') !=# '1'
line 4:   let guifg = isGuiReversed ? synIDattr(fgId, 'fg', 'gui') : synIDattr(fgId, 'bg', 'gui')
line 5:   let guibg = isGuiReversed ? synIDattr(bgId, 'bg', 'gui') : synIDattr(bgId, 'fg', 'gui')
line 6:   let isCtermReversed = synIDattr(fgId, 'reverse', 'cterm') !=# '1' || synIDattr(bgId, 'reverse', 'cterm') !=# '1'
line 7:   let ctermfg = isCtermReversed ? synIDattr(fgId, 'fg', 'cterm') : synIDattr(fgId, 'bg', 'cterm')
line 8:   let ctermbg = isCtermReversed ? synIDattr(bgId, 'bg', 'cterm') : synIDattr(bgId, 'fg', 'cterm')
line 9:   let bold = synIDattr(fgId, 'bold') ==# '1'
line 10:   let italic = synIDattr(fgId, 'italic') ==# '1'
line 11:   let underline = synIDattr(fgId, 'underline') ==# '1'
line 12:   let cmd = ''
line 13:   if !empty(guifg)
line 14:     let cmd .= ' guifg=' . guifg
line 15:   endif
line 16:   if !empty(ctermfg)
line 17:     let cmd .= ' ctermfg=' . ctermfg
line 18:   elseif guifg =~# '^#'
line 19:     let cmd .= ' ctermfg=' . coc#color#rgb2term(strpart(guifg, 1))
line 20:   endif
line 21:   if !empty(guibg)
line 22:     let cmd .= ' guibg=' . guibg
line 23:   endif
line 24:   if !empty(ctermbg)
line 25:     let cmd .= ' ctermbg=' . ctermbg
line 26:   elseif guibg =~# '^#'
line 27:     let cmd .= ' ctermbg=' . coc#color#rgb2term(strpart(guibg, 1))
line 28:   endif
line 29:   if bold
line 30:     let cmd .= ' cterm=bold gui=bold'
line 31:   elseif italic
line 32:     let cmd .= ' cterm=italic gui=italic'
line 33:   elseif underline
line 34:     let cmd .= ' cterm=underline gui=underline'
line 35:   endif
line 36:   return cmd
coc#highlight#compose returning ' guifg=#fab005 ctermfg=11 guibg=#414141 ctermbg=237'

continuing in <SNR>46_CreateHighlight

line 2:   if !empty(trim(cmd))
line 3:     exe 'hi default '.a:group.' '.cmd
line 3: hi default CocInfoFloat  guifg=#fab005 ctermfg=11 guibg=#414141 ctermbg=237
line 4:   else
line 5:     exe 'hi default link '.a:group.' '.a:fg
line 6:   endif
<SNR>46_CreateHighlight returning #0

continuing in <SNR>46_Highlight

line 54:     endif
line 55:   endfor
line 33:   for name in ['Error', 'Warning', 'Info', 'Hint']
line 34:     let suffix = name ==# 'Warning' ? 'Warn' : name
line 35:     if hlexists('DiagnosticUnderline'.suffix)
line 36:       exe 'hi default link Coc'.name.'Highlight DiagnosticUnderline'.suffix
line 37:     else
line 38:       exe 'hi default link Coc'.name.'Highlight CocUnderline'
line 38: hi default link CocHintHighlight CocUnderline
line 39:     endif
line 40:     if hlexists('DiagnosticSign'.suffix)
line 41:       exe 'hi default link Coc'.name.'Sign DiagnosticSign'.suffix
line 42:     else
line 43:       exe 'hi default Coc'.name.'Sign ctermfg='.sign_colors[suffix][0].' guifg='.sign_colors[suffix][1]
line 43: hi default CocHintSign ctermfg=Blue guifg=#15aabf
line 44:     endif
line 45:     if hlexists('DiagnosticVirtualText'.suffix)
line 46:       exe 'hi default link Coc'.name.'VirtualText DiagnosticVirtualText'.suffix
line 47:     else
line 48:       call s:CreateHighlight('Coc'.name.'VirtualText', 'Coc'.name.'Sign', 'Normal')
calling <SNR>46_CreateHighlight('CocHintVirtualText', 'CocHintSign', 'Normal')

line 1:   let cmd = coc#highlight#compose(a:fg, a:bg)
calling coc#highlight#compose('CocHintSign', 'Normal')

line 1:   let fgId = synIDtrans(hlID(a:fg))
line 2:   let bgId = synIDtrans(hlID(a:bg))
line 3:   let isGuiReversed = synIDattr(fgId, 'reverse', 'gui') !=# '1' || synIDattr(bgId, 'reverse', 'gui') !=# '1'
line 4:   let guifg = isGuiReversed ? synIDattr(fgId, 'fg', 'gui') : synIDattr(fgId, 'bg', 'gui')
line 5:   let guibg = isGuiReversed ? synIDattr(bgId, 'bg', 'gui') : synIDattr(bgId, 'fg', 'gui')
line 6:   let isCtermReversed = synIDattr(fgId, 'reverse', 'cterm') !=# '1' || synIDattr(bgId, 'reverse', 'cterm') !=# '1'
line 7:   let ctermfg = isCtermReversed ? synIDattr(fgId, 'fg', 'cterm') : synIDattr(fgId, 'bg', 'cterm')
line 8:   let ctermbg = isCtermReversed ? synIDattr(bgId, 'bg', 'cterm') : synIDattr(bgId, 'fg', 'cterm')
line 9:   let bold = synIDattr(fgId, 'bold') ==# '1'
line 10:   let italic = synIDattr(fgId, 'italic') ==# '1'
line 11:   let underline = synIDattr(fgId, 'underline') ==# '1'
line 12:   let cmd = ''
line 13:   if !empty(guifg)
line 14:     let cmd .= ' guifg=' . guifg
line 15:   endif
line 16:   if !empty(ctermfg)
line 17:     let cmd .= ' ctermfg=' . ctermfg
line 18:   elseif guifg =~# '^#'
line 19:     let cmd .= ' ctermfg=' . coc#color#rgb2term(strpart(guifg, 1))
line 20:   endif
line 21:   if !empty(guibg)
line 22:     let cmd .= ' guibg=' . guibg
line 23:   endif
line 24:   if !empty(ctermbg)
line 25:     let cmd .= ' ctermbg=' . ctermbg
line 26:   elseif guibg =~# '^#'
line 27:     let cmd .= ' ctermbg=' . coc#color#rgb2term(strpart(guibg, 1))
line 28:   endif
line 29:   if bold
line 30:     let cmd .= ' cterm=bold gui=bold'
line 31:   elseif italic
line 32:     let cmd .= ' cterm=italic gui=italic'
line 33:   elseif underline
line 34:     let cmd .= ' cterm=underline gui=underline'
line 35:   endif
line 36:   return cmd
coc#highlight#compose returning ' guifg=#15aabf ctermfg=12'

continuing in <SNR>46_CreateHighlight

line 2:   if !empty(trim(cmd))
line 3:     exe 'hi default '.a:group.' '.cmd
line 3: hi default CocHintVirtualText  guifg=#15aabf ctermfg=12
line 4:   else
line 5:     exe 'hi default link '.a:group.' '.a:fg
line 6:   endif
<SNR>46_CreateHighlight returning #0

continuing in <SNR>46_Highlight

line 49:     endif
line 50:     if hlexists('Diagnostic'.suffix)
line 51:       exe 'hi default link Coc'.name.'Float Diagnostic'.suffix
line 52:     else
line 53:       call s:CreateHighlight('Coc'.name.'Float', 'Coc'.name.'Sign', 'CocFloating')
calling <SNR>46_CreateHighlight('CocHintFloat', 'CocHintSign', 'CocFloating')

line 1:   let cmd = coc#highlight#compose(a:fg, a:bg)
calling coc#highlight#compose('CocHintSign', 'CocFloating')

line 1:   let fgId = synIDtrans(hlID(a:fg))
line 2:   let bgId = synIDtrans(hlID(a:bg))
line 3:   let isGuiReversed = synIDattr(fgId, 'reverse', 'gui') !=# '1' || synIDattr(bgId, 'reverse', 'gui') !=# '1'
line 4:   let guifg = isGuiReversed ? synIDattr(fgId, 'fg', 'gui') : synIDattr(fgId, 'bg', 'gui')
line 5:   let guibg = isGuiReversed ? synIDattr(bgId, 'bg', 'gui') : synIDattr(bgId, 'fg', 'gui')
line 6:   let isCtermReversed = synIDattr(fgId, 'reverse', 'cterm') !=# '1' || synIDattr(bgId, 'reverse', 'cterm') !=# '1'
line 7:   let ctermfg = isCtermReversed ? synIDattr(fgId, 'fg', 'cterm') : synIDattr(fgId, 'bg', 'cterm')
line 8:   let ctermbg = isCtermReversed ? synIDattr(bgId, 'bg', 'cterm') : synIDattr(bgId, 'fg', 'cterm')
line 9:   let bold = synIDattr(fgId, 'bold') ==# '1'
line 10:   let italic = synIDattr(fgId, 'italic') ==# '1'
line 11:   let underline = synIDattr(fgId, 'underline') ==# '1'
line 12:   let cmd = ''
line 13:   if !empty(guifg)
line 14:     let cmd .= ' guifg=' . guifg
line 15:   endif
line 16:   if !empty(ctermfg)
line 17:     let cmd .= ' ctermfg=' . ctermfg
line 18:   elseif guifg =~# '^#'
line 19:     let cmd .= ' ctermfg=' . coc#color#rgb2term(strpart(guifg, 1))
line 20:   endif
line 21:   if !empty(guibg)
line 22:     let cmd .= ' guibg=' . guibg
line 23:   endif
line 24:   if !empty(ctermbg)
line 25:     let cmd .= ' ctermbg=' . ctermbg
line 26:   elseif guibg =~# '^#'
line 27:     let cmd .= ' ctermbg=' . coc#color#rgb2term(strpart(guibg, 1))
line 28:   endif
line 29:   if bold
line 30:     let cmd .= ' cterm=bold gui=bold'
line 31:   elseif italic
line 32:     let cmd .= ' cterm=italic gui=italic'
line 33:   elseif underline
line 34:     let cmd .= ' cterm=underline gui=underline'
line 35:   endif
line 36:   return cmd
coc#highlight#compose returning ' guifg=#15aabf ctermfg=12 guibg=#414141 ctermbg=237'

continuing in <SNR>46_CreateHighlight

line 2:   if !empty(trim(cmd))
line 3:     exe 'hi default '.a:group.' '.cmd
line 3: hi default CocHintFloat  guifg=#15aabf ctermfg=12 guibg=#414141 ctermbg=237
line 4:   else
line 5:     exe 'hi default link '.a:group.' '.a:fg
line 6:   endif
<SNR>46_CreateHighlight returning #0

continuing in <SNR>46_Highlight

line 54:     endif
line 55:   endfor
line 33:   for name in ['Error', 'Warning', 'Info', 'Hint']
line 34:     let suffix = name ==# 'Warning' ? 'Warn' : name
line 35:     if hlexists('DiagnosticUnderline'.suffix)
line 36:       exe 'hi default link Coc'.name.'Highlight DiagnosticUnderline'.suffix
line 37:     else
line 38:       exe 'hi default link Coc'.name.'Highlight CocUnderline'
line 39:     endif
line 40:     if hlexists('DiagnosticSign'.suffix)
line 41:       exe 'hi default link Coc'.name.'Sign DiagnosticSign'.suffix
line 42:     else
line 43:       exe 'hi default Coc'.name.'Sign ctermfg='.sign_colors[suffix][0].' guifg='.sign_colors[suffix][1]
line 44:     endif
line 45:     if hlexists('DiagnosticVirtualText'.suffix)
line 46:       exe 'hi default link Coc'.name.'VirtualText DiagnosticVirtualText'.suffix
line 47:     else
line 48:       call s:CreateHighlight('Coc'.name.'VirtualText', 'Coc'.name.'Sign', 'Normal')
line 49:     endif
line 50:     if hlexists('Diagnostic'.suffix)
line 51:       exe 'hi default link Coc'.name.'Float Diagnostic'.suffix
line 52:     else
line 53:       call s:CreateHighlight('Coc'.name.'Float', 'Coc'.name.'Sign', 'CocFloating')
line 54:     endif
line 55:   endfor
line 56: 
line 57:   call s:CreateHighlight('CocInlayHint', 'CocHintSign', 'SignColumn')
calling <SNR>46_CreateHighlight('CocInlayHint', 'CocHintSign', 'SignColumn')

line 1:   let cmd = coc#highlight#compose(a:fg, a:bg)
calling coc#highlight#compose('CocHintSign', 'SignColumn')

line 1:   let fgId = synIDtrans(hlID(a:fg))
line 2:   let bgId = synIDtrans(hlID(a:bg))
line 3:   let isGuiReversed = synIDattr(fgId, 'reverse', 'gui') !=# '1' || synIDattr(bgId, 'reverse', 'gui') !=# '1'
line 4:   let guifg = isGuiReversed ? synIDattr(fgId, 'fg', 'gui') : synIDattr(fgId, 'bg', 'gui')
line 5:   let guibg = isGuiReversed ? synIDattr(bgId, 'bg', 'gui') : synIDattr(bgId, 'fg', 'gui')
line 6:   let isCtermReversed = synIDattr(fgId, 'reverse', 'cterm') !=# '1' || synIDattr(bgId, 'reverse', 'cterm') !=# '1'
line 7:   let ctermfg = isCtermReversed ? synIDattr(fgId, 'fg', 'cterm') : synIDattr(fgId, 'bg', 'cterm')
line 8:   let ctermbg = isCtermReversed ? synIDattr(bgId, 'bg', 'cterm') : synIDattr(bgId, 'fg', 'cterm')
line 9:   let bold = synIDattr(fgId, 'bold') ==# '1'
line 10:   let italic = synIDattr(fgId, 'italic') ==# '1'
line 11:   let underline = synIDattr(fgId, 'underline') ==# '1'
line 12:   let cmd = ''
line 13:   if !empty(guifg)
line 14:     let cmd .= ' guifg=' . guifg
line 15:   endif
line 16:   if !empty(ctermfg)
line 17:     let cmd .= ' ctermfg=' . ctermfg
line 18:   elseif guifg =~# '^#'
line 19:     let cmd .= ' ctermfg=' . coc#color#rgb2term(strpart(guifg, 1))
line 20:   endif
line 21:   if !empty(guibg)
line 22:     let cmd .= ' guibg=' . guibg
line 23:   endif
line 24:   if !empty(ctermbg)
line 25:     let cmd .= ' ctermbg=' . ctermbg
line 26:   elseif guibg =~# '^#'
line 27:     let cmd .= ' ctermbg=' . coc#color#rgb2term(strpart(guibg, 1))
line 28:   endif
line 29:   if bold
line 30:     let cmd .= ' cterm=bold gui=bold'
line 31:   elseif italic
line 32:     let cmd .= ' cterm=italic gui=italic'
line 33:   elseif underline
line 34:     let cmd .= ' cterm=underline gui=underline'
line 35:   endif
line 36:   return cmd
coc#highlight#compose returning ' guifg=#15aabf ctermfg=12'

continuing in <SNR>46_CreateHighlight

line 2:   if !empty(trim(cmd))
line 3:     exe 'hi default '.a:group.' '.cmd
line 3: hi default CocInlayHint  guifg=#15aabf ctermfg=12
line 4:   else
line 5:     exe 'hi default link '.a:group.' '.a:fg
line 6:   endif
<SNR>46_CreateHighlight returning #0

continuing in <SNR>46_Highlight

line 58:   for name in ['Parameter', 'Type']
line 59:     exe 'hi default link CocInlayHint'.name.' CocInlayHint'
line 59: hi default link CocInlayHintParameter CocInlayHint
line 60:   endfor
line 58:   for name in ['Parameter', 'Type']
line 59:     exe 'hi default link CocInlayHint'.name.' CocInlayHint'
line 59: hi default link CocInlayHintType CocInlayHint
line 60:   endfor
line 58:   for name in ['Parameter', 'Type']
line 59:     exe 'hi default link CocInlayHint'.name.' CocInlayHint'
line 60:   endfor
line 61: 
line 62:   if get(g:, 'coc_default_semantic_highlight_groups', 1)
line 63:     let hlMap = { 'TypeNamespace': ['@module', 'Include'], 'TypeType': ['@type', 'Type'], 'TypeClass': ['@constructor', 'Special'], 'TypeEnum': ['@type', 'Type'], 'TypeInterface': ['@type', 'Type'], 'TypeStruct': ['@structure', 'Identifier'], 'TypeTypeParameter': ['@variable.parameter', 'Identifier'], 'TypeParameter': ['@variable.parameter', 'Identifier'], 'TypeVariable': ['@variable', 'Identifier'], 'TypeProperty': ['@property', 'Identifier'], 'TypeEnumMember': ['@property', 'Constant'], 'TypeEvent': ['@keyword', 'Keyword'], 'TypeFunction': ['@function', 'Function'], 'TypeMethod': ['@function.method', 'Function'], 'TypeMacro': ['@constant.macro', 'Define'], 'TypeKeyword': ['@keyword', 'Keyword'], 'TypeModifier': ['@keyword.storage', 'StorageClass'], 'TypeComment': ['@comment', 'Comment'], 'TypeString': ['@string', 'String'], 'TypeNumber': ['@number', 'Number'], 'TypeBoolean': ['@boolean', 'Boolean'], 'TypeRegexp': ['@string.regexp', 'String'], 'TypeOperator': ['@operator', 'Operator'], 'TypeDecorato
line 90:     for [key, value] in items(hlMap)
line 91:       let ts = get(value, 0, '')
line 92:       let fallback = get(value, 1, '')
line 93:       execute 'hi default link CocSem'.key.' '.(coc#highlight#valid(ts) ? ts : fallback)
calling coc#highlight#valid('@constant.macro')

line 1:   return hlexists(a:hlGroup) && execute('hi '.a:hlGroup, 'silent!') !~# ' cleared$'
coc#highlight#valid returning #0

continuing in <SNR>46_Highlight

line 93: hi default link CocSemTypeMacro Define
line 94:     endfor
line 90:     for [key, value] in items(hlMap)
line 91:       let ts = get(value, 0, '')
line 92:       let fallback = get(value, 1, '')
line 93:       execute 'hi default link CocSem'.key.' '.(coc#highlight#valid(ts) ? ts : fallback)
calling coc#highlight#valid('@property')

line 1:   return hlexists(a:hlGroup) && execute('hi '.a:hlGroup, 'silent!') !~# ' cleared$'
coc#highlight#valid returning #0

continuing in <SNR>46_Highlight

line 93: hi default link CocSemTypeEnumMember Constant
line 94:     endfor
line 90:     for [key, value] in items(hlMap)
line 91:       let ts = get(value, 0, '')
line 92:       let fallback = get(value, 1, '')
line 93:       execute 'hi default link CocSem'.key.' '.(coc#highlight#valid(ts) ? ts : fallback)
calling coc#highlight#valid('@comment')

line 1:   return hlexists(a:hlGroup) && execute('hi '.a:hlGroup, 'silent!') !~# ' cleared$'
coc#highlight#valid returning #0

continuing in <SNR>46_Highlight

line 93: hi default link CocSemTypeComment Comment
line 94:     endfor
line 90:     for [key, value] in items(hlMap)
line 91:       let ts = get(value, 0, '')
line 92:       let fallback = get(value, 1, '')
line 93:       execute 'hi default link CocSem'.key.' '.(coc#highlight#valid(ts) ? ts : fallback)
calling coc#highlight#valid('@operator')

line 1:   return hlexists(a:hlGroup) && execute('hi '.a:hlGroup, 'silent!') !~# ' cleared$'
coc#highlight#valid returning #0

continuing in <SNR>46_Highlight

line 93: hi default link CocSemTypeOperator Operator
line 94:     endfor
line 90:     for [key, value] in items(hlMap)
line 91:       let ts = get(value, 0, '')
line 92:       let fallback = get(value, 1, '')
line 93:       execute 'hi default link CocSem'.key.' '.(coc#highlight#valid(ts) ? ts : fallback)
calling coc#highlight#valid('@property')

line 1:   return hlexists(a:hlGroup) && execute('hi '.a:hlGroup, 'silent!') !~# ' cleared$'
coc#highlight#valid returning #0

continuing in <SNR>46_Highlight

line 93: hi default link CocSemTypeProperty Identifier
line 94:     endfor
line 90:     for [key, value] in items(hlMap)
line 91:       let ts = get(value, 0, '')
line 92:       let fallback = get(value, 1, '')
line 93:       execute 'hi default link CocSem'.key.' '.(coc#highlight#valid(ts) ? ts : fallback)
calling coc#highlight#valid('@constructor')

line 1:   return hlexists(a:hlGroup) && execute('hi '.a:hlGroup, 'silent!') !~# ' cleared$'
coc#highlight#valid returning #0

continuing in <SNR>46_Highlight

line 93: hi default link CocSemTypeClass Special
line 94:     endfor
line 90:     for [key, value] in items(hlMap)
line 91:       let ts = get(value, 0, '')
line 92:       let fallback = get(value, 1, '')
line 93:       execute 'hi default link CocSem'.key.' '.(coc#highlight#valid(ts) ? ts : fallback)
calling coc#highlight#valid('@structure')

line 1:   return hlexists(a:hlGroup) && execute('hi '.a:hlGroup, 'silent!') !~# ' cleared$'
coc#highlight#valid returning #0

continuing in <SNR>46_Highlight

line 93: hi default link CocSemTypeStruct Identifier
line 94:     endfor
line 90:     for [key, value] in items(hlMap)
line 91:       let ts = get(value, 0, '')
line 92:       let fallback = get(value, 1, '')
line 93:       execute 'hi default link CocSem'.key.' '.(coc#highlight#valid(ts) ? ts : fallback)
calling coc#highlight#valid('@string.regexp')

line 1:   return hlexists(a:hlGroup) && execute('hi '.a:hlGroup, 'silent!') !~# ' cleared$'
coc#highlight#valid returning #0

continuing in <SNR>46_Highlight

line 93: hi default link CocSemTypeRegexp String
line 94:     endfor
line 90:     for [key, value] in items(hlMap)
line 91:       let ts = get(value, 0, '')
line 92:       let fallback = get(value, 1, '')
line 93:       execute 'hi default link CocSem'.key.' '.(coc#highlight#valid(ts) ? ts : fallback)
calling coc#highlight#valid('@boolean')

line 1:   return hlexists(a:hlGroup) && execute('hi '.a:hlGroup, 'silent!') !~# ' cleared$'
coc#highlight#valid returning #0

continuing in <SNR>46_Highlight

line 93: hi default link CocSemTypeBoolean Boolean
line 94:     endfor
line 90:     for [key, value] in items(hlMap)
line 91:       let ts = get(value, 0, '')
line 92:       let fallback = get(value, 1, '')
line 93:       execute 'hi default link CocSem'.key.' '.(coc#highlight#valid(ts) ? ts : fallback)
calling coc#highlight#valid('@function.method')

line 1:   return hlexists(a:hlGroup) && execute('hi '.a:hlGroup, 'silent!') !~# ' cleared$'
coc#highlight#valid returning #0

continuing in <SNR>46_Highlight

line 93: hi default link CocSemTypeMethod Function
line 94:     endfor
line 90:     for [key, value] in items(hlMap)
line 91:       let ts = get(value, 0, '')
line 92:       let fallback = get(value, 1, '')
line 93:       execute 'hi default link CocSem'.key.' '.(coc#highlight#valid(ts) ? ts : fallback)
calling coc#highlight#valid('@module')

line 1:   return hlexists(a:hlGroup) && execute('hi '.a:hlGroup, 'silent!') !~# ' cleared$'
coc#highlight#valid returning #0

continuing in <SNR>46_Highlight

line 93: hi default link CocSemTypeNamespace Include
line 94:     endfor
line 90:     for [key, value] in items(hlMap)
line 91:       let ts = get(value, 0, '')
line 92:       let fallback = get(value, 1, '')
line 93:       execute 'hi default link CocSem'.key.' '.(coc#highlight#valid(ts) ? ts : fallback)
calling coc#highlight#valid('@keyword.storage')

line 1:   return hlexists(a:hlGroup) && execute('hi '.a:hlGroup, 'silent!') !~# ' cleared$'
coc#highlight#valid returning #0

continuing in <SNR>46_Highlight

line 93: hi default link CocSemTypeModifier StorageClass
line 94:     endfor
line 90:     for [key, value] in items(hlMap)
line 91:       let ts = get(value, 0, '')
line 92:       let fallback = get(value, 1, '')
line 93:       execute 'hi default link CocSem'.key.' '.(coc#highlight#valid(ts) ? ts : fallback)
calling coc#highlight#valid('@number')

line 1:   return hlexists(a:hlGroup) && execute('hi '.a:hlGroup, 'silent!') !~# ' cleared$'
coc#highlight#valid returning #0

continuing in <SNR>46_Highlight

line 93: hi default link CocSemTypeNumber Number
line 94:     endfor
line 90:     for [key, value] in items(hlMap)
line 91:       let ts = get(value, 0, '')
line 92:       let fallback = get(value, 1, '')
line 93:       execute 'hi default link CocSem'.key.' '.(coc#highlight#valid(ts) ? ts : fallback)
calling coc#highlight#valid('@variable.parameter')

line 1:   return hlexists(a:hlGroup) && execute('hi '.a:hlGroup, 'silent!') !~# ' cleared$'
coc#highlight#valid returning #0

continuing in <SNR>46_Highlight

line 93: hi default link CocSemTypeTypeParameter Identifier
line 94:     endfor
line 90:     for [key, value] in items(hlMap)
line 91:       let ts = get(value, 0, '')
line 92:       let fallback = get(value, 1, '')
line 93:       execute 'hi default link CocSem'.key.' '.(coc#highlight#valid(ts) ? ts : fallback)
calling coc#highlight#valid('@keyword')

line 1:   return hlexists(a:hlGroup) && execute('hi '.a:hlGroup, 'silent!') !~# ' cleared$'
coc#highlight#valid returning #0

continuing in <SNR>46_Highlight

line 93: hi default link CocSemTypeKeyword Keyword
line 94:     endfor
line 90:     for [key, value] in items(hlMap)
line 91:       let ts = get(value, 0, '')
line 92:       let fallback = get(value, 1, '')
line 93:       execute 'hi default link CocSem'.key.' '.(coc#highlight#valid(ts) ? ts : fallback)
calling coc#highlight#valid('@markup.strikethrough')

line 1:   return hlexists(a:hlGroup) && execute('hi '.a:hlGroup, 'silent!') !~# ' cleared$'
coc#highlight#valid returning #0

continuing in <SNR>46_Highlight

line 93: hi default link CocSemModDeprecated CocDeprecatedHighlight
line 94:     endfor
line 90:     for [key, value] in items(hlMap)
line 91:       let ts = get(value, 0, '')
line 92:       let fallback = get(value, 1, '')
line 93:       execute 'hi default link CocSem'.key.' '.(coc#highlight#valid(ts) ? ts : fallback)
calling coc#highlight#valid('@function')

line 1:   return hlexists(a:hlGroup) && execute('hi '.a:hlGroup, 'silent!') !~# ' cleared$'
coc#highlight#valid returning #0

continuing in <SNR>46_Highlight

line 93: hi default link CocSemTypeFunction Function
line 94:     endfor
line 90:     for [key, value] in items(hlMap)
line 91:       let ts = get(value, 0, '')
line 92:       let fallback = get(value, 1, '')
line 93:       execute 'hi default link CocSem'.key.' '.(coc#highlight#valid(ts) ? ts : fallback)
calling coc#highlight#valid('@string.special.symbol')

line 1:   return hlexists(a:hlGroup) && execute('hi '.a:hlGroup, 'silent!') !~# ' cleared$'
coc#highlight#valid returning #0

continuing in <SNR>46_Highlight

line 93: hi default link CocSemTypeDecorator Identifier
line 94:     endfor
line 90:     for [key, value] in items(hlMap)
line 91:       let ts = get(value, 0, '')
line 92:       let fallback = get(value, 1, '')
line 93:       execute 'hi default link CocSem'.key.' '.(coc#highlight#valid(ts) ? ts : fallback)
calling coc#highlight#valid('@type')

line 1:   return hlexists(a:hlGroup) && execute('hi '.a:hlGroup, 'silent!') !~# ' cleared$'
coc#highlight#valid returning #0

continuing in <SNR>46_Highlight

line 93: hi default link CocSemTypeEnum Type
line 94:     endfor
line 90:     for [key, value] in items(hlMap)
line 91:       let ts = get(value, 0, '')
line 92:       let fallback = get(value, 1, '')
line 93:       execute 'hi default link CocSem'.key.' '.(coc#highlight#valid(ts) ? ts : fallback)
calling coc#highlight#valid('@variable.parameter')

line 1:   return hlexists(a:hlGroup) && execute('hi '.a:hlGroup, 'silent!') !~# ' cleared$'
coc#highlight#valid returning #0

continuing in <SNR>46_Highlight

line 93: hi default link CocSemTypeParameter Identifier
line 94:     endfor
line 90:     for [key, value] in items(hlMap)
line 91:       let ts = get(value, 0, '')
line 92:       let fallback = get(value, 1, '')
line 93:       execute 'hi default link CocSem'.key.' '.(coc#highlight#valid(ts) ? ts : fallback)
calling coc#highlight#valid('@type')

line 1:   return hlexists(a:hlGroup) && execute('hi '.a:hlGroup, 'silent!') !~# ' cleared$'
coc#highlight#valid returning #0

continuing in <SNR>46_Highlight

line 93: hi default link CocSemTypeType Type
line 94:     endfor
line 90:     for [key, value] in items(hlMap)
line 91:       let ts = get(value, 0, '')
line 92:       let fallback = get(value, 1, '')
line 93:       execute 'hi default link CocSem'.key.' '.(coc#highlight#valid(ts) ? ts : fallback)
calling coc#highlight#valid('@string')

line 1:   return hlexists(a:hlGroup) && execute('hi '.a:hlGroup, 'silent!') !~# ' cleared$'
coc#highlight#valid returning #0

continuing in <SNR>46_Highlight

line 93: hi default link CocSemTypeString String
line 94:     endfor
line 90:     for [key, value] in items(hlMap)
line 91:       let ts = get(value, 0, '')
line 92:       let fallback = get(value, 1, '')
line 93:       execute 'hi default link CocSem'.key.' '.(coc#highlight#valid(ts) ? ts : fallback)
calling coc#highlight#valid('@variable')

line 1:   return hlexists(a:hlGroup) && execute('hi '.a:hlGroup, 'silent!') !~# ' cleared$'
coc#highlight#valid returning #0

continuing in <SNR>46_Highlight

line 93: hi default link CocSemTypeVariable Identifier
line 94:     endfor
line 90:     for [key, value] in items(hlMap)
line 91:       let ts = get(value, 0, '')
line 92:       let fallback = get(value, 1, '')
line 93:       execute 'hi default link CocSem'.key.' '.(coc#highlight#valid(ts) ? ts : fallback)
calling coc#highlight#valid('@type')

line 1:   return hlexists(a:hlGroup) && execute('hi '.a:hlGroup, 'silent!') !~# ' cleared$'
coc#highlight#valid returning #0

continuing in <SNR>46_Highlight

line 93: hi default link CocSemTypeInterface Type
line 94:     endfor
line 90:     for [key, value] in items(hlMap)
line 91:       let ts = get(value, 0, '')
line 92:       let fallback = get(value, 1, '')
line 93:       execute 'hi default link CocSem'.key.' '.(coc#highlight#valid(ts) ? ts : fallback)
calling coc#highlight#valid('@keyword')

line 1:   return hlexists(a:hlGroup) && execute('hi '.a:hlGroup, 'silent!') !~# ' cleared$'
coc#highlight#valid returning #0

continuing in <SNR>46_Highlight

line 93: hi default link CocSemTypeEvent Keyword
line 94:     endfor
line 90:     for [key, value] in items(hlMap)
line 91:       let ts = get(value, 0, '')
line 92:       let fallback = get(value, 1, '')
line 93:       execute 'hi default link CocSem'.key.' '.(coc#highlight#valid(ts) ? ts : fallback)
line 94:     endfor
line 95:   endif
line 96:   let symbolMap = { 'Keyword': ['@keyword', 'Keyword'], 'Namespace': ['@module', 'Include'], 'Class': ['@constructor', 'Special'], 'Method': ['@method', 'Function'], 'Property': ['@property', 'Identifier'], 'Text': ['@text', 'CocSymbolDefault'], 'Unit': ['@unit', 'CocSymbolDefault'], 'Value': ['@value', 'CocSymbolDefault'], 'Snippet': ['@snippet', 'CocSymbolDefault'], 'Color': ['@color', 'Float'], 'Reference': ['@text.reference', 'Constant'], 'Folder': ['@folder', 'CocSymbolDefault'], 'File': ['@file', 'Statement'], 'Module': ['@module', 'Statement'], 'Package': ['@package', 'Statement'], 'Field': ['@variable.member', 'Identifier'], 'Constructor': ['@constructor', 'Special'], 'Enum': ['@type', 'CocSymbolDefault'], 'Interface': ['@type', 'CocSymbolDefault'], 'Function': ['@function', 'Function'], 'Variable': ['@variable.builtin', 'Special'], 'Constant': ['@constant', 'Constant'], 'String': ['@string', 'String'], 'Number': ['@number', 'Number'], 'Boolean': ['@boolean', 'Boolean'], 'Array': ['@array', '
line 132:   for [key, value] in items(symbolMap)
line 133:     let hlGroup = coc#highlight#valid(value[0]) ? value[0] : get(value, 1, 'CocSymbolDefault')
calling coc#highlight#valid('@unit')

line 1:   return hlexists(a:hlGroup) && execute('hi '.a:hlGroup, 'silent!') !~# ' cleared$'
coc#highlight#valid returning #0

continuing in <SNR>46_Highlight

line 134:     if hlexists(hlGroup)
line 135:       execute 'hi default CocSymbol'.key.' '.coc#highlight#get_hl_command(synIDtrans(hlID(hlGroup)), 'fg', '223', '#ebdbb2')
calling coc#highlight#get_hl_command(9, 'fg', '223', '#ebdbb2')

line 1:   let cterm = coc#highlight#get_color(a:id, a:key, 'cterm')
calling coc#highlight#get_color(9, 'fg', 'cterm')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning '188'

continuing in coc#highlight#get_hl_command

line 2:   let gui = coc#highlight#get_color(a:id, a:key, 'gui')
calling coc#highlight#get_color(9, 'fg', 'gui')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning '#dcdfe4'

continuing in coc#highlight#get_hl_command

line 3:   let cmd = ' cterm'.a:key.'=' . (empty(cterm) ? a:cterm : cterm)
line 4:   let cmd .= ' gui'.a:key.'=' . (empty(gui) ? a:gui : gui)
line 5:   return cmd
coc#highlight#get_hl_command returning ' ctermfg=188 guifg=#dcdfe4'

continuing in <SNR>46_Highlight

line 135: hi default CocSymbolUnit  ctermfg=188 guifg=#dcdfe4
line 136:     endif
line 137:   endfor
line 132:   for [key, value] in items(symbolMap)
line 133:     let hlGroup = coc#highlight#valid(value[0]) ? value[0] : get(value, 1, 'CocSymbolDefault')
calling coc#highlight#valid('@number')

line 1:   return hlexists(a:hlGroup) && execute('hi '.a:hlGroup, 'silent!') !~# ' cleared$'
coc#highlight#valid returning #0

continuing in <SNR>46_Highlight

line 134:     if hlexists(hlGroup)
line 135:       execute 'hi default CocSymbol'.key.' '.coc#highlight#get_hl_command(synIDtrans(hlID(hlGroup)), 'fg', '223', '#ebdbb2')
calling coc#highlight#get_hl_command(81, 'fg', '223', '#ebdbb2')

line 1:   let cterm = coc#highlight#get_color(a:id, a:key, 'cterm')
calling coc#highlight#get_color(81, 'fg', 'cterm')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning '180'

continuing in coc#highlight#get_hl_command

line 2:   let gui = coc#highlight#get_color(a:id, a:key, 'gui')
calling coc#highlight#get_color(81, 'fg', 'gui')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning '#e5c07b'

continuing in coc#highlight#get_hl_command

line 3:   let cmd = ' cterm'.a:key.'=' . (empty(cterm) ? a:cterm : cterm)
line 4:   let cmd .= ' gui'.a:key.'=' . (empty(gui) ? a:gui : gui)
line 5:   return cmd
coc#highlight#get_hl_command returning ' ctermfg=180 guifg=#e5c07b'

continuing in <SNR>46_Highlight

line 135: hi default CocSymbolNumber  ctermfg=180 guifg=#e5c07b
line 136:     endif
line 137:   endfor
line 132:   for [key, value] in items(symbolMap)
line 133:     let hlGroup = coc#highlight#valid(value[0]) ? value[0] : get(value, 1, 'CocSymbolDefault')
calling coc#highlight#valid('@function')

line 1:   return hlexists(a:hlGroup) && execute('hi '.a:hlGroup, 'silent!') !~# ' cleared$'
coc#highlight#valid returning #0

continuing in <SNR>46_Highlight

line 134:     if hlexists(hlGroup)
line 135:       execute 'hi default CocSymbol'.key.' '.coc#highlight#get_hl_command(synIDtrans(hlID(hlGroup)), 'fg', '223', '#ebdbb2')
calling coc#highlight#get_hl_command(84, 'fg', '223', '#ebdbb2')

line 1:   let cterm = coc#highlight#get_color(a:id, a:key, 'cterm')
calling coc#highlight#get_color(84, 'fg', 'cterm')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning '75'

continuing in coc#highlight#get_hl_command

line 2:   let gui = coc#highlight#get_color(a:id, a:key, 'gui')
calling coc#highlight#get_color(84, 'fg', 'gui')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning '#61afef'

continuing in coc#highlight#get_hl_command

line 3:   let cmd = ' cterm'.a:key.'=' . (empty(cterm) ? a:cterm : cterm)
line 4:   let cmd .= ' gui'.a:key.'=' . (empty(gui) ? a:gui : gui)
line 5:   return cmd
coc#highlight#get_hl_command returning ' ctermfg=75 guifg=#61afef'

continuing in <SNR>46_Highlight

line 135: hi default CocSymbolFunction  ctermfg=75 guifg=#61afef
line 136:     endif
line 137:   endfor
line 132:   for [key, value] in items(symbolMap)
line 133:     let hlGroup = coc#highlight#valid(value[0]) ? value[0] : get(value, 1, 'CocSymbolDefault')
calling coc#highlight#valid('@key')

line 1:   return hlexists(a:hlGroup) && execute('hi '.a:hlGroup, 'silent!') !~# ' cleared$'
coc#highlight#valid returning #0

continuing in <SNR>46_Highlight

line 134:     if hlexists(hlGroup)
line 135:       execute 'hi default CocSymbol'.key.' '.coc#highlight#get_hl_command(synIDtrans(hlID(hlGroup)), 'fg', '223', '#ebdbb2')
calling coc#highlight#get_hl_command(68, 'fg', '223', '#ebdbb2')

line 1:   let cterm = coc#highlight#get_color(a:id, a:key, 'cterm')
calling coc#highlight#get_color(68, 'fg', 'cterm')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning '168'

continuing in coc#highlight#get_hl_command

line 2:   let gui = coc#highlight#get_color(a:id, a:key, 'gui')
calling coc#highlight#get_color(68, 'fg', 'gui')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning '#e06c75'

continuing in coc#highlight#get_hl_command

line 3:   let cmd = ' cterm'.a:key.'=' . (empty(cterm) ? a:cterm : cterm)
line 4:   let cmd .= ' gui'.a:key.'=' . (empty(gui) ? a:gui : gui)
line 5:   return cmd
coc#highlight#get_hl_command returning ' ctermfg=168 guifg=#e06c75'

continuing in <SNR>46_Highlight

line 135: hi default CocSymbolKey  ctermfg=168 guifg=#e06c75
line 136:     endif
line 137:   endfor
line 132:   for [key, value] in items(symbolMap)
line 133:     let hlGroup = coc#highlight#valid(value[0]) ? value[0] : get(value, 1, 'CocSymbolDefault')
calling coc#highlight#valid('@keyword')

line 1:   return hlexists(a:hlGroup) && execute('hi '.a:hlGroup, 'silent!') !~# ' cleared$'
coc#highlight#valid returning #0

continuing in <SNR>46_Highlight

line 134:     if hlexists(hlGroup)
line 135:       execute 'hi default CocSymbol'.key.' '.coc#highlight#get_hl_command(synIDtrans(hlID(hlGroup)), 'fg', '223', '#ebdbb2')
calling coc#highlight#get_hl_command(89, 'fg', '223', '#ebdbb2')

line 1:   let cterm = coc#highlight#get_color(a:id, a:key, 'cterm')
calling coc#highlight#get_color(89, 'fg', 'cterm')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning '168'

continuing in coc#highlight#get_hl_command

line 2:   let gui = coc#highlight#get_color(a:id, a:key, 'gui')
calling coc#highlight#get_color(89, 'fg', 'gui')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning '#e06c75'

continuing in coc#highlight#get_hl_command

line 3:   let cmd = ' cterm'.a:key.'=' . (empty(cterm) ? a:cterm : cterm)
line 4:   let cmd .= ' gui'.a:key.'=' . (empty(gui) ? a:gui : gui)
line 5:   return cmd
coc#highlight#get_hl_command returning ' ctermfg=168 guifg=#e06c75'

continuing in <SNR>46_Highlight

line 135: hi default CocSymbolKeyword  ctermfg=168 guifg=#e06c75
line 136:     endif
line 137:   endfor
line 132:   for [key, value] in items(symbolMap)
line 133:     let hlGroup = coc#highlight#valid(value[0]) ? value[0] : get(value, 1, 'CocSymbolDefault')
calling coc#highlight#valid('@text.reference')

line 1:   return hlexists(a:hlGroup) && execute('hi '.a:hlGroup, 'silent!') !~# ' cleared$'
coc#highlight#valid returning #0

continuing in <SNR>46_Highlight

line 134:     if hlexists(hlGroup)
line 135:       execute 'hi default CocSymbol'.key.' '.coc#highlight#get_hl_command(synIDtrans(hlID(hlGroup)), 'fg', '223', '#ebdbb2')
calling coc#highlight#get_hl_command(66, 'fg', '223', '#ebdbb2')

line 1:   let cterm = coc#highlight#get_color(a:id, a:key, 'cterm')
calling coc#highlight#get_color(66, 'fg', 'cterm')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning '73'

continuing in coc#highlight#get_hl_command

line 2:   let gui = coc#highlight#get_color(a:id, a:key, 'gui')
calling coc#highlight#get_color(66, 'fg', 'gui')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning '#56b6c2'

continuing in coc#highlight#get_hl_command

line 3:   let cmd = ' cterm'.a:key.'=' . (empty(cterm) ? a:cterm : cterm)
line 4:   let cmd .= ' gui'.a:key.'=' . (empty(gui) ? a:gui : gui)
line 5:   return cmd
coc#highlight#get_hl_command returning ' ctermfg=73 guifg=#56b6c2'

continuing in <SNR>46_Highlight

line 135: hi default CocSymbolReference  ctermfg=73 guifg=#56b6c2
line 136:     endif
line 137:   endfor
line 132:   for [key, value] in items(symbolMap)
line 133:     let hlGroup = coc#highlight#valid(value[0]) ? value[0] : get(value, 1, 'CocSymbolDefault')
calling coc#highlight#valid('@folder')

line 1:   return hlexists(a:hlGroup) && execute('hi '.a:hlGroup, 'silent!') !~# ' cleared$'
coc#highlight#valid returning #0

continuing in <SNR>46_Highlight

line 134:     if hlexists(hlGroup)
line 135:       execute 'hi default CocSymbol'.key.' '.coc#highlight#get_hl_command(synIDtrans(hlID(hlGroup)), 'fg', '223', '#ebdbb2')
calling coc#highlight#get_hl_command(9, 'fg', '223', '#ebdbb2')

line 1:   let cterm = coc#highlight#get_color(a:id, a:key, 'cterm')
calling coc#highlight#get_color(9, 'fg', 'cterm')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning '188'

continuing in coc#highlight#get_hl_command

line 2:   let gui = coc#highlight#get_color(a:id, a:key, 'gui')
calling coc#highlight#get_color(9, 'fg', 'gui')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning '#dcdfe4'

continuing in coc#highlight#get_hl_command

line 3:   let cmd = ' cterm'.a:key.'=' . (empty(cterm) ? a:cterm : cterm)
line 4:   let cmd .= ' gui'.a:key.'=' . (empty(gui) ? a:gui : gui)
line 5:   return cmd
coc#highlight#get_hl_command returning ' ctermfg=188 guifg=#dcdfe4'

continuing in <SNR>46_Highlight

line 135: hi default CocSymbolFolder  ctermfg=188 guifg=#dcdfe4
line 136:     endif
line 137:   endfor
line 132:   for [key, value] in items(symbolMap)
line 133:     let hlGroup = coc#highlight#valid(value[0]) ? value[0] : get(value, 1, 'CocSymbolDefault')
calling coc#highlight#valid('@variable.builtin')

line 1:   return hlexists(a:hlGroup) && execute('hi '.a:hlGroup, 'silent!') !~# ' cleared$'
coc#highlight#valid returning #0

continuing in <SNR>46_Highlight

line 134:     if hlexists(hlGroup)
line 135:       execute 'hi default CocSymbol'.key.' '.coc#highlight#get_hl_command(synIDtrans(hlID(hlGroup)), 'fg', '223', '#ebdbb2')
calling coc#highlight#get_hl_command(67, 'fg', '223', '#ebdbb2')

line 1:   let cterm = coc#highlight#get_color(a:id, a:key, 'cterm')
calling coc#highlight#get_color(67, 'fg', 'cterm')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning '75'

continuing in coc#highlight#get_hl_command

line 2:   let gui = coc#highlight#get_color(a:id, a:key, 'gui')
calling coc#highlight#get_color(67, 'fg', 'gui')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning '#61afef'

continuing in coc#highlight#get_hl_command

line 3:   let cmd = ' cterm'.a:key.'=' . (empty(cterm) ? a:cterm : cterm)
line 4:   let cmd .= ' gui'.a:key.'=' . (empty(gui) ? a:gui : gui)
line 5:   return cmd
coc#highlight#get_hl_command returning ' ctermfg=75 guifg=#61afef'

continuing in <SNR>46_Highlight

line 135: hi default CocSymbolVariable  ctermfg=75 guifg=#61afef
line 136:     endif
line 137:   endfor
line 132:   for [key, value] in items(symbolMap)
line 133:     let hlGroup = coc#highlight#valid(value[0]) ? value[0] : get(value, 1, 'CocSymbolDefault')
calling coc#highlight#valid('@null')

line 1:   return hlexists(a:hlGroup) && execute('hi '.a:hlGroup, 'silent!') !~# ' cleared$'
coc#highlight#valid returning #0

continuing in <SNR>46_Highlight

line 134:     if hlexists(hlGroup)
line 135:       execute 'hi default CocSymbol'.key.' '.coc#highlight#get_hl_command(synIDtrans(hlID(hlGroup)), 'fg', '223', '#ebdbb2')
calling coc#highlight#get_hl_command(71, 'fg', '223', '#ebdbb2')

line 1:   let cterm = coc#highlight#get_color(a:id, a:key, 'cterm')
calling coc#highlight#get_color(71, 'fg', 'cterm')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning '180'

continuing in coc#highlight#get_hl_command

line 2:   let gui = coc#highlight#get_color(a:id, a:key, 'gui')
calling coc#highlight#get_color(71, 'fg', 'gui')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning '#e5c07b'

continuing in coc#highlight#get_hl_command

line 3:   let cmd = ' cterm'.a:key.'=' . (empty(cterm) ? a:cterm : cterm)
line 4:   let cmd .= ' gui'.a:key.'=' . (empty(gui) ? a:gui : gui)
line 5:   return cmd
coc#highlight#get_hl_command returning ' ctermfg=180 guifg=#e5c07b'

continuing in <SNR>46_Highlight

line 135: hi default CocSymbolNull  ctermfg=180 guifg=#e5c07b
line 136:     endif
line 137:   endfor
line 132:   for [key, value] in items(symbolMap)
line 133:     let hlGroup = coc#highlight#valid(value[0]) ? value[0] : get(value, 1, 'CocSymbolDefault')
calling coc#highlight#valid('@value')

line 1:   return hlexists(a:hlGroup) && execute('hi '.a:hlGroup, 'silent!') !~# ' cleared$'
coc#highlight#valid returning #0

continuing in <SNR>46_Highlight

line 134:     if hlexists(hlGroup)
line 135:       execute 'hi default CocSymbol'.key.' '.coc#highlight#get_hl_command(synIDtrans(hlID(hlGroup)), 'fg', '223', '#ebdbb2')
calling coc#highlight#get_hl_command(9, 'fg', '223', '#ebdbb2')

line 1:   let cterm = coc#highlight#get_color(a:id, a:key, 'cterm')
calling coc#highlight#get_color(9, 'fg', 'cterm')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning '188'

continuing in coc#highlight#get_hl_command

line 2:   let gui = coc#highlight#get_color(a:id, a:key, 'gui')
calling coc#highlight#get_color(9, 'fg', 'gui')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning '#dcdfe4'

continuing in coc#highlight#get_hl_command

line 3:   let cmd = ' cterm'.a:key.'=' . (empty(cterm) ? a:cterm : cterm)
line 4:   let cmd .= ' gui'.a:key.'=' . (empty(gui) ? a:gui : gui)
line 5:   return cmd
coc#highlight#get_hl_command returning ' ctermfg=188 guifg=#dcdfe4'

continuing in <SNR>46_Highlight

line 135: hi default CocSymbolValue  ctermfg=188 guifg=#dcdfe4
line 136:     endif
line 137:   endfor
line 132:   for [key, value] in items(symbolMap)
line 133:     let hlGroup = coc#highlight#valid(value[0]) ? value[0] : get(value, 1, 'CocSymbolDefault')
calling coc#highlight#valid('@constant')

line 1:   return hlexists(a:hlGroup) && execute('hi '.a:hlGroup, 'silent!') !~# ' cleared$'
coc#highlight#valid returning #0

continuing in <SNR>46_Highlight

line 134:     if hlexists(hlGroup)
line 135:       execute 'hi default CocSymbol'.key.' '.coc#highlight#get_hl_command(synIDtrans(hlID(hlGroup)), 'fg', '223', '#ebdbb2')
calling coc#highlight#get_hl_command(66, 'fg', '223', '#ebdbb2')

line 1:   let cterm = coc#highlight#get_color(a:id, a:key, 'cterm')
calling coc#highlight#get_color(66, 'fg', 'cterm')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning '73'

continuing in coc#highlight#get_hl_command

line 2:   let gui = coc#highlight#get_color(a:id, a:key, 'gui')
calling coc#highlight#get_color(66, 'fg', 'gui')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning '#56b6c2'

continuing in coc#highlight#get_hl_command

line 3:   let cmd = ' cterm'.a:key.'=' . (empty(cterm) ? a:cterm : cterm)
line 4:   let cmd .= ' gui'.a:key.'=' . (empty(gui) ? a:gui : gui)
line 5:   return cmd
coc#highlight#get_hl_command returning ' ctermfg=73 guifg=#56b6c2'

continuing in <SNR>46_Highlight

line 135: hi default CocSymbolConstant  ctermfg=73 guifg=#56b6c2
line 136:     endif
line 137:   endfor
line 132:   for [key, value] in items(symbolMap)
line 133:     let hlGroup = coc#highlight#valid(value[0]) ? value[0] : get(value, 1, 'CocSymbolDefault')
calling coc#highlight#valid('@text')

line 1:   return hlexists(a:hlGroup) && execute('hi '.a:hlGroup, 'silent!') !~# ' cleared$'
coc#highlight#valid returning #0

continuing in <SNR>46_Highlight

line 134:     if hlexists(hlGroup)
line 135:       execute 'hi default CocSymbol'.key.' '.coc#highlight#get_hl_command(synIDtrans(hlID(hlGroup)), 'fg', '223', '#ebdbb2')
calling coc#highlight#get_hl_command(9, 'fg', '223', '#ebdbb2')

line 1:   let cterm = coc#highlight#get_color(a:id, a:key, 'cterm')
calling coc#highlight#get_color(9, 'fg', 'cterm')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning '188'

continuing in coc#highlight#get_hl_command

line 2:   let gui = coc#highlight#get_color(a:id, a:key, 'gui')
calling coc#highlight#get_color(9, 'fg', 'gui')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning '#dcdfe4'

continuing in coc#highlight#get_hl_command

line 3:   let cmd = ' cterm'.a:key.'=' . (empty(cterm) ? a:cterm : cterm)
line 4:   let cmd .= ' gui'.a:key.'=' . (empty(gui) ? a:gui : gui)
line 5:   return cmd
coc#highlight#get_hl_command returning ' ctermfg=188 guifg=#dcdfe4'

continuing in <SNR>46_Highlight

line 135: hi default CocSymbolText  ctermfg=188 guifg=#dcdfe4
line 136:     endif
line 137:   endfor
line 132:   for [key, value] in items(symbolMap)
line 133:     let hlGroup = coc#highlight#valid(value[0]) ? value[0] : get(value, 1, 'CocSymbolDefault')
calling coc#highlight#valid('@module')

line 1:   return hlexists(a:hlGroup) && execute('hi '.a:hlGroup, 'silent!') !~# ' cleared$'
coc#highlight#valid returning #0

continuing in <SNR>46_Highlight

line 134:     if hlexists(hlGroup)
line 135:       execute 'hi default CocSymbol'.key.' '.coc#highlight#get_hl_command(synIDtrans(hlID(hlGroup)), 'fg', '223', '#ebdbb2')
calling coc#highlight#get_hl_command(69, 'fg', '223', '#ebdbb2')

line 1:   let cterm = coc#highlight#get_color(a:id, a:key, 'cterm')
calling coc#highlight#get_color(69, 'fg', 'cterm')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning '176'

continuing in coc#highlight#get_hl_command

line 2:   let gui = coc#highlight#get_color(a:id, a:key, 'gui')
calling coc#highlight#get_color(69, 'fg', 'gui')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning '#c678dd'

continuing in coc#highlight#get_hl_command

line 3:   let cmd = ' cterm'.a:key.'=' . (empty(cterm) ? a:cterm : cterm)
line 4:   let cmd .= ' gui'.a:key.'=' . (empty(gui) ? a:gui : gui)
line 5:   return cmd
coc#highlight#get_hl_command returning ' ctermfg=176 guifg=#c678dd'

continuing in <SNR>46_Highlight

line 135: hi default CocSymbolModule  ctermfg=176 guifg=#c678dd
line 136:     endif
line 137:   endfor
line 132:   for [key, value] in items(symbolMap)
line 133:     let hlGroup = coc#highlight#valid(value[0]) ? value[0] : get(value, 1, 'CocSymbolDefault')
calling coc#highlight#valid('@package')

line 1:   return hlexists(a:hlGroup) && execute('hi '.a:hlGroup, 'silent!') !~# ' cleared$'
coc#highlight#valid returning #0

continuing in <SNR>46_Highlight

line 134:     if hlexists(hlGroup)
line 135:       execute 'hi default CocSymbol'.key.' '.coc#highlight#get_hl_command(synIDtrans(hlID(hlGroup)), 'fg', '223', '#ebdbb2')
calling coc#highlight#get_hl_command(69, 'fg', '223', '#ebdbb2')

line 1:   let cterm = coc#highlight#get_color(a:id, a:key, 'cterm')
calling coc#highlight#get_color(69, 'fg', 'cterm')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning '176'

continuing in coc#highlight#get_hl_command

line 2:   let gui = coc#highlight#get_color(a:id, a:key, 'gui')
calling coc#highlight#get_color(69, 'fg', 'gui')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning '#c678dd'

continuing in coc#highlight#get_hl_command

line 3:   let cmd = ' cterm'.a:key.'=' . (empty(cterm) ? a:cterm : cterm)
line 4:   let cmd .= ' gui'.a:key.'=' . (empty(gui) ? a:gui : gui)
line 5:   return cmd
coc#highlight#get_hl_command returning ' ctermfg=176 guifg=#c678dd'

continuing in <SNR>46_Highlight

line 135: hi default CocSymbolPackage  ctermfg=176 guifg=#c678dd
line 136:     endif
line 137:   endfor
line 132:   for [key, value] in items(symbolMap)
line 133:     let hlGroup = coc#highlight#valid(value[0]) ? value[0] : get(value, 1, 'CocSymbolDefault')
calling coc#highlight#valid('@constructor')

line 1:   return hlexists(a:hlGroup) && execute('hi '.a:hlGroup, 'silent!') !~# ' cleared$'
coc#highlight#valid returning #0

continuing in <SNR>46_Highlight

line 134:     if hlexists(hlGroup)
line 135:       execute 'hi default CocSymbol'.key.' '.coc#highlight#get_hl_command(synIDtrans(hlID(hlGroup)), 'fg', '223', '#ebdbb2')
calling coc#highlight#get_hl_command(67, 'fg', '223', '#ebdbb2')

line 1:   let cterm = coc#highlight#get_color(a:id, a:key, 'cterm')
calling coc#highlight#get_color(67, 'fg', 'cterm')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning '75'

continuing in coc#highlight#get_hl_command

line 2:   let gui = coc#highlight#get_color(a:id, a:key, 'gui')
calling coc#highlight#get_color(67, 'fg', 'gui')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning '#61afef'

continuing in coc#highlight#get_hl_command

line 3:   let cmd = ' cterm'.a:key.'=' . (empty(cterm) ? a:cterm : cterm)
line 4:   let cmd .= ' gui'.a:key.'=' . (empty(gui) ? a:gui : gui)
line 5:   return cmd
coc#highlight#get_hl_command returning ' ctermfg=75 guifg=#61afef'

continuing in <SNR>46_Highlight

line 135: hi default CocSymbolClass  ctermfg=75 guifg=#61afef
line 136:     endif
line 137:   endfor
line 132:   for [key, value] in items(symbolMap)
line 133:     let hlGroup = coc#highlight#valid(value[0]) ? value[0] : get(value, 1, 'CocSymbolDefault')
calling coc#highlight#valid('@operator')

line 1:   return hlexists(a:hlGroup) && execute('hi '.a:hlGroup, 'silent!') !~# ' cleared$'
coc#highlight#valid returning #0

continuing in <SNR>46_Highlight

line 134:     if hlexists(hlGroup)
line 135:       execute 'hi default CocSymbol'.key.' '.coc#highlight#get_hl_command(synIDtrans(hlID(hlGroup)), 'fg', '223', '#ebdbb2')
calling coc#highlight#get_hl_command(88, 'fg', '223', '#ebdbb2')

line 1:   let cterm = coc#highlight#get_color(a:id, a:key, 'cterm')
calling coc#highlight#get_color(88, 'fg', 'cterm')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning '188'

continuing in coc#highlight#get_hl_command

line 2:   let gui = coc#highlight#get_color(a:id, a:key, 'gui')
calling coc#highlight#get_color(88, 'fg', 'gui')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning '#dcdfe4'

continuing in coc#highlight#get_hl_command

line 3:   let cmd = ' cterm'.a:key.'=' . (empty(cterm) ? a:cterm : cterm)
line 4:   let cmd .= ' gui'.a:key.'=' . (empty(gui) ? a:gui : gui)
line 5:   return cmd
coc#highlight#get_hl_command returning ' ctermfg=188 guifg=#dcdfe4'

continuing in <SNR>46_Highlight

line 135: hi default CocSymbolOperator  ctermfg=188 guifg=#dcdfe4
line 136:     endif
line 137:   endfor
line 132:   for [key, value] in items(symbolMap)
line 133:     let hlGroup = coc#highlight#valid(value[0]) ? value[0] : get(value, 1, 'CocSymbolDefault')
calling coc#highlight#valid('@structure')

line 1:   return hlexists(a:hlGroup) && execute('hi '.a:hlGroup, 'silent!') !~# ' cleared$'
coc#highlight#valid returning #0

continuing in <SNR>46_Highlight

line 134:     if hlexists(hlGroup)
line 135:       execute 'hi default CocSymbol'.key.' '.coc#highlight#get_hl_command(synIDtrans(hlID(hlGroup)), 'fg', '223', '#ebdbb2')
calling coc#highlight#get_hl_command(89, 'fg', '223', '#ebdbb2')

line 1:   let cterm = coc#highlight#get_color(a:id, a:key, 'cterm')
calling coc#highlight#get_color(89, 'fg', 'cterm')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning '168'

continuing in coc#highlight#get_hl_command

line 2:   let gui = coc#highlight#get_color(a:id, a:key, 'gui')
calling coc#highlight#get_color(89, 'fg', 'gui')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning '#e06c75'

continuing in coc#highlight#get_hl_command

line 3:   let cmd = ' cterm'.a:key.'=' . (empty(cterm) ? a:cterm : cterm)
line 4:   let cmd .= ' gui'.a:key.'=' . (empty(gui) ? a:gui : gui)
line 5:   return cmd
coc#highlight#get_hl_command returning ' ctermfg=168 guifg=#e06c75'

continuing in <SNR>46_Highlight

line 135: hi default CocSymbolStruct  ctermfg=168 guifg=#e06c75
line 136:     endif
line 137:   endfor
line 132:   for [key, value] in items(symbolMap)
line 133:     let hlGroup = coc#highlight#valid(value[0]) ? value[0] : get(value, 1, 'CocSymbolDefault')
calling coc#highlight#valid('@object')

line 1:   return hlexists(a:hlGroup) && execute('hi '.a:hlGroup, 'silent!') !~# ' cleared$'
coc#highlight#valid returning #0

continuing in <SNR>46_Highlight

line 134:     if hlexists(hlGroup)
line 135:       execute 'hi default CocSymbol'.key.' '.coc#highlight#get_hl_command(synIDtrans(hlID(hlGroup)), 'fg', '223', '#ebdbb2')
calling coc#highlight#get_hl_command(9, 'fg', '223', '#ebdbb2')

line 1:   let cterm = coc#highlight#get_color(a:id, a:key, 'cterm')
calling coc#highlight#get_color(9, 'fg', 'cterm')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning '188'

continuing in coc#highlight#get_hl_command

line 2:   let gui = coc#highlight#get_color(a:id, a:key, 'gui')
calling coc#highlight#get_color(9, 'fg', 'gui')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning '#dcdfe4'

continuing in coc#highlight#get_hl_command

line 3:   let cmd = ' cterm'.a:key.'=' . (empty(cterm) ? a:cterm : cterm)
line 4:   let cmd .= ' gui'.a:key.'=' . (empty(gui) ? a:gui : gui)
line 5:   return cmd
coc#highlight#get_hl_command returning ' ctermfg=188 guifg=#dcdfe4'

continuing in <SNR>46_Highlight

line 135: hi default CocSymbolObject  ctermfg=188 guifg=#dcdfe4
line 136:     endif
line 137:   endfor
line 132:   for [key, value] in items(symbolMap)
line 133:     let hlGroup = coc#highlight#valid(value[0]) ? value[0] : get(value, 1, 'CocSymbolDefault')
calling coc#highlight#valid('@method')

line 1:   return hlexists(a:hlGroup) && execute('hi '.a:hlGroup, 'silent!') !~# ' cleared$'
coc#highlight#valid returning #0

continuing in <SNR>46_Highlight

line 134:     if hlexists(hlGroup)
line 135:       execute 'hi default CocSymbol'.key.' '.coc#highlight#get_hl_command(synIDtrans(hlID(hlGroup)), 'fg', '223', '#ebdbb2')
calling coc#highlight#get_hl_command(84, 'fg', '223', '#ebdbb2')

line 1:   let cterm = coc#highlight#get_color(a:id, a:key, 'cterm')
calling coc#highlight#get_color(84, 'fg', 'cterm')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning '75'

continuing in coc#highlight#get_hl_command

line 2:   let gui = coc#highlight#get_color(a:id, a:key, 'gui')
calling coc#highlight#get_color(84, 'fg', 'gui')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning '#61afef'

continuing in coc#highlight#get_hl_command

line 3:   let cmd = ' cterm'.a:key.'=' . (empty(cterm) ? a:cterm : cterm)
line 4:   let cmd .= ' gui'.a:key.'=' . (empty(gui) ? a:gui : gui)
line 5:   return cmd
coc#highlight#get_hl_command returning ' ctermfg=75 guifg=#61afef'

continuing in <SNR>46_Highlight

line 135: hi default CocSymbolMethod  ctermfg=75 guifg=#61afef
line 136:     endif
line 137:   endfor
line 132:   for [key, value] in items(symbolMap)
line 133:     let hlGroup = coc#highlight#valid(value[0]) ? value[0] : get(value, 1, 'CocSymbolDefault')
calling coc#highlight#valid('@array')

line 1:   return hlexists(a:hlGroup) && execute('hi '.a:hlGroup, 'silent!') !~# ' cleared$'
coc#highlight#valid returning #0

continuing in <SNR>46_Highlight

line 134:     if hlexists(hlGroup)
line 135:       execute 'hi default CocSymbol'.key.' '.coc#highlight#get_hl_command(synIDtrans(hlID(hlGroup)), 'fg', '223', '#ebdbb2')
calling coc#highlight#get_hl_command(9, 'fg', '223', '#ebdbb2')

line 1:   let cterm = coc#highlight#get_color(a:id, a:key, 'cterm')
calling coc#highlight#get_color(9, 'fg', 'cterm')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning '188'

continuing in coc#highlight#get_hl_command

line 2:   let gui = coc#highlight#get_color(a:id, a:key, 'gui')
calling coc#highlight#get_color(9, 'fg', 'gui')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning '#dcdfe4'

continuing in coc#highlight#get_hl_command

line 3:   let cmd = ' cterm'.a:key.'=' . (empty(cterm) ? a:cterm : cterm)
line 4:   let cmd .= ' gui'.a:key.'=' . (empty(gui) ? a:gui : gui)
line 5:   return cmd
coc#highlight#get_hl_command returning ' ctermfg=188 guifg=#dcdfe4'

continuing in <SNR>46_Highlight

line 135: hi default CocSymbolArray  ctermfg=188 guifg=#dcdfe4
line 136:     endif
line 137:   endfor
line 132:   for [key, value] in items(symbolMap)
line 133:     let hlGroup = coc#highlight#valid(value[0]) ? value[0] : get(value, 1, 'CocSymbolDefault')
calling coc#highlight#valid('@type')

line 1:   return hlexists(a:hlGroup) && execute('hi '.a:hlGroup, 'silent!') !~# ' cleared$'
coc#highlight#valid returning #0

continuing in <SNR>46_Highlight

line 134:     if hlexists(hlGroup)
line 135:       execute 'hi default CocSymbol'.key.' '.coc#highlight#get_hl_command(synIDtrans(hlID(hlGroup)), 'fg', '223', '#ebdbb2')
calling coc#highlight#get_hl_command(9, 'fg', '223', '#ebdbb2')

line 1:   let cterm = coc#highlight#get_color(a:id, a:key, 'cterm')
calling coc#highlight#get_color(9, 'fg', 'cterm')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning '188'

continuing in coc#highlight#get_hl_command

line 2:   let gui = coc#highlight#get_color(a:id, a:key, 'gui')
calling coc#highlight#get_color(9, 'fg', 'gui')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning '#dcdfe4'

continuing in coc#highlight#get_hl_command

line 3:   let cmd = ' cterm'.a:key.'=' . (empty(cterm) ? a:cterm : cterm)
line 4:   let cmd .= ' gui'.a:key.'=' . (empty(gui) ? a:gui : gui)
line 5:   return cmd
coc#highlight#get_hl_command returning ' ctermfg=188 guifg=#dcdfe4'

continuing in <SNR>46_Highlight

line 135: hi default CocSymbolEnum  ctermfg=188 guifg=#dcdfe4
line 136:     endif
line 137:   endfor
line 132:   for [key, value] in items(symbolMap)
line 133:     let hlGroup = coc#highlight#valid(value[0]) ? value[0] : get(value, 1, 'CocSymbolDefault')
calling coc#highlight#valid('@variable.member')

line 1:   return hlexists(a:hlGroup) && execute('hi '.a:hlGroup, 'silent!') !~# ' cleared$'
coc#highlight#valid returning #0

continuing in <SNR>46_Highlight

line 134:     if hlexists(hlGroup)
line 135:       execute 'hi default CocSymbol'.key.' '.coc#highlight#get_hl_command(synIDtrans(hlID(hlGroup)), 'fg', '223', '#ebdbb2')
calling coc#highlight#get_hl_command(68, 'fg', '223', '#ebdbb2')

line 1:   let cterm = coc#highlight#get_color(a:id, a:key, 'cterm')
calling coc#highlight#get_color(68, 'fg', 'cterm')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning '168'

continuing in coc#highlight#get_hl_command

line 2:   let gui = coc#highlight#get_color(a:id, a:key, 'gui')
calling coc#highlight#get_color(68, 'fg', 'gui')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning '#e06c75'

continuing in coc#highlight#get_hl_command

line 3:   let cmd = ' cterm'.a:key.'=' . (empty(cterm) ? a:cterm : cterm)
line 4:   let cmd .= ' gui'.a:key.'=' . (empty(gui) ? a:gui : gui)
line 5:   return cmd
coc#highlight#get_hl_command returning ' ctermfg=168 guifg=#e06c75'

continuing in <SNR>46_Highlight

line 135: hi default CocSymbolField  ctermfg=168 guifg=#e06c75
line 136:     endif
line 137:   endfor
line 132:   for [key, value] in items(symbolMap)
line 133:     let hlGroup = coc#highlight#valid(value[0]) ? value[0] : get(value, 1, 'CocSymbolDefault')
calling coc#highlight#valid('@type')

line 1:   return hlexists(a:hlGroup) && execute('hi '.a:hlGroup, 'silent!') !~# ' cleared$'
coc#highlight#valid returning #0

continuing in <SNR>46_Highlight

line 134:     if hlexists(hlGroup)
line 135:       execute 'hi default CocSymbol'.key.' '.coc#highlight#get_hl_command(synIDtrans(hlID(hlGroup)), 'fg', '223', '#ebdbb2')
calling coc#highlight#get_hl_command(9, 'fg', '223', '#ebdbb2')

line 1:   let cterm = coc#highlight#get_color(a:id, a:key, 'cterm')
calling coc#highlight#get_color(9, 'fg', 'cterm')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning '188'

continuing in coc#highlight#get_hl_command

line 2:   let gui = coc#highlight#get_color(a:id, a:key, 'gui')
calling coc#highlight#get_color(9, 'fg', 'gui')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning '#dcdfe4'

continuing in coc#highlight#get_hl_command

line 3:   let cmd = ' cterm'.a:key.'=' . (empty(cterm) ? a:cterm : cterm)
line 4:   let cmd .= ' gui'.a:key.'=' . (empty(gui) ? a:gui : gui)
line 5:   return cmd
coc#highlight#get_hl_command returning ' ctermfg=188 guifg=#dcdfe4'

continuing in <SNR>46_Highlight

line 135: hi default CocSymbolInterface  ctermfg=188 guifg=#dcdfe4
line 136:     endif
line 137:   endfor
line 132:   for [key, value] in items(symbolMap)
line 133:     let hlGroup = coc#highlight#valid(value[0]) ? value[0] : get(value, 1, 'CocSymbolDefault')
calling coc#highlight#valid('@property')

line 1:   return hlexists(a:hlGroup) && execute('hi '.a:hlGroup, 'silent!') !~# ' cleared$'
coc#highlight#valid returning #0

continuing in <SNR>46_Highlight

line 134:     if hlexists(hlGroup)
line 135:       execute 'hi default CocSymbol'.key.' '.coc#highlight#get_hl_command(synIDtrans(hlID(hlGroup)), 'fg', '223', '#ebdbb2')
calling coc#highlight#get_hl_command(68, 'fg', '223', '#ebdbb2')

line 1:   let cterm = coc#highlight#get_color(a:id, a:key, 'cterm')
calling coc#highlight#get_color(68, 'fg', 'cterm')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning '168'

continuing in coc#highlight#get_hl_command

line 2:   let gui = coc#highlight#get_color(a:id, a:key, 'gui')
calling coc#highlight#get_color(68, 'fg', 'gui')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning '#e06c75'

continuing in coc#highlight#get_hl_command

line 3:   let cmd = ' cterm'.a:key.'=' . (empty(cterm) ? a:cterm : cterm)
line 4:   let cmd .= ' gui'.a:key.'=' . (empty(gui) ? a:gui : gui)
line 5:   return cmd
coc#highlight#get_hl_command returning ' ctermfg=168 guifg=#e06c75'

continuing in <SNR>46_Highlight

line 135: hi default CocSymbolProperty  ctermfg=168 guifg=#e06c75
line 136:     endif
line 137:   endfor
line 132:   for [key, value] in items(symbolMap)
line 133:     let hlGroup = coc#highlight#valid(value[0]) ? value[0] : get(value, 1, 'CocSymbolDefault')
calling coc#highlight#valid('@color')

line 1:   return hlexists(a:hlGroup) && execute('hi '.a:hlGroup, 'silent!') !~# ' cleared$'
coc#highlight#valid returning #0

continuing in <SNR>46_Highlight

line 134:     if hlexists(hlGroup)
line 135:       execute 'hi default CocSymbol'.key.' '.coc#highlight#get_hl_command(synIDtrans(hlID(hlGroup)), 'fg', '223', '#ebdbb2')
calling coc#highlight#get_hl_command(83, 'fg', '223', '#ebdbb2')

line 1:   let cterm = coc#highlight#get_color(a:id, a:key, 'cterm')
calling coc#highlight#get_color(83, 'fg', 'cterm')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning '180'

continuing in coc#highlight#get_hl_command

line 2:   let gui = coc#highlight#get_color(a:id, a:key, 'gui')
calling coc#highlight#get_color(83, 'fg', 'gui')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning '#e5c07b'

continuing in coc#highlight#get_hl_command

line 3:   let cmd = ' cterm'.a:key.'=' . (empty(cterm) ? a:cterm : cterm)
line 4:   let cmd .= ' gui'.a:key.'=' . (empty(gui) ? a:gui : gui)
line 5:   return cmd
coc#highlight#get_hl_command returning ' ctermfg=180 guifg=#e5c07b'

continuing in <SNR>46_Highlight

line 135: hi default CocSymbolColor  ctermfg=180 guifg=#e5c07b
line 136:     endif
line 137:   endfor
line 132:   for [key, value] in items(symbolMap)
line 133:     let hlGroup = coc#highlight#valid(value[0]) ? value[0] : get(value, 1, 'CocSymbolDefault')
calling coc#highlight#valid('@file')

line 1:   return hlexists(a:hlGroup) && execute('hi '.a:hlGroup, 'silent!') !~# ' cleared$'
coc#highlight#valid returning #0

continuing in <SNR>46_Highlight

line 134:     if hlexists(hlGroup)
line 135:       execute 'hi default CocSymbol'.key.' '.coc#highlight#get_hl_command(synIDtrans(hlID(hlGroup)), 'fg', '223', '#ebdbb2')
calling coc#highlight#get_hl_command(69, 'fg', '223', '#ebdbb2')

line 1:   let cterm = coc#highlight#get_color(a:id, a:key, 'cterm')
calling coc#highlight#get_color(69, 'fg', 'cterm')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning '176'

continuing in coc#highlight#get_hl_command

line 2:   let gui = coc#highlight#get_color(a:id, a:key, 'gui')
calling coc#highlight#get_color(69, 'fg', 'gui')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning '#c678dd'

continuing in coc#highlight#get_hl_command

line 3:   let cmd = ' cterm'.a:key.'=' . (empty(cterm) ? a:cterm : cterm)
line 4:   let cmd .= ' gui'.a:key.'=' . (empty(gui) ? a:gui : gui)
line 5:   return cmd
coc#highlight#get_hl_command returning ' ctermfg=176 guifg=#c678dd'

continuing in <SNR>46_Highlight

line 135: hi default CocSymbolFile  ctermfg=176 guifg=#c678dd
line 136:     endif
line 137:   endfor
line 132:   for [key, value] in items(symbolMap)
line 133:     let hlGroup = coc#highlight#valid(value[0]) ? value[0] : get(value, 1, 'CocSymbolDefault')
calling coc#highlight#valid('@constant')

line 1:   return hlexists(a:hlGroup) && execute('hi '.a:hlGroup, 'silent!') !~# ' cleared$'
coc#highlight#valid returning #0

continuing in <SNR>46_Highlight

line 134:     if hlexists(hlGroup)
line 135:       execute 'hi default CocSymbol'.key.' '.coc#highlight#get_hl_command(synIDtrans(hlID(hlGroup)), 'fg', '223', '#ebdbb2')
calling coc#highlight#get_hl_command(66, 'fg', '223', '#ebdbb2')

line 1:   let cterm = coc#highlight#get_color(a:id, a:key, 'cterm')
calling coc#highlight#get_color(66, 'fg', 'cterm')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning '73'

continuing in coc#highlight#get_hl_command

line 2:   let gui = coc#highlight#get_color(a:id, a:key, 'gui')
calling coc#highlight#get_color(66, 'fg', 'gui')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning '#56b6c2'

continuing in coc#highlight#get_hl_command

line 3:   let cmd = ' cterm'.a:key.'=' . (empty(cterm) ? a:cterm : cterm)
line 4:   let cmd .= ' gui'.a:key.'=' . (empty(gui) ? a:gui : gui)
line 5:   return cmd
coc#highlight#get_hl_command returning ' ctermfg=73 guifg=#56b6c2'

continuing in <SNR>46_Highlight

line 135: hi default CocSymbolEvent  ctermfg=73 guifg=#56b6c2
line 136:     endif
line 137:   endfor
line 132:   for [key, value] in items(symbolMap)
line 133:     let hlGroup = coc#highlight#valid(value[0]) ? value[0] : get(value, 1, 'CocSymbolDefault')
calling coc#highlight#valid('@variable.parameter')

line 1:   return hlexists(a:hlGroup) && execute('hi '.a:hlGroup, 'silent!') !~# ' cleared$'
coc#highlight#valid returning #0

continuing in <SNR>46_Highlight

line 134:     if hlexists(hlGroup)
line 135:       execute 'hi default CocSymbol'.key.' '.coc#highlight#get_hl_command(synIDtrans(hlID(hlGroup)), 'fg', '223', '#ebdbb2')
calling coc#highlight#get_hl_command(68, 'fg', '223', '#ebdbb2')

line 1:   let cterm = coc#highlight#get_color(a:id, a:key, 'cterm')
calling coc#highlight#get_color(68, 'fg', 'cterm')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning '168'

continuing in coc#highlight#get_hl_command

line 2:   let gui = coc#highlight#get_color(a:id, a:key, 'gui')
calling coc#highlight#get_color(68, 'fg', 'gui')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning '#e06c75'

continuing in coc#highlight#get_hl_command

line 3:   let cmd = ' cterm'.a:key.'=' . (empty(cterm) ? a:cterm : cterm)
line 4:   let cmd .= ' gui'.a:key.'=' . (empty(gui) ? a:gui : gui)
line 5:   return cmd
coc#highlight#get_hl_command returning ' ctermfg=168 guifg=#e06c75'

continuing in <SNR>46_Highlight

line 135: hi default CocSymbolTypeParameter  ctermfg=168 guifg=#e06c75
line 136:     endif
line 137:   endfor
line 132:   for [key, value] in items(symbolMap)
line 133:     let hlGroup = coc#highlight#valid(value[0]) ? value[0] : get(value, 1, 'CocSymbolDefault')
calling coc#highlight#valid('@constructor')

line 1:   return hlexists(a:hlGroup) && execute('hi '.a:hlGroup, 'silent!') !~# ' cleared$'
coc#highlight#valid returning #0

continuing in <SNR>46_Highlight

line 134:     if hlexists(hlGroup)
line 135:       execute 'hi default CocSymbol'.key.' '.coc#highlight#get_hl_command(synIDtrans(hlID(hlGroup)), 'fg', '223', '#ebdbb2')
calling coc#highlight#get_hl_command(67, 'fg', '223', '#ebdbb2')

line 1:   let cterm = coc#highlight#get_color(a:id, a:key, 'cterm')
calling coc#highlight#get_color(67, 'fg', 'cterm')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning '75'

continuing in coc#highlight#get_hl_command

line 2:   let gui = coc#highlight#get_color(a:id, a:key, 'gui')
calling coc#highlight#get_color(67, 'fg', 'gui')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning '#61afef'

continuing in coc#highlight#get_hl_command

line 3:   let cmd = ' cterm'.a:key.'=' . (empty(cterm) ? a:cterm : cterm)
line 4:   let cmd .= ' gui'.a:key.'=' . (empty(gui) ? a:gui : gui)
line 5:   return cmd
coc#highlight#get_hl_command returning ' ctermfg=75 guifg=#61afef'

continuing in <SNR>46_Highlight

line 135: hi default CocSymbolConstructor  ctermfg=75 guifg=#61afef
line 136:     endif
line 137:   endfor
line 132:   for [key, value] in items(symbolMap)
line 133:     let hlGroup = coc#highlight#valid(value[0]) ? value[0] : get(value, 1, 'CocSymbolDefault')
calling coc#highlight#valid('@snippet')

line 1:   return hlexists(a:hlGroup) && execute('hi '.a:hlGroup, 'silent!') !~# ' cleared$'
coc#highlight#valid returning #0

continuing in <SNR>46_Highlight

line 134:     if hlexists(hlGroup)
line 135:       execute 'hi default CocSymbol'.key.' '.coc#highlight#get_hl_command(synIDtrans(hlID(hlGroup)), 'fg', '223', '#ebdbb2')
calling coc#highlight#get_hl_command(9, 'fg', '223', '#ebdbb2')

line 1:   let cterm = coc#highlight#get_color(a:id, a:key, 'cterm')
calling coc#highlight#get_color(9, 'fg', 'cterm')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning '188'

continuing in coc#highlight#get_hl_command

line 2:   let gui = coc#highlight#get_color(a:id, a:key, 'gui')
calling coc#highlight#get_color(9, 'fg', 'gui')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning '#dcdfe4'

continuing in coc#highlight#get_hl_command

line 3:   let cmd = ' cterm'.a:key.'=' . (empty(cterm) ? a:cterm : cterm)
line 4:   let cmd .= ' gui'.a:key.'=' . (empty(gui) ? a:gui : gui)
line 5:   return cmd
coc#highlight#get_hl_command returning ' ctermfg=188 guifg=#dcdfe4'

continuing in <SNR>46_Highlight

line 135: hi default CocSymbolSnippet  ctermfg=188 guifg=#dcdfe4
line 136:     endif
line 137:   endfor
line 132:   for [key, value] in items(symbolMap)
line 133:     let hlGroup = coc#highlight#valid(value[0]) ? value[0] : get(value, 1, 'CocSymbolDefault')
calling coc#highlight#valid('@boolean')

line 1:   return hlexists(a:hlGroup) && execute('hi '.a:hlGroup, 'silent!') !~# ' cleared$'
coc#highlight#valid returning #0

continuing in <SNR>46_Highlight

line 134:     if hlexists(hlGroup)
line 135:       execute 'hi default CocSymbol'.key.' '.coc#highlight#get_hl_command(synIDtrans(hlID(hlGroup)), 'fg', '223', '#ebdbb2')
calling coc#highlight#get_hl_command(82, 'fg', '223', '#ebdbb2')

line 1:   let cterm = coc#highlight#get_color(a:id, a:key, 'cterm')
calling coc#highlight#get_color(82, 'fg', 'cterm')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning '180'

continuing in coc#highlight#get_hl_command

line 2:   let gui = coc#highlight#get_color(a:id, a:key, 'gui')
calling coc#highlight#get_color(82, 'fg', 'gui')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning '#e5c07b'

continuing in coc#highlight#get_hl_command

line 3:   let cmd = ' cterm'.a:key.'=' . (empty(cterm) ? a:cterm : cterm)
line 4:   let cmd .= ' gui'.a:key.'=' . (empty(gui) ? a:gui : gui)
line 5:   return cmd
coc#highlight#get_hl_command returning ' ctermfg=180 guifg=#e5c07b'

continuing in <SNR>46_Highlight

line 135: hi default CocSymbolBoolean  ctermfg=180 guifg=#e5c07b
line 136:     endif
line 137:   endfor
line 132:   for [key, value] in items(symbolMap)
line 133:     let hlGroup = coc#highlight#valid(value[0]) ? value[0] : get(value, 1, 'CocSymbolDefault')
calling coc#highlight#valid('@module')

line 1:   return hlexists(a:hlGroup) && execute('hi '.a:hlGroup, 'silent!') !~# ' cleared$'
coc#highlight#valid returning #0

continuing in <SNR>46_Highlight

line 134:     if hlexists(hlGroup)
line 135:       execute 'hi default CocSymbol'.key.' '.coc#highlight#get_hl_command(synIDtrans(hlID(hlGroup)), 'fg', '223', '#ebdbb2')
calling coc#highlight#get_hl_command(91, 'fg', '223', '#ebdbb2')

line 1:   let cterm = coc#highlight#get_color(a:id, a:key, 'cterm')
calling coc#highlight#get_color(91, 'fg', 'cterm')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning '176'

continuing in coc#highlight#get_hl_command

line 2:   let gui = coc#highlight#get_color(a:id, a:key, 'gui')
calling coc#highlight#get_color(91, 'fg', 'gui')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning '#c678dd'

continuing in coc#highlight#get_hl_command

line 3:   let cmd = ' cterm'.a:key.'=' . (empty(cterm) ? a:cterm : cterm)
line 4:   let cmd .= ' gui'.a:key.'=' . (empty(gui) ? a:gui : gui)
line 5:   return cmd
coc#highlight#get_hl_command returning ' ctermfg=176 guifg=#c678dd'

continuing in <SNR>46_Highlight

line 135: hi default CocSymbolNamespace  ctermfg=176 guifg=#c678dd
line 136:     endif
line 137:   endfor
line 132:   for [key, value] in items(symbolMap)
line 133:     let hlGroup = coc#highlight#valid(value[0]) ? value[0] : get(value, 1, 'CocSymbolDefault')
calling coc#highlight#valid('@string')

line 1:   return hlexists(a:hlGroup) && execute('hi '.a:hlGroup, 'silent!') !~# ' cleared$'
coc#highlight#valid returning #0

continuing in <SNR>46_Highlight

line 134:     if hlexists(hlGroup)
line 135:       execute 'hi default CocSymbol'.key.' '.coc#highlight#get_hl_command(synIDtrans(hlID(hlGroup)), 'fg', '223', '#ebdbb2')
calling coc#highlight#get_hl_command(79, 'fg', '223', '#ebdbb2')

line 1:   let cterm = coc#highlight#get_color(a:id, a:key, 'cterm')
calling coc#highlight#get_color(79, 'fg', 'cterm')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning '114'

continuing in coc#highlight#get_hl_command

line 2:   let gui = coc#highlight#get_color(a:id, a:key, 'gui')
calling coc#highlight#get_color(79, 'fg', 'gui')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning '#98c379'

continuing in coc#highlight#get_hl_command

line 3:   let cmd = ' cterm'.a:key.'=' . (empty(cterm) ? a:cterm : cterm)
line 4:   let cmd .= ' gui'.a:key.'=' . (empty(gui) ? a:gui : gui)
line 5:   return cmd
coc#highlight#get_hl_command returning ' ctermfg=114 guifg=#98c379'

continuing in <SNR>46_Highlight

line 135: hi default CocSymbolString  ctermfg=114 guifg=#98c379
line 136:     endif
line 137:   endfor
line 132:   for [key, value] in items(symbolMap)
line 133:     let hlGroup = coc#highlight#valid(value[0]) ? value[0] : get(value, 1, 'CocSymbolDefault')
calling coc#highlight#valid('@property')

line 1:   return hlexists(a:hlGroup) && execute('hi '.a:hlGroup, 'silent!') !~# ' cleared$'
coc#highlight#valid returning #0

continuing in <SNR>46_Highlight

line 134:     if hlexists(hlGroup)
line 135:       execute 'hi default CocSymbol'.key.' '.coc#highlight#get_hl_command(synIDtrans(hlID(hlGroup)), 'fg', '223', '#ebdbb2')
calling coc#highlight#get_hl_command(68, 'fg', '223', '#ebdbb2')

line 1:   let cterm = coc#highlight#get_color(a:id, a:key, 'cterm')
calling coc#highlight#get_color(68, 'fg', 'cterm')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning '168'

continuing in coc#highlight#get_hl_command

line 2:   let gui = coc#highlight#get_color(a:id, a:key, 'gui')
calling coc#highlight#get_color(68, 'fg', 'gui')

line 1:   if synIDattr(a:id, 'reverse', a:kind) !=# '1'
line 2:     return synIDattr(a:id, a:key, a:kind)
coc#highlight#get_color returning '#e06c75'

continuing in coc#highlight#get_hl_command

line 3:   let cmd = ' cterm'.a:key.'=' . (empty(cterm) ? a:cterm : cterm)
line 4:   let cmd .= ' gui'.a:key.'=' . (empty(gui) ? a:gui : gui)
line 5:   return cmd
coc#highlight#get_hl_command returning ' ctermfg=168 guifg=#e06c75'

continuing in <SNR>46_Highlight

line 135: hi default CocSymbolEnumMember  ctermfg=168 guifg=#e06c75
line 136:     endif
line 137:   endfor
line 132:   for [key, value] in items(symbolMap)
line 133:     let hlGroup = coc#highlight#valid(value[0]) ? value[0] : get(value, 1, 'CocSymbolDefault')
line 134:     if hlexists(hlGroup)
line 135:       execute 'hi default CocSymbol'.key.' '.coc#highlight#get_hl_command(synIDtrans(hlID(hlGroup)), 'fg', '223', '#ebdbb2')
line 136:     endif
line 137:   endfor
<SNR>46_Highlight returning #0

continuing in <SNR>46_VimEnter

<SNR>46_VimEnter returning #0

continuing in VimEnter Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Autocmd('CursorMoved', +expand('<abuf>'), [line('.'), col('.')])

Executing: call s:Autocmd('CursorMoved', +expand('<abuf>'), [line('.'), col('.')])
calling <SNR>46_Autocmd('CursorMoved', 1, [1, 1])

line 1:   if !get(g:, 'coc_workspace_initialized', 0)
line 2:     return
<SNR>46_Autocmd returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>57_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>57_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>57_Remove_Matches returning #0

continuing in <SNR>57_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>57_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing SafeState Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>57_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>57_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>57_Remove_Matches returning #0

continuing in <SNR>57_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>57_Highlight_Matching_Pair returning #0

continuing in SafeState Autocommands for "*"

calling lightline#link()

line 1:   let mode = get(s:lightline._mode_, a:0 ? a:1 : mode(), 'normal')
line 2:   if s:mode ==# mode
line 3:     return ''
lightline#link returning ''

calling lightline#mode()

line 1:   return get(s:lightline.mode_map, mode(), '')
lightline#mode returning 'NORMAL'

calling lightline#link()

line 1:   let mode = get(s:lightline._mode_, a:0 ? a:1 : mode(), 'normal')
line 2:   if s:mode ==# mode
line 3:     return ''
lightline#link returning ''

calling lightline#mode()

line 1:   return get(s:lightline.mode_map, mode(), '')
lightline#mode returning 'NORMAL'

calling coc#api#notify('set_var', ['coc_process_pid', 11019])

line 1:   try
line 2:     call call(s:funcs[a:method], a:args)
calling 272('coc_process_pid', 11019)

line 1:   execute 'let g:'.a:name.'= a:value'
line 1: let g:coc_process_pid= a:value
line 2:   return v:null
272 returning v:null

continuing in coc#api#notify

line 3:   catch /.*/
line 4:     call coc#rpc#notify('nvim_error_event', [0, v:exception.' on api "'.a:method.'" '.json_encode(a:args)])
line 5:   endtry
coc#api#notify returning #0

calling coc#api#notify('set_client_info', ['coc', {'major': 0, 'patch': 82, 'minor': 0}, 'remote', {}, {}])

line 1:   try
line 2:     call call(s:funcs[a:method], a:args)
calling 281('coc', {'major': 0, 'patch': 82, 'minor': 0}, 'remote', {}, {})

line 1:   " not supported
line 2:   return v:null
281 returning v:null

continuing in coc#api#notify

line 3:   catch /.*/
line 4:     call coc#rpc#notify('nvim_error_event', [0, v:exception.' on api "'.a:method.'" '.json_encode(a:args)])
line 5:   endtry
coc#api#notify returning #0

calling coc#api#notify('command', ['sign define CocSelected text=* texthl=CocSelectedText linehl=CocSelectedLine'])

line 1:   try
line 2:     call call(s:funcs[a:method], a:args)
calling 286('sign define CocSelected text=* texthl=CocSelectedText linehl=CocSelectedLine')

line 1:   " command that could cause cursor vanish
line 2:   if a:command =~# '^echo' || a:command =~# '^redraw' || a:command =~# '^sign place'
line 3:     call timer_start(0, {-> s:execute(a:command)})
line 4:   else
line 5:     execute a:command
line 5: sign define CocSelected text=* texthl=CocSelectedText linehl=CocSelectedLine
line 6:     let err = get(g:, 'errmsg', '')
line 7:     " get error from python script run.
line 8:     if !empty(err)
line 9:       unlet g:errmsg
line 10:       throw 'Command error '.err
line 11:     endif
line 12:   endif
286 returning #0

continuing in coc#api#notify

line 3:   catch /.*/
line 4:     call coc#rpc#notify('nvim_error_event', [0, v:exception.' on api "'.a:method.'" '.json_encode(a:args)])
line 5:   endtry
coc#api#notify returning #0

calling coc#api#call('call_function', ['coc#util#vim_info', []])

line 1:   let err = v:null
line 2:   let res = v:null
line 3:   try
line 4:     let res = call(s:funcs[a:method], a:args)
calling 284('coc#util#vim_info', [])

line 1:   return call(a:method, a:args)
calling coc#util#vim_info()

line 1:   return { 'root': s:root, 'apiversion': s:vim_api_version, 'mode': mode(), 'config': get(g:, 'coc_user_config', {}), 'floating': has('nvim') && exists('*nvim_open_win') ? v:true : v:false, 'extensionRoot': coc#util#extension_root(), 'globalExtensions': get(g:, 'coc_global_extensions', []), 'lines': &lines, 'columns': &columns, 'cmdheight': &cmdheight, 'pid': coc#util#getpid(), 'filetypeMap': get(g:, 'coc_filetype_map', {}), 'version': coc#util#version(), 'pumevent': 1, 'isVim': has('nvim') ? v:false : v:true, 'isCygwin': has('win32unix') ? v:true : v:false, 'isMacvim': has('gui_macvim') ? v:true : v:false, 'isiTerm': $TERM_PROGRAM ==# "iTerm.app", 'colorscheme': get(g:, 'colors_name', ''), 'workspaceFolders': get(g:, 'WorkspaceFolders', v:null), 'background': &background, 'runtimepath': join(globpath(&runtimepath, '', 0, 1), ','), 'locationlist': get(g:,'coc_enable_locationlist', 1), 'progpath': v:progpath, 'guicursor': &guicursor, 'pumwidth': exists('&pumwidth') ? &pumwidth : 15, 'tabCount': tabpage
calling coc#util#extension_root()

line 1:   return coc#util#get_data_home().'/extensions'
calling coc#util#get_data_home()

line 1:   if get(g:, 'coc_node_env', '') ==# 'test'
line 2:     return $COC_DATA_HOME
line 3:   endif
line 4:   if !empty(get(g:, 'coc_data_home', ''))
line 5:     let dir = resolve(expand(g:coc_data_home))
line 6:   else
line 7:     if exists('$XDG_CONFIG_HOME') && isdirectory(resolve($XDG_CONFIG_HOME))
line 8:       let dir = resolve($XDG_CONFIG_HOME."/coc")
line 9:     else
line 10:       if s:is_win
line 11:         let dir = resolve(expand('~/AppData/Local/coc'))
line 12:       else
line 13:         let dir = resolve(expand('~/.config/coc'))
line 14:       endif
line 15:     endif
line 16:   endif
line 17:   if !isdirectory(dir)
line 18:     call coc#notify#create(['creating coc.nvim data directory: '.dir], { 'borderhighlight': 'CocInfoSign', 'timeout': 5000, 'kind': 'info', })
line 23:     call mkdir(dir, "p", 0755)
line 24:   endif
line 25:   return dir
coc#util#get_data_home returning '/home/Dante/.config/coc'

continuing in coc#util#extension_root

coc#util#extension_root returning '/home/Dante/.config/coc/extensions'

continuing in coc#util#vim_info

calling coc#util#getpid()

line 1:   if !has('win32unix')
line 2:     return getpid()
coc#util#getpid returning #11018

continuing in coc#util#vim_info

calling coc#util#version()

line 1:   if s:is_vim
line 2:     return string(v:versionlong)
coc#util#version returning '9011043'

continuing in coc#util#vim_info

calling coc#util#semantic_hlgroups()

line 1:   let res = split(execute('hi'), "\n")
line 1: hi
SpecialKey     xxx term=bold ctermfg=188 guifg=#dcdfe4
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
EndOfBuffer    xxx links to NonText
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 13
NonText        xxx term=bold ctermfg=239 guifg=#373C45
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
Directory      xxx term=bold ctermfg=75 guifg=#61afef
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
ErrorMsg       xxx term=standout ctermfg=188 guifg=#dcdfe4
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
IncSearch      xxx term=reverse ctermfg=236 ctermbg=180 guifg=#282c34 guibg=#e5c07b
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
Search         xxx term=reverse ctermfg=236 ctermbg=180 guifg=#282c34 guibg=#e5c07b
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
CurSearch      xxx links to Search
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 13
MoreMsg        xxx term=bold ctermfg=188 guifg=#dcdfe4
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
ModeMsg        xxx term=bold ctermfg=188 guifg=#dcdfe4
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
LineNr         xxx term=underline
	Last set from ~/.vimrc line 295
LineNrAbove    xxx cleared
LineNrBelow    xxx cleared
CursorLineNr   xxx term=bold ctermfg=188 guifg=#dcdfe4
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
CursorLineSign xxx links to SignColumn
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 13
CursorLineFold xxx links to FoldColumn
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 13
Question       xxx term=standout ctermfg=176 guifg=#c678dd
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
StatusLine     xxx term=bold,reverse ctermfg=75 ctermbg=237 guifg=#61afef guibg=#313640
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
StatusLineNC   xxx term=reverse ctermfg=241 ctermbg=237 guifg=#5c6370 guibg=#313640
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
VertSplit      xxx term=reverse ctermfg=237 ctermbg=237 guifg=#313640 guibg=#313640
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
Title          xxx term=bold ctermfg=114 guifg=#98c379
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
Visual         xxx ctermfg=0 ctermbg=239 guibg=#474e5d
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
VisualNOS      xxx term=bold,underline ctermbg=239 guibg=#474e5d
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
WarningMsg     xxx term=standout ctermfg=168 guifg=#e06c75
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
WildMenu       xxx term=standout ctermfg=188 guifg=#dcdfe4
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
Folded         xxx term=standout ctermfg=188 guifg=#dcdfe4
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
FoldColumn     xxx term=standout ctermfg=188 guifg=#dcdfe4
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
DiffAdd        xxx term=bold ctermfg=114 guifg=#98c379
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
DiffChange     xxx term=bold ctermfg=180 guifg=#e5c07b
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
DiffDelete     xxx term=bold ctermfg=168 guifg=#e06c75
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
DiffText       xxx term=reverse ctermfg=75 guifg=#61afef
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
SignColumn     xxx term=standout ctermfg=188 guifg=#dcdfe4
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
Conceal        xxx ctermfg=188 guifg=#dcdfe4
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
SpellBad       xxx term=reverse ctermfg=168 guifg=#e06c75 guisp=Red
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
SpellCap       xxx term=reverse ctermfg=180 guifg=#e5c07b guisp=Blue
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
SpellRare      xxx term=reverse ctermfg=180 guifg=#e5c07b guisp=Magenta
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
SpellLocal     xxx term=underline ctermfg=180 guifg=#e5c07b guisp=Cyan
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
Pmenu          xxx ctermfg=236 ctermbg=188 guifg=#282c34 guibg=#dcdfe4
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
PmenuSel       xxx ctermfg=188 ctermbg=75 guifg=#dcdfe4 guibg=#61afef
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
PmenuMatch     xxx links to Pmenu
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 13
PmenuMatchSel  xxx links to PmenuSel
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 13
PmenuKind      xxx links to Pmenu
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 13
PmenuKindSel   xxx links to PmenuSel
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 13
PmenuExtra     xxx links to Pmenu
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 13
PmenuExtraSel  xxx links to PmenuSel
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 13
PmenuSbar      xxx ctermbg=239 guibg=#474e5d
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
PmenuThumb     xxx ctermbg=188 guibg=#dcdfe4
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
TabLine        xxx term=underline ctermfg=241 ctermbg=237 guifg=#5c6370 guibg=#313640
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
TabLineSel     xxx term=bold ctermfg=188 ctermbg=236 guifg=#dcdfe4 guibg=#282c34
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
TabLineFill    xxx term=reverse ctermfg=241 ctermbg=237 guifg=#5c6370 guibg=#313640
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
CursorColumn   xxx term=reverse ctermbg=237 guibg=#313640
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
CursorLine     xxx term=underline ctermbg=237 guibg=#313640
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
ColorColumn    xxx term=reverse ctermbg=237 guibg=#313640
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
QuickFixLine   xxx links to Search
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 13
StatusLineTerm xxx term=bold,reverse cterm=bold ctermfg=0 ctermbg=121 gui=bold guifg=bg
                   guibg=LightGreen
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 13
StatusLineTermNC xxx term=reverse ctermfg=0 ctermbg=121 guifg=bg guibg=LightGreen
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 13
MsgArea        xxx cleared
ComplMatchIns  xxx cleared
Cursor         xxx ctermfg=236 ctermbg=75 guifg=#282c34 guibg=#61afef
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
lCursor        xxx guifg=bg guibg=fg
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 13
Normal         xxx ctermfg=188 guifg=#dcdfe4
	Last set from ~/.vimrc line 289
MatchParen     xxx term=reverse cterm=underline ctermfg=75 gui=underline guifg=#61afef
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 56
ToolbarLine    xxx term=underline ctermbg=242 guibg=Grey50
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 13
ToolbarButton  xxx cterm=bold ctermfg=0 ctermbg=7 gui=bold guifg=Black guibg=LightGrey
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 13
Comment        xxx term=bold cterm=italic ctermfg=241 gui=italic guifg=#5c6370
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 56
Constant       xxx term=underline ctermfg=73 guifg=#56b6c2
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
Special        xxx term=bold ctermfg=75 guifg=#61afef
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
Identifier     xxx term=underline ctermfg=168 guifg=#e06c75
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
Statement      xxx term=bold ctermfg=176 guifg=#c678dd
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
PreProc        xxx term=underline ctermfg=180 guifg=#e5c07b
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
Type           xxx term=underline ctermfg=180 guifg=#e5c07b
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
Underlined     xxx term=underline ctermfg=188 guifg=#dcdfe4
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
Ignore         xxx ctermfg=188 guifg=#dcdfe4
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
Added          xxx ctermfg=10 guifg=LimeGreen
	Last set from /usr/share/vim/vim91/syntax/syncolor.vim line 44
Changed        xxx ctermfg=12 guifg=DodgerBlue
	Last set from /usr/share/vim/vim91/syntax/syncolor.vim line 45
Removed        xxx ctermfg=9 guifg=Red
	Last set from /usr/share/vim/vim91/syntax/syncolor.vim line 46
Error          xxx term=reverse ctermfg=168 ctermbg=236 guifg=#e06c75 guibg=#282c34
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
Todo           xxx term=standout ctermfg=176 guifg=#c678dd
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
String         xxx ctermfg=114 guifg=#98c379
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
Character      xxx ctermfg=114 guifg=#98c379
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
Number         xxx ctermfg=180 guifg=#e5c07b
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
Boolean        xxx ctermfg=180 guifg=#e5c07b
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
Float          xxx ctermfg=180 guifg=#e5c07b
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
Function       xxx ctermfg=75 guifg=#61afef
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
Conditional    xxx ctermfg=176 guifg=#c678dd
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
Repeat         xxx ctermfg=176 guifg=#c678dd
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
Label          xxx ctermfg=176 guifg=#c678dd
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
Operator       xxx ctermfg=188 guifg=#dcdfe4
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
Keyword        xxx ctermfg=168 guifg=#e06c75
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
Exception      xxx ctermfg=176 guifg=#c678dd
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
Include        xxx ctermfg=176 guifg=#c678dd
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
Define         xxx ctermfg=176 guifg=#c678dd
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
Macro          xxx ctermfg=176 guifg=#c678dd
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
PreCondit      xxx ctermfg=180 guifg=#e5c07b
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
StorageClass   xxx ctermfg=180 guifg=#e5c07b
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
Structure      xxx ctermfg=180 guifg=#e5c07b
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
Typedef        xxx ctermfg=180 guifg=#e5c07b
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
Tag            xxx ctermfg=188 guifg=#dcdfe4
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
SpecialChar    xxx ctermfg=188 guifg=#dcdfe4
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
Delimiter      xxx ctermfg=188 guifg=#dcdfe4
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
SpecialComment xxx ctermfg=188 guifg=#dcdfe4
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
Debug          xxx ctermfg=188 guifg=#dcdfe4
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
Whitespace     xxx ctermfg=239 guifg=#373C45
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
GitGutterAdd   xxx ctermfg=114 ctermbg=236 guifg=#98c379 guibg=#282c34
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
GitGutterDelete xxx ctermfg=168 ctermbg=236 guifg=#e06c75 guibg=#282c34
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
GitGutterChange xxx ctermfg=180 ctermbg=236 guifg=#e5c07b guibg=#282c34
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
GitGutterChangeDelete xxx ctermfg=168 ctermbg=236 guifg=#e06c75 guibg=#282c34
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
diffAdded      xxx ctermfg=114 guifg=#98c379
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
diffRemoved    xxx ctermfg=168 guifg=#e06c75
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
gitcommitComment xxx ctermfg=241 guifg=#5c6370
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
gitcommitUnmerged xxx ctermfg=168 guifg=#e06c75
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
gitcommitOnBranch xxx ctermfg=188 guifg=#dcdfe4
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
gitcommitBranch xxx ctermfg=176 guifg=#c678dd
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
gitcommitDiscardedType xxx ctermfg=168 guifg=#e06c75
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
gitcommitSelectedType xxx ctermfg=114 guifg=#98c379
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
gitcommitHeader xxx ctermfg=188 guifg=#dcdfe4
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
gitcommitUntrackedFile xxx ctermfg=73 guifg=#56b6c2
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
gitcommitDiscardedFile xxx ctermfg=168 guifg=#e06c75
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
gitcommitSelectedFile xxx ctermfg=114 guifg=#98c379
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
gitcommitUnmergedFile xxx ctermfg=180 guifg=#e5c07b
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
gitcommitFile  xxx ctermfg=188 guifg=#dcdfe4
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 58
gitcommitNoBranch xxx links to gitcommitBranch
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 197
gitcommitUntracked xxx links to gitcommitComment
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 198
gitcommitDiscarded xxx links to gitcommitComment
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 199
gitcommitSelected xxx links to gitcommitComment
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 200
gitcommitDiscardedArrow xxx links to gitcommitDiscardedFile
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 201
gitcommitSelectedArrow xxx links to gitcommitSelectedFile
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 202
gitcommitUnmergedArrow xxx links to gitcommitUnmergedFile
	Last set from ~/.vim/plugged/onehalf/vim/colors/onehalfdark.vim line 203
CocSelectedText xxx ctermfg=9 guifg=#fb4934
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 431
CocCodeLens    xxx ctermfg=248 guifg=#999999
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 432
CocUnderline   xxx term=underline cterm=underline gui=underline guisp=#ebdbb2
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 433
CocBold        xxx term=bold cterm=bold gui=bold
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 434
CocItalic      xxx term=italic cterm=italic gui=italic
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 435
CocStrikeThrough xxx term=strikethrough cterm=strikethrough gui=strikethrough
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 436
CocMarkdownLink xxx ctermfg=12 guifg=#15aabf
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 437
CocDisabled    xxx ctermfg=248 guifg=#999999
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 438
CocSearch      xxx ctermfg=12 guifg=#15aabf
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 439
CocLink        xxx term=underline cterm=underline gui=underline guisp=#15aabf
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 440
CocFloatActive xxx links to CocSearch
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 441
CocFadeOut     xxx links to Conceal
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 442
CocMarkdownCode xxx links to markdownCode
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 443
markdownCode   xxx cleared
CocMarkdownHeader xxx links to markdownH1
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 444
markdownH1     xxx cleared
CocDeprecatedHighlight xxx links to CocStrikeThrough
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 445
CocUnusedHighlight xxx links to CocFadeOut
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 446
CocListSearch  xxx links to CocSearch
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 447
CocListMode    xxx links to ModeMsg
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 448
CocListPath    xxx links to Comment
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 449
CocHighlightText xxx links to CursorColumn
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 450
CocHoverRange  xxx links to Search
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 451
CocCursorRange xxx links to Search
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 452
CocLinkedEditing xxx links to CocCursorRange
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 453
CocHighlightRead xxx links to CocHighlightText
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 454
CocHighlightWrite xxx links to CocHighlightText
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 455
CocNotificationProgress xxx ctermfg=12 guifg=#15aabf
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 457
CocNotificationButton xxx links to CocUnderline
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 458
CocNotificationError xxx links to CocErrorFloat
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 459
CocErrorFloat  xxx ctermfg=9 ctermbg=237 guifg=#ff0000 guibg=#414141
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 231
CocNotificationWarning xxx links to CocWarningFloat
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 460
CocWarningFloat xxx ctermfg=130 ctermbg=237 guifg=#ff922b guibg=#414141
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 231
CocNotificationInfo xxx links to CocInfoFloat
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 461
CocInfoFloat   xxx ctermfg=11 ctermbg=237 guifg=#fab005 guibg=#414141
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 231
CocSnippetVisual xxx links to Visual
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 463
CocTreeTitle   xxx links to Title
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 465
CocTreeDescription xxx links to Comment
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 466
CocTreeOpenClose xxx links to CocBold
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 467
CocTreeSelected xxx links to CursorLine
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 468
CocSelectedRange xxx links to CocHighlightText
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 469
CocSymbolDefault xxx links to MoreMsg
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 471
CocPumSearch   xxx links to CocSearch
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 473
CocPumDetail   xxx links to Comment
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 474
CocPumMenu     xxx links to CocFloating
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 475
CocFloating    xxx ctermbg=237 guibg=#414141
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 489
CocPumShortcut xxx links to Comment
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 476
CocPumDeprecated xxx links to CocStrikeThrough
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 477
CocVirtualText xxx ctermfg=12 guifg=#504945
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 478
CocPumVirtualText xxx links to CocVirtualText
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 479
CocInputBoxVirtualText xxx links to CocVirtualText
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 480
CocFloatDividingLine xxx links to CocVirtualText
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 481
CocListBlackBlack xxx guifg=#282828 guibg=#282828
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListBlackBlue xxx guifg=#282828 guibg=#458588
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListBlackGreen xxx guifg=#282828 guibg=#98971a
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListBlackGrey xxx guifg=#282828 guibg=#928374
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListBlackWhite xxx guifg=#282828 guibg=#a89984
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListBlackCyan xxx guifg=#282828 guibg=#689d6a
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListBlackYellow xxx guifg=#282828 guibg=#d79921
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListBlackMagenta xxx guifg=#282828 guibg=#b16286
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListBlackRed xxx guifg=#282828 guibg=#cc241d
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListFgBlack xxx ctermfg=0 guifg=#282828
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 220
CocListBgBlack xxx ctermbg=0 guibg=#282828
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 221
CocListBlueBlack xxx guifg=#458588 guibg=#282828
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListBlueBlue xxx guifg=#458588 guibg=#458588
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListBlueGreen xxx guifg=#458588 guibg=#98971a
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListBlueGrey xxx guifg=#458588 guibg=#928374
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListBlueWhite xxx guifg=#458588 guibg=#a89984
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListBlueCyan xxx guifg=#458588 guibg=#689d6a
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListBlueYellow xxx guifg=#458588 guibg=#d79921
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListBlueMagenta xxx guifg=#458588 guibg=#b16286
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListBlueRed xxx guifg=#458588 guibg=#cc241d
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListFgBlue  xxx ctermfg=12 guifg=#458588
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 220
CocListBgBlue  xxx ctermbg=12 guibg=#458588
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 221
CocListGreenBlack xxx guifg=#98971a guibg=#282828
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListGreenBlue xxx guifg=#98971a guibg=#458588
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListGreenGreen xxx guifg=#98971a guibg=#98971a
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListGreenGrey xxx guifg=#98971a guibg=#928374
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListGreenWhite xxx guifg=#98971a guibg=#a89984
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListGreenCyan xxx guifg=#98971a guibg=#689d6a
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListGreenYellow xxx guifg=#98971a guibg=#d79921
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListGreenMagenta xxx guifg=#98971a guibg=#b16286
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListGreenRed xxx guifg=#98971a guibg=#cc241d
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListFgGreen xxx ctermfg=10 guifg=#98971a
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 220
CocListBgGreen xxx ctermbg=10 guibg=#98971a
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 221
CocListGreyBlack xxx guifg=#928374 guibg=#282828
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListGreyBlue xxx guifg=#928374 guibg=#458588
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListGreyGreen xxx guifg=#928374 guibg=#98971a
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListGreyGrey xxx guifg=#928374 guibg=#928374
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListGreyWhite xxx guifg=#928374 guibg=#a89984
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListGreyCyan xxx guifg=#928374 guibg=#689d6a
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListGreyYellow xxx guifg=#928374 guibg=#d79921
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListGreyMagenta xxx guifg=#928374 guibg=#b16286
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListGreyRed xxx guifg=#928374 guibg=#cc241d
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListFgGrey  xxx ctermfg=248 guifg=#928374
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 220
CocListBgGrey  xxx ctermbg=248 guibg=#928374
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 221
CocListWhiteBlack xxx guifg=#a89984 guibg=#282828
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListWhiteBlue xxx guifg=#a89984 guibg=#458588
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListWhiteGreen xxx guifg=#a89984 guibg=#98971a
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListWhiteGrey xxx guifg=#a89984 guibg=#928374
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListWhiteWhite xxx guifg=#a89984 guibg=#a89984
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListWhiteCyan xxx guifg=#a89984 guibg=#689d6a
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListWhiteYellow xxx guifg=#a89984 guibg=#d79921
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListWhiteMagenta xxx guifg=#a89984 guibg=#b16286
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListWhiteRed xxx guifg=#a89984 guibg=#cc241d
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListFgWhite xxx ctermfg=15 guifg=#a89984
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 220
CocListBgWhite xxx ctermbg=15 guibg=#a89984
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 221
CocListCyanBlack xxx guifg=#689d6a guibg=#282828
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListCyanBlue xxx guifg=#689d6a guibg=#458588
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListCyanGreen xxx guifg=#689d6a guibg=#98971a
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListCyanGrey xxx guifg=#689d6a guibg=#928374
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListCyanWhite xxx guifg=#689d6a guibg=#a89984
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListCyanCyan xxx guifg=#689d6a guibg=#689d6a
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListCyanYellow xxx guifg=#689d6a guibg=#d79921
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListCyanMagenta xxx guifg=#689d6a guibg=#b16286
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListCyanRed xxx guifg=#689d6a guibg=#cc241d
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListFgCyan  xxx ctermfg=14 guifg=#689d6a
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 220
CocListBgCyan  xxx ctermbg=14 guibg=#689d6a
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 221
CocListYellowBlack xxx guifg=#d79921 guibg=#282828
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListYellowBlue xxx guifg=#d79921 guibg=#458588
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListYellowGreen xxx guifg=#d79921 guibg=#98971a
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListYellowGrey xxx guifg=#d79921 guibg=#928374
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListYellowWhite xxx guifg=#d79921 guibg=#a89984
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListYellowCyan xxx guifg=#d79921 guibg=#689d6a
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListYellowYellow xxx guifg=#d79921 guibg=#d79921
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListYellowMagenta xxx guifg=#d79921 guibg=#b16286
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListYellowRed xxx guifg=#d79921 guibg=#cc241d
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListFgYellow xxx ctermfg=11 guifg=#d79921
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 220
CocListBgYellow xxx ctermbg=11 guibg=#d79921
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 221
CocListMagentaBlack xxx guifg=#b16286 guibg=#282828
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListMagentaBlue xxx guifg=#b16286 guibg=#458588
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListMagentaGreen xxx guifg=#b16286 guibg=#98971a
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListMagentaGrey xxx guifg=#b16286 guibg=#928374
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListMagentaWhite xxx guifg=#b16286 guibg=#a89984
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListMagentaCyan xxx guifg=#b16286 guibg=#689d6a
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListMagentaYellow xxx guifg=#b16286 guibg=#d79921
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListMagentaMagenta xxx guifg=#b16286 guibg=#b16286
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListMagentaRed xxx guifg=#b16286 guibg=#cc241d
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListFgMagenta xxx ctermfg=13 guifg=#b16286
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 220
CocListBgMagenta xxx ctermbg=13 guibg=#b16286
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 221
CocListRedBlack xxx guifg=#cc241d guibg=#282828
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListRedBlue xxx guifg=#cc241d guibg=#458588
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListRedGreen xxx guifg=#cc241d guibg=#98971a
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListRedGrey xxx guifg=#cc241d guibg=#928374
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListRedWhite xxx guifg=#cc241d guibg=#a89984
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListRedCyan xxx guifg=#cc241d guibg=#689d6a
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListRedYellow xxx guifg=#cc241d guibg=#d79921
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListRedMagenta xxx guifg=#cc241d guibg=#b16286
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListRedRed  xxx guifg=#cc241d guibg=#cc241d
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 218
CocListFgRed   xxx ctermfg=9 guifg=#cc241d
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 220
CocListBgRed   xxx ctermbg=9 guibg=#cc241d
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 221
CocMenuSel     xxx ctermbg=238 guibg=#4f4f4f
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 490
CocListLine    xxx links to CursorLine
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 507
LightlineLeft_normal_0 xxx ctermfg=236 ctermbg=114 guifg=#282c34 guibg=#98c379
	Last set from ~/.vim/plugged/lightline.vim/autoload/lightline.vim line 285
LightlineLeft_normal_0_1 xxx ctermfg=114 ctermbg=243 guifg=#98c379 guibg=#5d677a
	Last set from ~/.vim/plugged/lightline.vim/autoload/lightline.vim line 290
LightlineLeft_normal_0_tabsel xxx ctermfg=114 ctermbg=243 guifg=#98c379 guibg=#5d677a
	Last set from ~/.vim/plugged/lightline.vim/autoload/lightline.vim line 290
LightlineLeft_normal_1 xxx ctermfg=255 ctermbg=243 guifg=#dcdfe4 guibg=#5d677a
	Last set from ~/.vim/plugged/lightline.vim/autoload/lightline.vim line 285
LightlineLeft_normal_1_2 xxx ctermfg=243 ctermbg=238 guifg=#5d677a guibg=#313640
	Last set from ~/.vim/plugged/lightline.vim/autoload/lightline.vim line 290
LightlineLeft_normal_1_tabsel xxx ctermfg=243 ctermbg=243 guifg=#5d677a guibg=#5d677a
	Last set from ~/.vim/plugged/lightline.vim/autoload/lightline.vim line 290
LightlineLeft_normal_tabsel xxx ctermfg=255 ctermbg=243 guifg=#dcdfe4 guibg=#5d677a
	Last set from ~/.vim/plugged/lightline.vim/autoload/lightline.vim line 285
LightlineLeft_normal_tabsel_0 xxx ctermfg=243 ctermbg=114 guifg=#5d677a guibg=#98c379
	Last set from ~/.vim/plugged/lightline.vim/autoload/lightline.vim line 290
LightlineLeft_normal_tabsel_1 xxx ctermfg=243 ctermbg=243 guifg=#5d677a guibg=#5d677a
	Last set from ~/.vim/plugged/lightline.vim/autoload/lightline.vim line 290
LightlineLeft_normal_tabsel_2 xxx ctermfg=243 ctermbg=238 guifg=#5d677a guibg=#313640
	Last set from ~/.vim/plugged/lightline.vim/autoload/lightline.vim line 290
LightlineLeft_normal_tabsel_tabsel xxx ctermfg=243 ctermbg=243 guifg=#5d677a guibg=#5d677a
	Last set from ~/.vim/plugged/lightline.vim/autoload/lightline.vim line 290
LightlineRight_normal_0 xxx ctermfg=236 ctermbg=114 guifg=#282c34 guibg=#98c379
	Last set from ~/.vim/plugged/lightline.vim/autoload/lightline.vim line 285
LightlineRight_normal_0_1 xxx ctermfg=114 ctermbg=243 guifg=#98c379 guibg=#5d677a
	Last set from ~/.vim/plugged/lightline.vim/autoload/lightline.vim line 290
LightlineRight_normal_0_tabsel xxx ctermfg=114 ctermbg=243 guifg=#98c379 guibg=#5d677a
	Last set from ~/.vim/plugged/lightline.vim/autoload/lightline.vim line 290
LightlineRight_normal_1 xxx ctermfg=255 ctermbg=243 guifg=#dcdfe4 guibg=#5d677a
	Last set from ~/.vim/plugged/lightline.vim/autoload/lightline.vim line 285
LightlineRight_normal_1_2 xxx ctermfg=243 ctermbg=238 guifg=#5d677a guibg=#313640
	Last set from ~/.vim/plugged/lightline.vim/autoload/lightline.vim line 290
LightlineRight_normal_1_tabsel xxx ctermfg=243 ctermbg=243 guifg=#5d677a guibg=#5d677a
	Last set from ~/.vim/plugged/lightline.vim/autoload/lightline.vim line 290
LightlineRight_normal_2 xxx ctermfg=114 ctermbg=238 guifg=#98c379 guibg=#313640
	Last set from ~/.vim/plugged/lightline.vim/autoload/lightline.vim line 285
LightlineRight_normal_2_3 xxx ctermfg=238 ctermbg=238 guifg=#313640 guibg=#313640
	Last set from ~/.vim/plugged/lightline.vim/autoload/lightline.vim line 290
LightlineRight_normal_2_tabsel xxx ctermfg=238 ctermbg=243 guifg=#313640 guibg=#5d677a
	Last set from ~/.vim/plugged/lightline.vim/autoload/lightline.vim line 290
LightlineRight_normal_tabsel xxx ctermfg=255 ctermbg=243 guifg=#dcdfe4 guibg=#5d677a
	Last set from ~/.vim/plugged/lightline.vim/autoload/lightline.vim line 285
LightlineRight_normal_tabsel_0 xxx ctermfg=243 ctermbg=114 guifg=#5d677a guibg=#98c379
	Last set from ~/.vim/plugged/lightline.vim/autoload/lightline.vim line 290
LightlineRight_normal_tabsel_1 xxx ctermfg=243 ctermbg=243 guifg=#5d677a guibg=#5d677a
	Last set from ~/.vim/plugged/lightline.vim/autoload/lightline.vim line 290
LightlineRight_normal_tabsel_2 xxx ctermfg=243 ctermbg=238 guifg=#5d677a guibg=#313640
	Last set from ~/.vim/plugged/lightline.vim/autoload/lightline.vim line 290
LightlineRight_normal_tabsel_3 xxx ctermfg=243 ctermbg=238 guifg=#5d677a guibg=#313640
	Last set from ~/.vim/plugged/lightline.vim/autoload/lightline.vim line 290
LightlineRight_normal_tabsel_tabsel xxx ctermfg=243 ctermbg=243 guifg=#5d677a guibg=#5d677a
	Last set from ~/.vim/plugged/lightline.vim/autoload/lightline.vim line 290
LightlineMiddle_normal xxx ctermfg=114 ctermbg=238 guifg=#98c379 guibg=#313640
	Last set from ~/.vim/plugged/lightline.vim/autoload/lightline.vim line 295
LightlineLeft_active_0 xxx links to LightlineLeft_normal_0
	Last set from ~/.vim/plugged/lightline.vim/autoload/lightline.vim line 235
LightlineLeft_active_0_1 xxx links to LightlineLeft_normal_0_1
	Last set from ~/.vim/plugged/lightline.vim/autoload/lightline.vim line 239
LightlineLeft_active_0_tabsel xxx links to LightlineLeft_normal_0_tabsel
	Last set from ~/.vim/plugged/lightline.vim/autoload/lightline.vim line 239
LightlineLeft_active_1 xxx links to LightlineLeft_normal_1
	Last set from ~/.vim/plugged/lightline.vim/autoload/lightline.vim line 235
LightlineLeft_active_1_2 xxx links to LightlineLeft_normal_1_2
	Last set from ~/.vim/plugged/lightline.vim/autoload/lightline.vim line 239
LightlineLeft_active_1_tabsel xxx links to LightlineLeft_normal_1_tabsel
	Last set from ~/.vim/plugged/lightline.vim/autoload/lightline.vim line 239
LightlineLeft_active_tabsel xxx links to LightlineLeft_normal_tabsel
	Last set from ~/.vim/plugged/lightline.vim/autoload/lightline.vim line 235
LightlineLeft_active_tabsel_0 xxx links to LightlineLeft_normal_tabsel_0
	Last set from ~/.vim/plugged/lightline.vim/autoload/lightline.vim line 239
LightlineLeft_active_tabsel_1 xxx links to LightlineLeft_normal_tabsel_1
	Last set from ~/.vim/plugged/lightline.vim/autoload/lightline.vim line 239
LightlineLeft_active_tabsel_2 xxx links to LightlineLeft_normal_tabsel_2
	Last set from ~/.vim/plugged/lightline.vim/autoload/lightline.vim line 239
LightlineLeft_active_tabsel_tabsel xxx links to LightlineLeft_normal_tabsel_tabsel
	Last set from ~/.vim/plugged/lightline.vim/autoload/lightline.vim line 239
LightlineRight_active_0 xxx links to LightlineRight_normal_0
	Last set from ~/.vim/plugged/lightline.vim/autoload/lightline.vim line 235
LightlineRight_active_0_1 xxx links to LightlineRight_normal_0_1
	Last set from ~/.vim/plugged/lightline.vim/autoload/lightline.vim line 239
LightlineRight_active_0_tabsel xxx links to LightlineRight_normal_0_tabsel
	Last set from ~/.vim/plugged/lightline.vim/autoload/lightline.vim line 239
LightlineRight_active_1 xxx links to LightlineRight_normal_1
	Last set from ~/.vim/plugged/lightline.vim/autoload/lightline.vim line 235
LightlineRight_active_1_2 xxx links to LightlineRight_normal_1_2
	Last set from ~/.vim/plugged/lightline.vim/autoload/lightline.vim line 239
LightlineRight_active_1_tabsel xxx links to LightlineRight_normal_1_tabsel
	Last set from ~/.vim/plugged/lightline.vim/autoload/lightline.vim line 239
LightlineRight_active_2 xxx links to LightlineRight_normal_2
	Last set from ~/.vim/plugged/lightline.vim/autoload/lightline.vim line 235
LightlineRight_active_2_3 xxx links to LightlineRight_normal_2_3
	Last set from ~/.vim/plugged/lightline.vim/autoload/lightline.vim line 239
LightlineRight_active_2_tabsel xxx links to LightlineRight_normal_2_tabsel
	Last set from ~/.vim/plugged/lightline.vim/autoload/lightline.vim line 239
LightlineRight_active_tabsel xxx links to LightlineRight_normal_tabsel
	Last set from ~/.vim/plugged/lightline.vim/autoload/lightline.vim line 235
LightlineRight_active_tabsel_0 xxx links to LightlineRight_normal_tabsel_0
	Last set from ~/.vim/plugged/lightline.vim/autoload/lightline.vim line 239
LightlineRight_active_tabsel_1 xxx links to LightlineRight_normal_tabsel_1
	Last set from ~/.vim/plugged/lightline.vim/autoload/lightline.vim line 239
LightlineRight_active_tabsel_2 xxx links to LightlineRight_normal_tabsel_2
	Last set from ~/.vim/plugged/lightline.vim/autoload/lightline.vim line 239
LightlineRight_active_tabsel_3 xxx links to LightlineRight_normal_tabsel_3
	Last set from ~/.vim/plugged/lightline.vim/autoload/lightline.vim line 239
LightlineRight_active_tabsel_tabsel xxx links to LightlineRight_normal_tabsel_tabsel
	Last set from ~/.vim/plugged/lightline.vim/autoload/lightline.vim line 239
LightlineMiddle_active xxx links to LightlineMiddle_normal
	Last set from ~/.vim/plugged/lightline.vim/autoload/lightline.vim line 244
CocFloatThumb  xxx ctermbg=240 guibg=#5e5e5e
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 491
CocFloatSbar   xxx links to CocFloating
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 492
CocErrorHighlight xxx links to CocUnderline
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 525
CocErrorSign   xxx ctermfg=9 guifg=#ff0000
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 530
CocErrorVirtualText xxx ctermfg=9 guifg=#ff0000
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 231
CocWarningHighlight xxx links to CocUnderline
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 525
CocWarningSign xxx ctermfg=130 guifg=#ff922b
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 530
CocWarningVirtualText xxx ctermfg=130 guifg=#ff922b
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 231
CocInfoHighlight xxx links to CocUnderline
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 525
CocInfoSign    xxx ctermfg=11 guifg=#fab005
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 530
CocInfoVirtualText xxx ctermfg=11 guifg=#fab005
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 231
CocHintHighlight xxx links to CocUnderline
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 525
CocHintSign    xxx ctermfg=12 guifg=#15aabf
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 530
CocHintVirtualText xxx ctermfg=12 guifg=#15aabf
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 231
CocHintFloat   xxx ctermfg=12 ctermbg=237 guifg=#15aabf guibg=#414141
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 231
CocInlayHint   xxx ctermfg=12 guifg=#15aabf
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 231
CocInlayHintParameter xxx links to CocInlayHint
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 546
CocInlayHintType xxx links to CocInlayHint
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 546
CocSemTypeMacro xxx links to Define
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 580
CocSemTypeEnumMember xxx links to Constant
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 580
CocSemTypeComment xxx links to Comment
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 580
CocSemTypeOperator xxx links to Operator
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 580
CocSemTypeProperty xxx links to Identifier
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 580
CocSemTypeClass xxx links to Special
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 580
CocSemTypeStruct xxx links to Identifier
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 580
CocSemTypeRegexp xxx links to String
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 580
CocSemTypeBoolean xxx links to Boolean
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 580
CocSemTypeMethod xxx links to Function
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 580
CocSemTypeNamespace xxx links to Include
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 580
CocSemTypeModifier xxx links to StorageClass
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 580
CocSemTypeNumber xxx links to Number
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 580
CocSemTypeTypeParameter xxx links to Identifier
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 580
CocSemTypeKeyword xxx links to Keyword
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 580
CocSemModDeprecated xxx links to CocDeprecatedHighlight
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 580
CocSemTypeFunction xxx links to Function
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 580
CocSemTypeDecorator xxx links to Identifier
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 580
CocSemTypeEnum xxx links to Type
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 580
CocSemTypeParameter xxx links to Identifier
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 580
CocSemTypeType xxx links to Type
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 580
CocSemTypeString xxx links to String
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 580
CocSemTypeVariable xxx links to Identifier
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 580
CocSemTypeInterface xxx links to Type
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 580
CocSemTypeEvent xxx links to Keyword
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 580
CocSymbolUnit  xxx ctermfg=188 guifg=#dcdfe4
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 622
CocSymbolNumber xxx ctermfg=180 guifg=#e5c07b
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 622
CocSymbolFunction xxx ctermfg=75 guifg=#61afef
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 622
CocSymbolKey   xxx ctermfg=168 guifg=#e06c75
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 622
CocSymbolKeyword xxx ctermfg=168 guifg=#e06c75
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 622
CocSymbolReference xxx ctermfg=73 guifg=#56b6c2
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 622
CocSymbolFolder xxx ctermfg=188 guifg=#dcdfe4
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 622
CocSymbolVariable xxx ctermfg=75 guifg=#61afef
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 622
CocSymbolNull  xxx ctermfg=180 guifg=#e5c07b
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 622
CocSymbolValue xxx ctermfg=188 guifg=#dcdfe4
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 622
CocSymbolConstant xxx ctermfg=73 guifg=#56b6c2
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 622
CocSymbolText  xxx ctermfg=188 guifg=#dcdfe4
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 622
CocSymbolModule xxx ctermfg=176 guifg=#c678dd
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 622
CocSymbolPackage xxx ctermfg=176 guifg=#c678dd
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 622
CocSymbolClass xxx ctermfg=75 guifg=#61afef
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 622
CocSymbolOperator xxx ctermfg=188 guifg=#dcdfe4
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 622
CocSymbolStruct xxx ctermfg=168 guifg=#e06c75
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 622
CocSymbolObject xxx ctermfg=188 guifg=#dcdfe4
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 622
CocSymbolMethod xxx ctermfg=75 guifg=#61afef
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 622
CocSymbolArray xxx ctermfg=188 guifg=#dcdfe4
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 622
CocSymbolEnum  xxx ctermfg=188 guifg=#dcdfe4
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 622
CocSymbolField xxx ctermfg=168 guifg=#e06c75
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 622
CocSymbolInterface xxx ctermfg=188 guifg=#dcdfe4
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 622
CocSymbolProperty xxx ctermfg=168 guifg=#e06c75
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 622
CocSymbolColor xxx ctermfg=180 guifg=#e5c07b
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 622
CocSymbolFile  xxx ctermfg=176 guifg=#c678dd
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 622
CocSymbolEvent xxx ctermfg=73 guifg=#56b6c2
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 622
CocSymbolTypeParameter xxx ctermfg=168 guifg=#e06c75
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 622
CocSymbolConstructor xxx ctermfg=75 guifg=#61afef
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 622
CocSymbolSnippet xxx ctermfg=188 guifg=#dcdfe4
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 622
CocSymbolBoolean xxx ctermfg=180 guifg=#e5c07b
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 622
CocSymbolNamespace xxx ctermfg=176 guifg=#c678dd
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 622
CocSymbolString xxx ctermfg=114 guifg=#98c379
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 622
CocSymbolEnumMember xxx ctermfg=168 guifg=#e06c75
	Last set from ~/.vim/plugged/coc.nvim/plugin/coc.vim line 622
CocSelectedLine xxx cleared
line 2:   let filtered = filter(res, "v:val =~# '^CocSem' && v:val !~# ' cleared$'")
line 3:   return map(filtered, "matchstr(v:val,'\\v^CocSem\\w+')")
coc#util#semantic_hlgroups returning ['CocSemTypeMacro', 'CocSemTypeEnumMem...ocSemTypeInterface', 'CocSemTypeEvent']

continuing in coc#util#vim_info

coc#util#vim_info returning {'root': '/home/Dante/.vim/plugged/coc...inkon175', 'ambiguousIsNarrow': v:true}

continuing in 284

284 returning {'root': '/home/Dante/.vim/plugged/coc...inkon175', 'ambiguousIsNarrow': v:true}

continuing in coc#api#call

line 5:   catch /.*/
line 6:     let err = v:exception .' on api "'.a:method.'" '.json_encode(a:args)
line 7:   endtry
line 8:   return [err, res]
coc#api#call returning [v:null, {'root': '/home/Dante/.vim/pl...nkon175', 'ambiguousIsNarrow': v:true}]

calling coc#api#notify('command', ['autocmd! coc_dynamic_content BufRead...pand(''<afile>'')]) | filetype detect'])

line 1:   try
line 2:     call call(s:funcs[a:method], a:args)
calling 286('autocmd! coc_dynamic_content BufReadC...xpand(''<afile>'')]) | filetype detect')

line 1:   " command that could cause cursor vanish
line 2:   if a:command =~# '^echo' || a:command =~# '^redraw' || a:command =~# '^sign place'
line 3:     call timer_start(0, {-> s:execute(a:command)})
line 4:   else
line 5:     execute a:command
line 5: autocmd! coc_dynamic_content BufReadCmd,FileReadCmd,SourceCmd output:/* call coc#rpc#request('CocAutocmd', ['BufReadCmd','output', expand('<afile>')]) | filetype detect
line 6:     let err = get(g:, 'errmsg', '')
line 7:     " get error from python script run.
line 8:     if !empty(err)
line 9:       unlet g:errmsg
line 10:       throw 'Command error '.err
line 11:     endif
line 12:   endif
286 returning #0

continuing in coc#api#notify

line 3:   catch /.*/
line 4:     call coc#rpc#notify('nvim_error_event', [0, v:exception.' on api "'.a:method.'" '.json_encode(a:args)])
line 5:   endtry
coc#api#notify returning #0

calling coc#api#notify('command', ['autocmd! coc_dynamic_option OptionSe...tch>''), v:option_old, v:option_new])'])

line 1:   try
line 2:     call call(s:funcs[a:method], a:args)
calling 286('autocmd! coc_dynamic_option OptionSet...atch>''), v:option_old, v:option_new])')

line 1:   " command that could cause cursor vanish
line 2:   if a:command =~# '^echo' || a:command =~# '^redraw' || a:command =~# '^sign place'
line 3:     call timer_start(0, {-> s:execute(a:command)})
line 4:   else
line 5:     execute a:command
line 5: autocmd! coc_dynamic_option OptionSet runtimepath call coc#rpc#notify('OptionSet',[expand('<amatch>'), v:option_old, v:option_new])
line 6:     let err = get(g:, 'errmsg', '')
line 7:     " get error from python script run.
line 8:     if !empty(err)
line 9:       unlet g:errmsg
line 10:       throw 'Command error '.err
line 11:     endif
line 12:   endif
286 returning #0

continuing in coc#api#notify

line 3:   catch /.*/
line 4:     call coc#rpc#notify('nvim_error_event', [0, v:exception.' on api "'.a:method.'" '.json_encode(a:args)])
line 5:   endtry
coc#api#notify returning #0

calling coc#api#call('call_function', ['coc#util#all_state', []])

line 1:   let err = v:null
line 2:   let res = v:null
line 3:   try
line 4:     let res = call(s:funcs[a:method], a:args)
calling 284('coc#util#all_state', [])

line 1:   return call(a:method, a:args)
calling coc#util#all_state()

line 1:   return { 'bufnr': bufnr('%'), 'winid': win_getid(), 'bufnrs': map(getbufinfo({'bufloaded': 1}),'v:val["bufnr"]'), 'winids': map(getwininfo(),'v:val["winid"]'), }
coc#util#all_state returning {'bufnr': 1, 'bufnrs': [1], 'winids': [1000], 'winid': 1000}

continuing in 284

284 returning {'bufnr': 1, 'bufnrs': [1], 'winids': [1000], 'winid': 1000}

continuing in coc#api#call

line 5:   catch /.*/
line 6:     let err = v:exception .' on api "'.a:method.'" '.json_encode(a:args)
line 7:   endtry
line 8:   return [err, res]
coc#api#call returning [v:null, {'bufnr': 1, 'bufnrs': [1], 'winids': [1000], 'winid': 1000}]

calling coc#api#call('call_function', ['coc#util#get_bufoptions', [1, 10485760]])

line 1:   let err = v:null
line 2:   let res = v:null
line 3:   try
line 4:     let res = call(s:funcs[a:method], a:args)
calling 284('coc#util#get_bufoptions', [1, 10485760])

line 1:   return call(a:method, a:args)
calling coc#util#get_bufoptions(1, 10485760)

line 1:   if !bufloaded(a:bufnr) | return v:null | endif
line 1:  return v:null | endif
line 1:  endif
line 2:   let bufname = bufname(a:bufnr)
line 3:   let buftype = getbufvar(a:bufnr, '&buftype')
line 4:   let commandline = get(getbufinfo(a:bufnr)[0], 'command', 0) || bufname(a:bufnr) == '[Command Line]'
line 5:   let size = coc#util#bufsize(a:bufnr)
calling coc#util#bufsize(1)

line 1:   if bufnr('%') == a:bufnr
line 2:     return line2byte(line("$") + 1)
coc#util#bufsize returning #-1

continuing in coc#util#get_bufoptions

line 6:   let lines = v:null
line 7:   if getbufvar(a:bufnr, 'coc_enabled', 1) && (buftype == '' || buftype == 'acwrite' || getbufvar(a:bufnr, 'coc_force_attach', 0)) && size != -2 && size < a:max
line 11:     let lines = getbufline(a:bufnr, 1, '$')
line 12:   endif
line 13:   return { 'bufnr': a:bufnr, 'commandline': commandline, 'size': size, 'lines': lines, 'winid': bufwinid(a:bufnr), 'bufname': bufname, 'buftype': buftype, 'previewwindow': v:false, 'eol': getbufvar(a:bufnr, '&eol'), 'variables': coc#util#variables(a:bufnr), 'filetype': getbufvar(a:bufnr, '&filetype'), 'lisp': getbufvar(a:bufnr, '&lisp'), 'iskeyword': getbufvar(a:bufnr, '&iskeyword'), 'changedtick': getbufvar(a:bufnr, 'changedtick'), 'fullpath': empty(bufname) ? '' : fnamemodify(bufname, ':p'),}
calling coc#util#variables(1)

line 1:   let info = getbufinfo(a:bufnr)
line 2:   let variables = empty(info) ? {} : copy(info[0]['variables'])
line 3:   for key in keys(variables)
line 4:     if key !~# '\v^coc'
line 5:       unlet variables[key]
line 6:     endif
line 7:   endfor
line 3:   for key in keys(variables)
line 4:     if key !~# '\v^coc'
line 5:       unlet variables[key]
line 6:     endif
line 7:   endfor
line 8:   return variables
coc#util#variables returning {}

continuing in coc#util#get_bufoptions

coc#util#get_bufoptions returning {'variables': {}, 'lisp': 0, 'size': -...ine': 0, 'fullpath': '', 'winid': 1000}

continuing in 284

284 returning {'variables': {}, 'lisp': 0, 'size': -...ine': 0, 'fullpath': '', 'winid': 1000}

continuing in coc#api#call

line 5:   catch /.*/
line 6:     let err = v:exception .' on api "'.a:method.'" '.json_encode(a:args)
line 7:   endtry
line 8:   return [err, res]
coc#api#call returning [v:null, {'variables': {}, 'lisp': 0, ...ne': 0, 'fullpath': '', 'winid': 1000}]

calling coc#api#call('eval', ['[win_getid(),coc#util#editor_infos()]'])

line 1:   let err = v:null
line 2:   let res = v:null
line 3:   try
line 4:     let res = call(s:funcs[a:method], a:args)
calling 287('[win_getid(),coc#util#editor_infos()]')

line 1:   return eval(a:expr)
calling coc#util#editor_infos()

line 1:   let result = []
line 2:   for info in getwininfo()
line 3:     if !coc#window#is_float(info['winid'])
Searching for "autoload/coc/window.vim" in "/home/Dante/.vim,/home/Dante/.vim/plugged/onedark.vim,/home/Dante/.vim/plugged/onehalf/vim,/home/Dante/.vim/plugged/gruvbox,/home/Dante/.vim/plugged/lightline.vim,/home/Dante/.vim/plugged/vim-tmux-navigator,/home/Dante/.vim/plugged/vimtex,/home/Dante/.vim/plugged/nerdtree,/home/Dante/.vim/plugged/fzf,/home/Dante/.vim/plugged/fzf.vim,/home/Dante/.vim/plugged/vim-wayland-clipboard,/home/Dante/.vim/plugged/coc.nvim,/home/Dante/.vim/plugged/vim-obsession,/usr/share/vim/vimfiles,/usr/share/vim/vim91,/usr/share/vim/vim91/pack/dist/opt/netrw,/usr/share/vim/vimfiles/after,/home/Dante/.vim/plugged/vimtex/after,/home/Dante/.vim/after"
Searching for "/home/Dante/.vim/autoload/coc/window.vim"
Searching for "/home/Dante/.vim/plugged/onedark.vim/autoload/coc/window.vim"
Searching for "/home/Dante/.vim/plugged/onehalf/vim/autoload/coc/window.vim"
Searching for "/home/Dante/.vim/plugged/gruvbox/autoload/coc/window.vim"
Searching for "/home/Dante/.vim/plugged/lightline.vim/autoload/coc/window.vim"
Searching for "/home/Dante/.vim/plugged/vim-tmux-navigator/autoload/coc/window.vim"
Searching for "/home/Dante/.vim/plugged/vimtex/autoload/coc/window.vim"
Searching for "/home/Dante/.vim/plugged/nerdtree/autoload/coc/window.vim"
Searching for "/home/Dante/.vim/plugged/fzf/autoload/coc/window.vim"
Searching for "/home/Dante/.vim/plugged/fzf.vim/autoload/coc/window.vim"
Searching for "/home/Dante/.vim/plugged/vim-wayland-clipboard/autoload/coc/window.vim"
Searching for "/home/Dante/.vim/plugged/coc.nvim/autoload/coc/window.vim"
chdir(/home/Dante/.vim/plugged/coc.nvim/autoload/coc)
fchdir() to previous dir
line 3: sourcing "/home/Dante/.vim/plugged/coc.nvim/autoload/coc/window.vim"
line 1: let g:coc_max_treeview_width = get(g:, 'coc_max_treeview_width', 40)
line 2: let s:is_vim = !has('nvim')
line 3: 
line 4: " Get tabpagenr of winid, return -1 if window doesn't exist
line 5: function! coc#window#tabnr(winid) abort
line 15: 
line 16: " (1, 0) based line, column
line 17: function! coc#window#get_cursor(winid) abort
line 25: 
line 26: " Check if winid visible on current tabpage
line 27: function! coc#window#visible(winid) abort
line 44: 
line 45: " winid is popup and shown
line 46: function! s:visible_popup(winid) abort
line 53: 
line 54: " Return v:null when name or window doesn't exist,
line 55: " 'getwinvar' only works on window of current tab
line 56: function! coc#window#get_var(winid, name, ...) abort
line 79: 
line 80: " Not throw like setwinvar
line 81: function! coc#window#set_var(winid, name, value) abort
line 100: 
line 101: function! coc#window#is_float(winid) abort
line 113: 
line 114: " Reset current lnum & topline of window
line 115: function! coc#window#restview(winid, lnum, topline) abort
line 125: 
line 126: function! coc#window#set_height(winid, height) abort
line 136: 
line 137: function! coc#window#adjust_width(winid) abort
line 156: 
line 157: " Get single window by window variable, current tab only
line 158: function! coc#window#find(key, val) abort
line 167: 
line 168: " Visible buffer numbers
line 169: function! coc#window#bufnrs() abort
line 178: 
line 179: " Avoid errors
line 180: function! coc#window#close(winid) abort
line 196: 
line 197: function! coc#window#visible_range() abort
line 205: 
line 206: function! coc#window#visible_ranges(bufnr) abort
finished sourcing /home/Dante/.vim/plugged/coc.nvim/autoload/coc/window.vim
continuing in coc#util#editor_infos
calling coc#window#is_float(1000)

line 1:   if s:is_vim
line 2:     try
line 3:       return !empty(popup_getpos(a:winid))
Exception thrown: Vim(return):E993: Window 1000 is not a popup window

line 4:     catch /^Vim\%((\a\+)\)\=:E993/
Exception caught: Vim(return):E993: Window 1000 is not a popup window

line 5:       return 0
Exception finished: Vim(return):E993: Window 1000 is not a popup window

:return 0 made pending

line 6:     endtry
:return 0 resumed

coc#window#is_float returning #0

continuing in coc#util#editor_infos

line 4:       let bufnr = info['bufnr']
line 5:       let buftype = getbufvar(bufnr, '&buftype')
line 6:       if buftype !=# '' && buftype !=# 'acwrite'
line 7:         continue
line 8:       endif
line 9:       let bufname = bufname(bufnr)
line 10:       call add(result, { 'winid': info['winid'], 'bufnr': bufnr, 'tabid': coc#util#tabnr_id(info['tabnr']), 'fullpath': empty(bufname) ? '' : fnamemodify(bufname, ':p'), })
calling coc#util#tabnr_id(1)

line 1:   return s:is_vim ? coc#api#get_tabid(a:tabnr) : nvim_list_tabpages()[a:tabnr - 1]
calling coc#api#get_tabid(1)

line 1:   return s:tabnr_id(a:nr)
calling <SNR>50_tabnr_id(1)

line 1:   let tid = gettabvar(a:nr, '__tid', -1)
line 2:   if tid == -1
line 3:     let tid = s:tab_id
line 4:     call settabvar(a:nr, '__tid', tid)
line 5:     let s:tab_id = s:tab_id + 1
line 6:   endif
line 7:   return tid
<SNR>50_tabnr_id returning #1

continuing in coc#api#get_tabid

coc#api#get_tabid returning #1

continuing in coc#util#tabnr_id

coc#util#tabnr_id returning #1

continuing in coc#util#editor_infos

line 16:     endif
line 17:   endfor
line 2:   for info in getwininfo()
line 3:     if !coc#window#is_float(info['winid'])
line 4:       let bufnr = info['bufnr']
line 5:       let buftype = getbufvar(bufnr, '&buftype')
line 6:       if buftype !=# '' && buftype !=# 'acwrite'
line 7:         continue
line 8:       endif
line 9:       let bufname = bufname(bufnr)
line 10:       call add(result, { 'winid': info['winid'], 'bufnr': bufnr, 'tabid': coc#util#tabnr_id(info['tabnr']), 'fullpath': empty(bufname) ? '' : fnamemodify(bufname, ':p'), })
line 16:     endif
line 17:   endfor
line 18:   return result
coc#util#editor_infos returning [{'bufnr': 1, 'tabid': 1, 'fullpath': '', 'winid': 1000}]

continuing in 287

287 returning [1000, [{'bufnr': 1, 'tabid': 1, 'fullpath': '', 'winid': 1000}]]

continuing in coc#api#call

line 5:   catch /.*/
line 6:     let err = v:exception .' on api "'.a:method.'" '.json_encode(a:args)
line 7:   endtry
line 8:   return [err, res]
coc#api#call returning [v:null, [1000, [{'bufnr': 1, 'tabid': 1, 'fullpath': '', 'winid': 1000}]]]

calling coc#api#call('call_function', ['coc#util#get_editoroption', [1000]])

line 1:   let err = v:null
line 2:   let res = v:null
line 3:   try
line 4:     let res = call(s:funcs[a:method], a:args)
calling 284('coc#util#get_editoroption', [1000])

line 1:   return call(a:method, a:args)
calling coc#util#get_editoroption(1000)

line 1:   let info = get(getwininfo(a:winid), 0, v:null)
line 2:   if empty(info) || coc#window#is_float(a:winid)
calling coc#window#is_float(1000)

line 1:   if s:is_vim
line 2:     try
line 3:       return !empty(popup_getpos(a:winid))
Exception thrown: Vim(return):E993: Window 1000 is not a popup window

line 4:     catch /^Vim\%((\a\+)\)\=:E993/
Exception caught: Vim(return):E993: Window 1000 is not a popup window

line 5:       return 0
Exception finished: Vim(return):E993: Window 1000 is not a popup window

:return 0 made pending

line 6:     endtry
:return 0 resumed

coc#window#is_float returning #0

continuing in coc#util#get_editoroption

line 3:     return v:null
line 4:   endif
line 5:   let bufnr = info['bufnr']
line 6:   let buftype = getbufvar(bufnr, '&buftype')
line 7:   " avoid window for other purpose.
line 8:   if buftype !=# '' && buftype !=# 'acwrite'
line 9:     return v:null
line 10:   endif
line 11:   let tabSize = getbufvar(bufnr, '&shiftwidth')
line 12:   if tabSize == 0
line 13:     let tabSize = getbufvar(bufnr, '&tabstop')
line 14:   endif
line 15:   return { 'bufnr': bufnr, 'winid': a:winid, 'tabpageid': coc#util#tabnr_id(info['tabnr']), 'winnr': winnr(), 'visibleRanges': s:visible_ranges(a:winid), 'tabSize': tabSize, 'insertSpaces': getbufvar(bufnr, '&expandtab') ? v:true : v:false }
calling coc#util#tabnr_id(1)

line 1:   return s:is_vim ? coc#api#get_tabid(a:tabnr) : nvim_list_tabpages()[a:tabnr - 1]
calling coc#api#get_tabid(1)

line 1:   return s:tabnr_id(a:nr)
calling <SNR>50_tabnr_id(1)

line 1:   let tid = gettabvar(a:nr, '__tid', -1)
line 2:   if tid == -1
line 3:     let tid = s:tab_id
line 4:     call settabvar(a:nr, '__tid', tid)
line 5:     let s:tab_id = s:tab_id + 1
line 6:   endif
line 7:   return tid
<SNR>50_tabnr_id returning #1

continuing in coc#api#get_tabid

coc#api#get_tabid returning #1

continuing in coc#util#tabnr_id

coc#util#tabnr_id returning #1

continuing in coc#util#get_editoroption

calling <SNR>48_visible_ranges(1000)

line 1:   let info = getwininfo(a:winid)[0]
line 2:   let res = []
line 3:   if !has_key(info, 'topline') || !has_key(info, 'botline')
line 4:     return res
line 5:   endif
line 6:   let begin = 0
line 7:   let curr = info['topline']
line 8:   let max = info['botline']
line 9:   if win_getid() != a:winid
line 10:     return [[curr, max]]
line 11:   endif
line 12:   while curr <= max
line 13:     let closedend = foldclosedend(curr)
line 14:     if closedend == -1
line 15:       let begin = begin == 0 ? curr : begin
line 16:       if curr == max
line 17:         call add(res, [begin, curr])
line 18:       endif
line 19:       let curr = curr + 1
line 20:     else
line 21:       if begin != 0
line 22:         call add(res, [begin, curr - 1])
line 23:         let begin = closedend + 1
line 24:       endif
line 25:       let curr = closedend + 1
line 26:     endif
line 27:   endwhile
line 12:   while curr <= max
line 13:     let closedend = foldclosedend(curr)
line 14:     if closedend == -1
line 15:       let begin = begin == 0 ? curr : begin
line 16:       if curr == max
line 17:         call add(res, [begin, curr])
line 18:       endif
line 19:       let curr = curr + 1
line 20:     else
line 21:       if begin != 0
line 22:         call add(res, [begin, curr - 1])
line 23:         let begin = closedend + 1
line 24:       endif
line 25:       let curr = closedend + 1
line 26:     endif
line 27:   endwhile
line 28:   return res
<SNR>48_visible_ranges returning [[1, 1]]

continuing in coc#util#get_editoroption

coc#util#get_editoroption returning {'bufnr': 1, 'winnr': 1, 'tabSize': 4,...[1, 1]], 'winid': 1000, 'tabpageid': 1}

continuing in 284

284 returning {'bufnr': 1, 'winnr': 1, 'tabSize': 4,...[1, 1]], 'winid': 1000, 'tabpageid': 1}

continuing in coc#api#call

line 5:   catch /.*/
line 6:     let err = v:exception .' on api "'.a:method.'" '.json_encode(a:args)
line 7:   endtry
line 8:   return [err, res]
coc#api#call returning [v:null, {'bufnr': 1, 'winnr': 1, 'tab...1, 1]], 'winid': 1000, 'tabpageid': 1}]

calling coc#api#notify('set_var', ['coc_workspace_initialized', v:true])

line 1:   try
line 2:     call call(s:funcs[a:method], a:args)
calling 272('coc_workspace_initialized', v:true)

line 1:   execute 'let g:'.a:name.'= a:value'
line 1: let g:coc_workspace_initialized= a:value
line 2:   return v:null
272 returning v:null

continuing in coc#api#notify

line 3:   catch /.*/
line 4:     call coc#rpc#notify('nvim_error_event', [0, v:exception.' on api "'.a:method.'" '.json_encode(a:args)])
line 5:   endtry
coc#api#notify returning #0

calling coc#api#notify('call_function', ['coc#ui#check_pum_keymappings', ['always']])

line 1:   try
line 2:     call call(s:funcs[a:method], a:args)
calling 284('coc#ui#check_pum_keymappings', ['always'])

line 1:   return call(a:method, a:args)
Searching for "autoload/coc/ui.vim" in "/home/Dante/.vim,/home/Dante/.vim/plugged/onedark.vim,/home/Dante/.vim/plugged/onehalf/vim,/home/Dante/.vim/plugged/gruvbox,/home/Dante/.vim/plugged/lightline.vim,/home/Dante/.vim/plugged/vim-tmux-navigator,/home/Dante/.vim/plugged/vimtex,/home/Dante/.vim/plugged/nerdtree,/home/Dante/.vim/plugged/fzf,/home/Dante/.vim/plugged/fzf.vim,/home/Dante/.vim/plugged/vim-wayland-clipboard,/home/Dante/.vim/plugged/coc.nvim,/home/Dante/.vim/plugged/vim-obsession,/usr/share/vim/vimfiles,/usr/share/vim/vim91,/usr/share/vim/vim91/pack/dist/opt/netrw,/usr/share/vim/vimfiles/after,/home/Dante/.vim/plugged/vimtex/after,/home/Dante/.vim/after"
Searching for "/home/Dante/.vim/autoload/coc/ui.vim"
Searching for "/home/Dante/.vim/plugged/onedark.vim/autoload/coc/ui.vim"
Searching for "/home/Dante/.vim/plugged/onehalf/vim/autoload/coc/ui.vim"
Searching for "/home/Dante/.vim/plugged/gruvbox/autoload/coc/ui.vim"
Searching for "/home/Dante/.vim/plugged/lightline.vim/autoload/coc/ui.vim"
Searching for "/home/Dante/.vim/plugged/vim-tmux-navigator/autoload/coc/ui.vim"
Searching for "/home/Dante/.vim/plugged/vimtex/autoload/coc/ui.vim"
Searching for "/home/Dante/.vim/plugged/nerdtree/autoload/coc/ui.vim"
Searching for "/home/Dante/.vim/plugged/fzf/autoload/coc/ui.vim"
Searching for "/home/Dante/.vim/plugged/fzf.vim/autoload/coc/ui.vim"
Searching for "/home/Dante/.vim/plugged/vim-wayland-clipboard/autoload/coc/ui.vim"
Searching for "/home/Dante/.vim/plugged/coc.nvim/autoload/coc/ui.vim"
chdir(/home/Dante/.vim/plugged/coc.nvim/autoload/coc)
fchdir() to previous dir
line 1: sourcing "/home/Dante/.vim/plugged/coc.nvim/autoload/coc/ui.vim"
line 1: let s:is_vim = !has('nvim')
line 2: let s:is_win = has('win32') || has('win64')
line 3: let s:is_mac = has('mac')
line 4: let s:sign_api = exists('*sign_getplaced') && exists('*sign_place')
line 5: let s:sign_groups = []
line 6: let s:outline_preview_bufnr = 0
line 7: 
line 8: " Check <Tab> and <CR>
line 9: function! coc#ui#check_pum_keymappings(trigger) abort
line 29: 
line 30: function! coc#ui#quickpick(title, items, cb) abort
line 60: 
line 61: " cmd, cwd
line 62: function! coc#ui#open_terminal(opts) abort
line 121: 
line 122: " run command in terminal
line 123: function! coc#ui#run_terminal(opts, cb)
line 136: 
line 137: function! coc#ui#echo_hover(msg)
line 143: 
line 144: function! coc#ui#echo_messages(hl, msgs)
line 156: 
line 157: function! coc#ui#preview_info(lines, filetype, ...) abort
line 174: 
line 175: function! coc#ui#open_files(files)
line 205: 
line 206: function! coc#ui#echo_lines(lines)
line 209: 
line 210: function! coc#ui#echo_signatures(signatures) abort
line 220: 
line 221: function! s:echo_signature(parts)
line 232: 
line 233: function! coc#ui#iterm_open(dir)
line 249: 
line 250: function! s:osascript(...) abort
line 255: 
line 256: function! s:system(cmd)
line 264: 
line 265: function! coc#ui#set_lines(bufnr, changedtick, original, replacement, start, end, changes, cursor, col) abort
line 307: 
line 308: function! coc#ui#change_lines(bufnr, list) abort
line 328: 
line 329: function! coc#ui#open_url(url)
line 352: 
line 353: function! coc#ui#rename_file(oldPath, newPath, write) abort
line 386: 
line 387: " System is case in sensitive and newPath have different case.
line 388: function! coc#ui#safe_rename(bufnr, oldPath, newPath, write) abort
line 407: 
line 408: function! coc#ui#sign_unplace() abort
line 415: 
line 416: function! coc#ui#update_signs(bufnr, group, signs) abort
line 429: 
line 430: function! coc#ui#outline_preview(config) abort
line 476: 
line 477: function! coc#ui#outline_close_preview() abort
line 483: 
line 484: " Ignore error from autocmd when file opened
line 485: function! coc#ui#safe_open(cmd, file) abort
line 495: 
line 496: " Use noa to setloclist, avoid BufWinEnter autocmd
line 497: function! coc#ui#setloclist(nr, items, action, title) abort
line 506: 
line 507: function! coc#ui#get_mouse() abort
line 513: 
line 514: " viewId - identifier of tree view
line 515: " bufnr - bufnr tree view
line 516: " winid - winid of tree view
line 517: " bufname -  bufname of tree view
line 518: " command - split command
line 519: " optional options - bufhidden, canSelectMany, winfixwidth
line 520: function! coc#ui#create_tree(opts) abort
line 549: 
line 550: " valid window id or -1
line 551: function! s:get_tree_winid(opts) abort
line 562: 
line 563: function! s:set_tree_defaults(opts) abort
finished sourcing /home/Dante/.vim/plugged/coc.nvim/autoload/coc/ui.vim
continuing in 284
calling coc#ui#check_pum_keymappings('always')

line 1:   if get(g:, 'coc_disable_mappings_check', 0) == 1
line 2:     return
line 3:   endif
line 4:   if a:trigger !=# 'none'
line 5:     for key in ['<cr>', '<tab>', '<c-y>', '<s-tab>']
line 6:       let arg = maparg(key, 'i', 0, 1)
line 7:       if get(arg, 'expr', 0)
line 8:         let rhs = get(arg, 'rhs', '')
line 9:         if rhs =~# '\<pumvisible()' && rhs !~# '\<coc#pum#visible()'
line 10:           let rhs = substitute(rhs, '\Cpumvisible()', 'coc#pum#visible()', 'g')
line 11:           let rhs = substitute(rhs, '\c"\\<C-n>"', 'coc#pum#next(1)', '')
line 12:           let rhs = substitute(rhs, '\c"\\<C-p>"', 'coc#pum#prev(1)', '')
line 13:           let rhs = substitute(rhs, '\c"\\<C-y>"', 'coc#pum#confirm()', '')
line 14:           execute 'inoremap <silent><nowait><expr> '.arg['lhs'].' '.rhs
line 15:         endif
line 16:       endif
line 17:     endfor
line 5:     for key in ['<cr>', '<tab>', '<c-y>', '<s-tab>']
line 6:       let arg = maparg(key, 'i', 0, 1)
line 7:       if get(arg, 'expr', 0)
line 8:         let rhs = get(arg, 'rhs', '')
line 9:         if rhs =~# '\<pumvisible()' && rhs !~# '\<coc#pum#visible()'
line 10:           let rhs = substitute(rhs, '\Cpumvisible()', 'coc#pum#visible()', 'g')
line 11:           let rhs = substitute(rhs, '\c"\\<C-n>"', 'coc#pum#next(1)', '')
line 12:           let rhs = substitute(rhs, '\c"\\<C-p>"', 'coc#pum#prev(1)', '')
line 13:           let rhs = substitute(rhs, '\c"\\<C-y>"', 'coc#pum#confirm()', '')
line 14:           execute 'inoremap <silent><nowait><expr> '.arg['lhs'].' '.rhs
line 15:         endif
line 16:       endif
line 17:     endfor
line 5:     for key in ['<cr>', '<tab>', '<c-y>', '<s-tab>']
line 6:       let arg = maparg(key, 'i', 0, 1)
line 7:       if get(arg, 'expr', 0)
line 8:         let rhs = get(arg, 'rhs', '')
line 9:         if rhs =~# '\<pumvisible()' && rhs !~# '\<coc#pum#visible()'
line 10:           let rhs = substitute(rhs, '\Cpumvisible()', 'coc#pum#visible()', 'g')
line 11:           let rhs = substitute(rhs, '\c"\\<C-n>"', 'coc#pum#next(1)', '')
line 12:           let rhs = substitute(rhs, '\c"\\<C-p>"', 'coc#pum#prev(1)', '')
line 13:           let rhs = substitute(rhs, '\c"\\<C-y>"', 'coc#pum#confirm()', '')
line 14:           execute 'inoremap <silent><nowait><expr> '.arg['lhs'].' '.rhs
line 15:         endif
line 16:       endif
line 17:     endfor
line 5:     for key in ['<cr>', '<tab>', '<c-y>', '<s-tab>']
line 6:       let arg = maparg(key, 'i', 0, 1)
line 7:       if get(arg, 'expr', 0)
line 8:         let rhs = get(arg, 'rhs', '')
line 9:         if rhs =~# '\<pumvisible()' && rhs !~# '\<coc#pum#visible()'
line 10:           let rhs = substitute(rhs, '\Cpumvisible()', 'coc#pum#visible()', 'g')
line 11:           let rhs = substitute(rhs, '\c"\\<C-n>"', 'coc#pum#next(1)', '')
line 12:           let rhs = substitute(rhs, '\c"\\<C-p>"', 'coc#pum#prev(1)', '')
line 13:           let rhs = substitute(rhs, '\c"\\<C-y>"', 'coc#pum#confirm()', '')
line 14:           execute 'inoremap <silent><nowait><expr> '.arg['lhs'].' '.rhs
line 15:         endif
line 16:       endif
line 17:     endfor
line 5:     for key in ['<cr>', '<tab>', '<c-y>', '<s-tab>']
line 6:       let arg = maparg(key, 'i', 0, 1)
line 7:       if get(arg, 'expr', 0)
line 8:         let rhs = get(arg, 'rhs', '')
line 9:         if rhs =~# '\<pumvisible()' && rhs !~# '\<coc#pum#visible()'
line 10:           let rhs = substitute(rhs, '\Cpumvisible()', 'coc#pum#visible()', 'g')
line 11:           let rhs = substitute(rhs, '\c"\\<C-n>"', 'coc#pum#next(1)', '')
line 12:           let rhs = substitute(rhs, '\c"\\<C-p>"', 'coc#pum#prev(1)', '')
line 13:           let rhs = substitute(rhs, '\c"\\<C-y>"', 'coc#pum#confirm()', '')
line 14:           execute 'inoremap <silent><nowait><expr> '.arg['lhs'].' '.rhs
line 15:         endif
line 16:       endif
line 17:     endfor
line 18:   endif
coc#ui#check_pum_keymappings returning #0

continuing in 284

284 returning #0

continuing in coc#api#notify

line 3:   catch /.*/
line 4:     call coc#rpc#notify('nvim_error_event', [0, v:exception.' on api "'.a:method.'" '.json_encode(a:args)])
line 5:   endtry
coc#api#notify returning #0

calling coc#api#notify('call_atomic', [[['nvim_command', ['sign define CocEr...intLine texthl=CocHintSign text=>>']]]])

line 1:   try
line 2:     call call(s:funcs[a:method], a:args)
calling 280([['nvim_command', ['sign define CocErr...HintLine texthl=CocHintSign text=>>']]])

line 1:   let results = []
line 2:   for i in range(len(a:calls))
line 3:     let [key, arglist] = a:calls[i]
line 4:     let name = key[5:]
line 5:     try
line 6:       call add(results, call(s:funcs[name], arglist))
calling 286('sign define CocError linehl=CocErrorLine texthl=CocErrorSign text=>>')

line 1:   " command that could cause cursor vanish
line 2:   if a:command =~# '^echo' || a:command =~# '^redraw' || a:command =~# '^sign place'
line 3:     call timer_start(0, {-> s:execute(a:command)})
line 4:   else
line 5:     execute a:command
line 5: sign define CocError linehl=CocErrorLine texthl=CocErrorSign text=>>
line 6:     let err = get(g:, 'errmsg', '')
line 7:     " get error from python script run.
line 8:     if !empty(err)
line 9:       unlet g:errmsg
line 10:       throw 'Command error '.err
line 11:     endif
line 12:   endif
286 returning #0

continuing in 280

line 7:     catch /.*/
line 8:       return [results, [i, "VimException(".s:inspect_type(v:exception).")", v:exception . ' on function "'.name.'"']]
line 9:     endtry
line 10:   endfor
line 2:   for i in range(len(a:calls))
line 3:     let [key, arglist] = a:calls[i]
line 4:     let name = key[5:]
line 5:     try
line 6:       call add(results, call(s:funcs[name], arglist))
calling 286('sign define CocWarning linehl=CocWarningLine texthl=CocWarningSign text=')

line 1:   " command that could cause cursor vanish
line 2:   if a:command =~# '^echo' || a:command =~# '^redraw' || a:command =~# '^sign place'
line 3:     call timer_start(0, {-> s:execute(a:command)})
line 4:   else
line 5:     execute a:command
line 5: sign define CocWarning linehl=CocWarningLine texthl=CocWarningSign text=
line 6:     let err = get(g:, 'errmsg', '')
line 7:     " get error from python script run.
line 8:     if !empty(err)
line 9:       unlet g:errmsg
line 10:       throw 'Command error '.err
line 11:     endif
line 12:   endif
286 returning #0

continuing in 280

line 7:     catch /.*/
line 8:       return [results, [i, "VimException(".s:inspect_type(v:exception).")", v:exception . ' on function "'.name.'"']]
line 9:     endtry
line 10:   endfor
line 2:   for i in range(len(a:calls))
line 3:     let [key, arglist] = a:calls[i]
line 4:     let name = key[5:]
line 5:     try
line 6:       call add(results, call(s:funcs[name], arglist))
calling 286('sign define CocInfo linehl=CocInfoLine texthl=CocInfoSign text=>>')

line 1:   " command that could cause cursor vanish
line 2:   if a:command =~# '^echo' || a:command =~# '^redraw' || a:command =~# '^sign place'
line 3:     call timer_start(0, {-> s:execute(a:command)})
line 4:   else
line 5:     execute a:command
line 5: sign define CocInfo linehl=CocInfoLine texthl=CocInfoSign text=>>
line 6:     let err = get(g:, 'errmsg', '')
line 7:     " get error from python script run.
line 8:     if !empty(err)
line 9:       unlet g:errmsg
line 10:       throw 'Command error '.err
line 11:     endif
line 12:   endif
286 returning #0

continuing in 280

line 7:     catch /.*/
line 8:       return [results, [i, "VimException(".s:inspect_type(v:exception).")", v:exception . ' on function "'.name.'"']]
line 9:     endtry
line 10:   endfor
line 2:   for i in range(len(a:calls))
line 3:     let [key, arglist] = a:calls[i]
line 4:     let name = key[5:]
line 5:     try
line 6:       call add(results, call(s:funcs[name], arglist))
calling 286('sign define CocHint linehl=CocHintLine texthl=CocHintSign text=>>')

line 1:   " command that could cause cursor vanish
line 2:   if a:command =~# '^echo' || a:command =~# '^redraw' || a:command =~# '^sign place'
line 3:     call timer_start(0, {-> s:execute(a:command)})
line 4:   else
line 5:     execute a:command
line 5: sign define CocHint linehl=CocHintLine texthl=CocHintSign text=>>
line 6:     let err = get(g:, 'errmsg', '')
line 7:     " get error from python script run.
line 8:     if !empty(err)
line 9:       unlet g:errmsg
line 10:       throw 'Command error '.err
line 11:     endif
line 12:   endif
286 returning #0

continuing in 280

line 7:     catch /.*/
line 8:       return [results, [i, "VimException(".s:inspect_type(v:exception).")", v:exception . ' on function "'.name.'"']]
line 9:     endtry
line 10:   endfor
line 2:   for i in range(len(a:calls))
line 3:     let [key, arglist] = a:calls[i]
line 4:     let name = key[5:]
line 5:     try
line 6:       call add(results, call(s:funcs[name], arglist))
line 7:     catch /.*/
line 8:       return [results, [i, "VimException(".s:inspect_type(v:exception).")", v:exception . ' on function "'.name.'"']]
line 9:     endtry
line 10:   endfor
line 11:   return [results, v:null]
280 returning [[0, 0, 0, 0], v:null]

continuing in coc#api#notify

line 3:   catch /.*/
line 4:     call coc#rpc#notify('nvim_error_event', [0, v:exception.' on api "'.a:method.'" '.json_encode(a:args)])
line 5:   endtry
coc#api#notify returning #0

calling coc#api#notify('call_atomic', [[['nvim_set_var', ['coc_service_initi...c#util#do_autocmd', ['CocNvimInit']]]]])

line 1:   try
line 2:     call call(s:funcs[a:method], a:args)
calling 280([['nvim_set_var', ['coc_service_initia...oc#util#do_autocmd', ['CocNvimInit']]]])

line 1:   let results = []
line 2:   for i in range(len(a:calls))
line 3:     let [key, arglist] = a:calls[i]
line 4:     let name = key[5:]
line 5:     try
line 6:       call add(results, call(s:funcs[name], arglist))
calling 272('coc_service_initialized', 1)

line 1:   execute 'let g:'.a:name.'= a:value'
line 1: let g:coc_service_initialized= a:value
line 2:   return v:null
272 returning v:null

continuing in 280

line 7:     catch /.*/
line 8:       return [results, [i, "VimException(".s:inspect_type(v:exception).")", v:exception . ' on function "'.name.'"']]
line 9:     endtry
line 10:   endfor
line 2:   for i in range(len(a:calls))
line 3:     let [key, arglist] = a:calls[i]
line 4:     let name = key[5:]
line 5:     try
line 6:       call add(results, call(s:funcs[name], arglist))
calling 284('coc#util#do_autocmd', ['CocNvimInit'])

line 1:   return call(a:method, a:args)
calling coc#util#do_autocmd('CocNvimInit')

line 1:   if exists('#User#'.a:name)
line 2:     exe 'doautocmd <nomodeline> User '.a:name
line 3:   endif
coc#util#do_autocmd returning #0

continuing in 284

284 returning #0

continuing in 280

line 7:     catch /.*/
line 8:       return [results, [i, "VimException(".s:inspect_type(v:exception).")", v:exception . ' on function "'.name.'"']]
line 9:     endtry
line 10:   endfor
line 2:   for i in range(len(a:calls))
line 3:     let [key, arglist] = a:calls[i]
line 4:     let name = key[5:]
line 5:     try
line 6:       call add(results, call(s:funcs[name], arglist))
line 7:     catch /.*/
line 8:       return [results, [i, "VimException(".s:inspect_type(v:exception).")", v:exception . ' on function "'.name.'"']]
line 9:     endtry
line 10:   endfor
line 11:   return [results, v:null]
280 returning [[v:null, 0], v:null]

continuing in coc#api#notify

line 3:   catch /.*/
line 4:     call coc#rpc#notify('nvim_error_event', [0, v:exception.' on api "'.a:method.'" '.json_encode(a:args)])
line 5:   endtry
coc#api#notify returning #0

calling lightline#link()

line 1:   let mode = get(s:lightline._mode_, a:0 ? a:1 : mode(), 'normal')
line 2:   if s:mode ==# mode
line 3:     return ''
lightline#link returning ''

calling lightline#mode()

line 1:   return get(s:lightline.mode_map, mode(), '')
lightline#mode returning 'NORMAL'

calling lightline#link()

line 1:   let mode = get(s:lightline._mode_, a:0 ? a:1 : mode(), 'normal')
line 2:   if s:mode ==# mode
line 3:     return ''
lightline#link returning ''

calling lightline#mode()

line 1:   return get(s:lightline.mode_map, mode(), '')
lightline#mode returning 'NORMAL'

Executing CursorHold Autocommands for "*"
autocommand call coc#float#check_related()

Executing: call coc#float#check_related()
Searching for "autoload/coc/float.vim" in "/home/Dante/.vim,/home/Dante/.vim/plugged/onedark.vim,/home/Dante/.vim/plugged/onehalf/vim,/home/Dante/.vim/plugged/gruvbox,/home/Dante/.vim/plugged/lightline.vim,/home/Dante/.vim/plugged/vim-tmux-navigator,/home/Dante/.vim/plugged/vimtex,/home/Dante/.vim/plugged/nerdtree,/home/Dante/.vim/plugged/fzf,/home/Dante/.vim/plugged/fzf.vim,/home/Dante/.vim/plugged/vim-wayland-clipboard,/home/Dante/.vim/plugged/coc.nvim,/home/Dante/.vim/plugged/vim-obsession,/usr/share/vim/vimfiles,/usr/share/vim/vim91,/usr/share/vim/vim91/pack/dist/opt/netrw,/usr/share/vim/vimfiles/after,/home/Dante/.vim/plugged/vimtex/after,/home/Dante/.vim/after"
Searching for "/home/Dante/.vim/autoload/coc/float.vim"
Searching for "/home/Dante/.vim/plugged/onedark.vim/autoload/coc/float.vim"
Searching for "/home/Dante/.vim/plugged/onehalf/vim/autoload/coc/float.vim"
Searching for "/home/Dante/.vim/plugged/gruvbox/autoload/coc/float.vim"
Searching for "/home/Dante/.vim/plugged/lightline.vim/autoload/coc/float.vim"
Searching for "/home/Dante/.vim/plugged/vim-tmux-navigator/autoload/coc/float.vim"
Searching for "/home/Dante/.vim/plugged/vimtex/autoload/coc/float.vim"
Searching for "/home/Dante/.vim/plugged/nerdtree/autoload/coc/float.vim"
Searching for "/home/Dante/.vim/plugged/fzf/autoload/coc/float.vim"
Searching for "/home/Dante/.vim/plugged/fzf.vim/autoload/coc/float.vim"
Searching for "/home/Dante/.vim/plugged/vim-wayland-clipboard/autoload/coc/float.vim"
Searching for "/home/Dante/.vim/plugged/coc.nvim/autoload/coc/float.vim"
chdir(/home/Dante/.vim/plugged/coc.nvim/autoload/coc)
fchdir() to previous dir
line 0: sourcing "/home/Dante/.vim/plugged/coc.nvim/autoload/coc/float.vim"
line 1: scriptencoding utf-8
line 2: let s:is_vim = !has('nvim')
line 3: let s:borderchars = get(g:, 'coc_borderchars', ['', '', '', '', '', '', '', ''])
line 4: let s:rounded_borderchars = s:borderchars[0:3] + ['', '', '', '']
line 5: let s:borderjoinchars = get(g:, 'coc_border_joinchars', ['', '', '', ''])
line 6: let s:popup_list_api = exists('*popup_list')
line 7: " Popup ids, used when popup_list() doesn't exist
line 8: let s:popup_list = []
line 9: let s:pad_bufnr = -1
line 10: 
line 11: " Check visible float/popup exists.
line 12: function! coc#float#has_float(...) abort
line 15: 
line 16: function! coc#float#close_all(...) abort
line 27: 
line 28: function! coc#float#jump() abort
line 36: 
line 37: function! coc#float#valid(winid) abort
line 54: 
line 55: function! coc#float#get_height(winid) abort
line 65: 
line 66: function! coc#float#change_height(winid, delta) abort
line 93: 
line 94: " create or config float window, returns [winid, bufnr], config including:
line 95: " - relative:  could be 'editor' 'cursor'
line 96: " - row: line count relative to editor/cursor, nagetive number means abover cursor.
line 97: " - col: column count relative to editor/cursor, nagetive number means left of cursor.
line 98: " - width: content width without border and title.
line 99: " - height: content height without border and title.
line 100: " - lines: (optional) lines to insert, default to v:null.
line 101: " - title: (optional) title.
line 102: " - border: (optional) border as number list, like [1, 1, 1 ,1].
line 103: " - cursorline: (optional) enable cursorline when is 1.
line 104: " - autohide: (optional) window should be closed on CursorMoved when is 1.
line 105: " - highlight: (optional) highlight of window, default to 'CocFloating'
line 106: " - borderhighlight: (optional) should be array or string for border highlights,
line 107: "   highlight all borders with first value.
line 108: " - close: (optional) show close button when is 1.
line 109: " - highlights: (optional) highlight items.
line 110: " - buttons: (optional) array of button text for create buttons at bottom.
line 111: " - codes: (optional) list of CodeBlock.
line 112: " - winblend: (optional) winblend option for float window, neovim only.
line 113: " - shadow:  (optional) use shadow as border style, neovim only.
line 114: " - focusable:  (optional) neovim only, default to true.
line 115: " - scrollinside: (optional) neovim only, create scrollbar inside window.
line 116: " - rounded: (optional) use rounded borderchars, ignored when borderchars exists.
line 117: " - zindex: (optional) zindex of window, default 50.
line 118: " - borderchars: (optional) borderchars, should be length of 8
line 119: " - nopad: (optional) not add pad when 1
line 120: " - index: (optional) line index
line 121: function! coc#float#create_float_win(winid, bufnr, config) abort
line 270: 
line 271: function! coc#float#nvim_create_related(winid, config, opts) abort
line 303: 
line 304: " border window for neovim, content config with border
line 305: function! coc#float#nvim_border_win(config, borderchars, winid, border, title, hasbtn, hlgroup, shadow, related) abort
line 339: 
line 340: " neovim only
line 341: function! coc#float#nvim_close_btn(config, winid, border, hlgroup, related) abort
line 365: 
line 366: " Create padding window by config of current window & border config
line 367: function! coc#float#nvim_right_pad(config, winid, shadow, related) abort
line 393: 
line 394: " draw buttons window for window with config
line 395: function! coc#float#nvim_buttons(config, winid, buttons, getchar, borderbottom, pad, borderhighlight, shadow, related) abort
line 441: 
line 442: function! coc#float#getchar(winid, keys) abort
line 474: 
line 475: " Create or refresh scrollbar for winid
line 476: " Need called on create, config, buffer change, scrolled
line 477: function! coc#float#nvim_scrollbar(winid) abort
line 573: 
line 574: function! coc#float#create_border_lines(border, borderchars, title, width, height, hasbtn) abort
line 603: 
line 604: " Close float window by id
line 605: function! coc#float#close(winid, ...) abort
line 611: 
line 612: " Get visible float windows
line 613: function! coc#float#get_float_win_list(...) abort
line 639: 
line 640: function! coc#float#get_float_by_kind(kind) abort
line 658: 
line 659: " Check if a float window is scrollable
line 660: function! coc#float#scrollable(winid) abort
line 683: 
line 684: function! coc#float#has_scroll() abort
line 688: 
line 689: function! coc#float#scroll(forward, ...)
line 703: 
line 704: function! coc#float#scroll_win(winid, forward, amount) abort
line 736: 
line 737: function! coc#float#content_height(bufnr, width, wrap) abort
line 747: 
line 748: function! coc#float#nvim_refresh_scrollbar(winid) abort
line 754: 
line 755: function! coc#float#on_close(winid) abort
line 764: 
line 765: " Close related windows, or specific kind
line 766: function! coc#float#close_related(winid, ...) abort
line 790: 
line 791: " Close related windows if target window is not visible.
line 792: function! coc#float#check_related() abort
line 808: 
line 809: " Show float window/popup for user confirm.
line 810: " Create buttons popup on vim
line 811: function! coc#float#vim_buttons(winid, config) abort
line 893: 
line 894: function! coc#float#nvim_float_click() abort
line 921: 
line 922: " Add <LeftRelease> mapping if necessary
line 923: function! coc#float#nvim_win_enter(winid) abort
line 931: 
line 932: function! coc#float#vim_filter(winid, key, keys) abort
line 943: 
line 944: function! coc#float#get_related(winid, kind, ...) abort
line 954: 
line 955: function! coc#float#get_row(winid) abort
line 966: 
line 967: " Create temporarily buffer with optional lines and &bufhidden
line 968: function! coc#float#create_buf(bufnr, ...) abort
line 999: 
line 1000: " Change border window & close window when scrollbar is shown.
line 1001: function! coc#float#nvim_scroll_adjust(winid) abort
line 1059: 
line 1060: function! coc#float#nvim_set_winblend(winid, winblend) abort
line 1069: 
line 1070: function! s:popup_visible(id) abort
line 1077: 
line 1078: function! s:convert_config_nvim(config, create) abort
line 1111: 
line 1112: function! s:create_btns_buffer(bufnr, width, buttons, borderbottom) abort
line 1149: 
line 1150: function! s:gen_filter_keys(line) abort
line 1175: 
line 1176: function! s:close_win(winid, noautocmd) abort
line 1190: 
line 1191: function! s:nvim_create_keymap(winid) abort
line 1198: 
line 1199: " getwininfo is buggy on neovim, use topline, width & height should for content
line 1200: function! s:nvim_get_botline(topline, height, width, bufnr) abort
line 1215: 
line 1216: " get popup position for vim8 based on config of neovim float window
line 1217: function! s:popup_position(config) abort
line 1233: 
line 1234: function! coc#float#add_related(winid, target) abort
line 1242: 
line 1243: function! coc#float#get_wininfo(winid) abort
line 1254: 
line 1255: function! s:popup_cursor(n) abort
line 1264: 
line 1265: " max firstline of lines, height > 0, width > 0
line 1266: function! s:max_firstline(lines, height, width) abort
line 1280: 
line 1281: " Get best lnum by topline
line 1282: function! s:get_cursorline(topline, lines, scrolloff, width, height) abort
line 1305: 
line 1306: " Get firstline for full scroll
line 1307: function! s:get_topline(topline, lines, forward, height, width) abort
line 1329: 
line 1330: " topline content_height content_width
line 1331: function! coc#float#get_options(winid) abort
line 1352: 
line 1353: function! s:win_setview(winid, topline, lnum) abort
line 1364: 
line 1365: function! s:set_float_defaults(winid, config) abort
line 1400: 
line 1401: function! s:nvim_add_related(winid, target, kind, winhl, related) abort
line 1414: 
line 1415: function! s:nvim_get_foldcolumn(config) abort
line 1426: 
line 1427: function! s:add_highlights(winid, config, create) abort
line 1442: 
line 1443: function! s:empty_border(border) abort
line 1449: 
line 1450: function! s:get_borderchars(config) abort
line 1457: 
line 1458: function! s:scroll_win(winid, forward, amount) abort
line 1465: 
line 1466: function! s:get_borderhighlight(config) abort
line 1475: 
line 1476: function! s:has_shadow(config) abort
finished sourcing /home/Dante/.vim/plugged/coc.nvim/autoload/coc/float.vim
continuing in CursorHold Autocommands for "*"
calling coc#float#check_related()

line 1:   let invalids = []
line 2:   let ids = coc#float#get_float_win_list(1)
calling coc#float#get_float_win_list(1)

line 1:   let res = []
line 2:   let list_all = get(a:, 1, 0)
line 3:   if s:is_vim
line 4:     if s:popup_list_api
line 5:       return filter(popup_list(), 'popup_getpos(v:val)["visible"]'.(list_all ? '' : '&& getwinvar(v:val, "float", 0)'))
coc#float#get_float_win_list returning []

continuing in coc#float#check_related

line 3:   for id in ids
line 4:     let target = getwinvar(id, 'target_winid', 0)
line 5:     if target && index(ids, target) == -1
line 6:       call add(invalids, id)
line 7:     endif
line 8:   endfor
line 9:   if s:is_vim && !s:popup_list_api
line 10:     let s:popup_list = filter(ids, "index(invalids, v:val) == -1")
line 11:   endif
line 12:   for id in invalids
line 13:     call coc#float#close(id)
line 14:   endfor
coc#float#check_related returning #0

continuing in CursorHold Autocommands for "*"

autocommand call s:Autocmd('CursorHold', +expand('<abuf>'), [line('.'), col('.')])

Executing: call s:Autocmd('CursorHold', +expand('<abuf>'), [line('.'), col('.')])
calling <SNR>46_Autocmd('CursorHold', 1, [1, 1])

line 1:   if !get(g:, 'coc_workspace_initialized', 0)
line 2:     return
line 3:   endif
line 4:   call coc#rpc#notify('CocAutocmd', a:000)
calling coc#rpc#notify('CocAutocmd', ['CursorHold', 1, [1, 1]])

line 1:   if !coc#rpc#ready()
calling coc#rpc#ready()

line 1:   if empty(s:client) || s:client['running'] == 0
line 2:     return 0
line 3:   endif
line 4:   return 1
coc#rpc#ready returning #1

continuing in coc#rpc#notify

line 2:     return ''
line 3:   endif
line 4:   call s:client['notify'](a:method, a:args)
calling <SNR>49_notify('CocAutocmd', ['CursorHold', 1, [1, 1]])

line 1:   let channel = coc#client#get_channel(self)
calling coc#client#get_channel()

line 1:   if s:is_vim
line 2:     return a:client['channel']
coc#client#get_channel returning channel 0 open

continuing in <SNR>49_notify

line 2:   if empty(channel)
line 3:     return ''
line 4:   endif
line 5:   try
line 6:     if s:is_vim
line 7:       call ch_sendraw(channel, json_encode([0, [a:method, a:args]])."\n")
line 8:     else
line 9:       call call('rpcnotify', [channel, a:method] + a:args)
line 10:     endif
line 11:   catch /.*/
line 12:     if v:exception =~# 'E475'
line 13:       if get(g:, 'coc_vim_leaving', 0)
line 14:         return
line 15:       endif
line 16:       echohl Error | echom '['.self.name.'] server connection lost' | echohl None
line 16:  echom '['.self.name.'] server connection lost' | echohl None
line 16:  echohl None
line 17:       let name = self.name
line 18:       call s:on_exit(name, 0)
line 19:       execute 'silent do User ConnectionLost'.toupper(name[0]).name[1:]
line 20:     elseif v:exception =~# 'E12'
line 21:       " neovim's bug, ignore it
line 22:     else
line 23:       echohl Error | echo 'Error on notify ('.a:method.'): '.v:exception | echohl None
line 23:  echo 'Error on notify ('.a:method.'): '.v:exception | echohl None
line 23:  echohl None
line 24:     endif
line 25:   endtry
<SNR>49_notify returning #0

continuing in coc#rpc#notify

line 5:   return ''
coc#rpc#notify returning ''

continuing in <SNR>46_Autocmd

<SNR>46_Autocmd returning #0

continuing in CursorHold Autocommands for "*"

calling lightline#link()

line 1:   let mode = get(s:lightline._mode_, a:0 ? a:1 : mode(), 'normal')
line 2:   if s:mode ==# mode
line 3:     return ''
lightline#link returning ''

calling lightline#mode()

line 1:   return get(s:lightline.mode_map, mode(), '')
lightline#mode returning 'NORMAL'

calling coc#api#call('eval', ['[win_getid(),coc#util#get_loaded_bufs(),coc#util#editor_infos()]'])

line 1:   let err = v:null
line 2:   let res = v:null
line 3:   try
line 4:     let res = call(s:funcs[a:method], a:args)
calling 287('[win_getid(),coc#util#get_loaded_bufs(),coc#util#editor_infos()]')

line 1:   return eval(a:expr)
calling coc#util#get_loaded_bufs()

line 1:   return map(getbufinfo({'bufloaded': 1}),'v:val["bufnr"]')
coc#util#get_loaded_bufs returning [1]

continuing in 287

calling coc#util#editor_infos()

line 1:   let result = []
line 2:   for info in getwininfo()
line 3:     if !coc#window#is_float(info['winid'])
calling coc#window#is_float(1000)

line 1:   if s:is_vim
line 2:     try
line 3:       return !empty(popup_getpos(a:winid))
Exception thrown: Vim(return):E993: Window 1000 is not a popup window

line 4:     catch /^Vim\%((\a\+)\)\=:E993/
Exception caught: Vim(return):E993: Window 1000 is not a popup window

line 5:       return 0
Exception finished: Vim(return):E993: Window 1000 is not a popup window

:return 0 made pending

line 6:     endtry
:return 0 resumed

coc#window#is_float returning #0

continuing in coc#util#editor_infos

line 4:       let bufnr = info['bufnr']
line 5:       let buftype = getbufvar(bufnr, '&buftype')
line 6:       if buftype !=# '' && buftype !=# 'acwrite'
line 7:         continue
line 8:       endif
line 9:       let bufname = bufname(bufnr)
line 10:       call add(result, { 'winid': info['winid'], 'bufnr': bufnr, 'tabid': coc#util#tabnr_id(info['tabnr']), 'fullpath': empty(bufname) ? '' : fnamemodify(bufname, ':p'), })
calling coc#util#tabnr_id(1)

line 1:   return s:is_vim ? coc#api#get_tabid(a:tabnr) : nvim_list_tabpages()[a:tabnr - 1]
calling coc#api#get_tabid(1)

line 1:   return s:tabnr_id(a:nr)
calling <SNR>50_tabnr_id(1)

line 1:   let tid = gettabvar(a:nr, '__tid', -1)
line 2:   if tid == -1
line 3:     let tid = s:tab_id
line 4:     call settabvar(a:nr, '__tid', tid)
line 5:     let s:tab_id = s:tab_id + 1
line 6:   endif
line 7:   return tid
<SNR>50_tabnr_id returning #1

continuing in coc#api#get_tabid

coc#api#get_tabid returning #1

continuing in coc#util#tabnr_id

coc#util#tabnr_id returning #1

continuing in coc#util#editor_infos

line 16:     endif
line 17:   endfor
line 2:   for info in getwininfo()
line 3:     if !coc#window#is_float(info['winid'])
line 4:       let bufnr = info['bufnr']
line 5:       let buftype = getbufvar(bufnr, '&buftype')
line 6:       if buftype !=# '' && buftype !=# 'acwrite'
line 7:         continue
line 8:       endif
line 9:       let bufname = bufname(bufnr)
line 10:       call add(result, { 'winid': info['winid'], 'bufnr': bufnr, 'tabid': coc#util#tabnr_id(info['tabnr']), 'fullpath': empty(bufname) ? '' : fnamemodify(bufname, ':p'), })
line 16:     endif
line 17:   endfor
line 18:   return result
coc#util#editor_infos returning [{'bufnr': 1, 'tabid': 1, 'fullpath': '', 'winid': 1000}]

continuing in 287

287 returning [1000, [1], [{'bufnr': 1, 'tabid': 1, 'fullpath': '', 'winid': 1000}]]

continuing in coc#api#call

line 5:   catch /.*/
line 6:     let err = v:exception .' on api "'.a:method.'" '.json_encode(a:args)
line 7:   endtry
line 8:   return [err, res]
coc#api#call returning [v:null, [1000, [1], [{'bufnr': 1, 'tabid': 1, 'fullpath': '', 'winid': 1000}]]]


Executing: q
Executing BufWinLeave Autocommands for "*"
autocommand call s:Autocmd('BufWinLeave', +expand('<abuf>'), bufwinid(+expand('<abuf>')))

Executing: call s:Autocmd('BufWinLeave', +expand('<abuf>'), bufwinid(+expand('<abuf>')))
calling <SNR>46_Autocmd('BufWinLeave', 1, 1000)

line 1:   if !get(g:, 'coc_workspace_initialized', 0)
line 2:     return
line 3:   endif
line 4:   call coc#rpc#notify('CocAutocmd', a:000)
calling coc#rpc#notify('CocAutocmd', ['BufWinLeave', 1, 1000])

line 1:   if !coc#rpc#ready()
calling coc#rpc#ready()

line 1:   if empty(s:client) || s:client['running'] == 0
line 2:     return 0
line 3:   endif
line 4:   return 1
coc#rpc#ready returning #1

continuing in coc#rpc#notify

line 2:     return ''
line 3:   endif
line 4:   call s:client['notify'](a:method, a:args)
calling <SNR>49_notify('CocAutocmd', ['BufWinLeave', 1, 1000])

line 1:   let channel = coc#client#get_channel(self)
calling coc#client#get_channel()

line 1:   if s:is_vim
line 2:     return a:client['channel']
coc#client#get_channel returning channel 0 open

continuing in <SNR>49_notify

line 2:   if empty(channel)
line 3:     return ''
line 4:   endif
line 5:   try
line 6:     if s:is_vim
line 7:       call ch_sendraw(channel, json_encode([0, [a:method, a:args]])."\n")
line 8:     else
line 9:       call call('rpcnotify', [channel, a:method] + a:args)
line 10:     endif
line 11:   catch /.*/
line 12:     if v:exception =~# 'E475'
line 13:       if get(g:, 'coc_vim_leaving', 0)
line 14:         return
line 15:       endif
line 16:       echohl Error | echom '['.self.name.'] server connection lost' | echohl None
line 16:  echom '['.self.name.'] server connection lost' | echohl None
line 16:  echohl None
line 17:       let name = self.name
line 18:       call s:on_exit(name, 0)
line 19:       execute 'silent do User ConnectionLost'.toupper(name[0]).name[1:]
line 20:     elseif v:exception =~# 'E12'
line 21:       " neovim's bug, ignore it
line 22:     else
line 23:       echohl Error | echo 'Error on notify ('.a:method.'): '.v:exception | echohl None
line 23:  echo 'Error on notify ('.a:method.'): '.v:exception | echohl None
line 23:  echohl None
line 24:     endif
line 25:   endtry
<SNR>49_notify returning #0

continuing in coc#rpc#notify

line 5:   return ''
coc#rpc#notify returning ''

continuing in <SNR>46_Autocmd

<SNR>46_Autocmd returning #0

continuing in BufWinLeave Autocommands for "*"

Executing BufUnload Autocommands for "*"
autocommand call s:Autocmd('BufUnload', +expand('<abuf>'))

Executing: call s:Autocmd('BufUnload', +expand('<abuf>'))
calling <SNR>46_Autocmd('BufUnload', 1)

line 1:   if !get(g:, 'coc_workspace_initialized', 0)
line 2:     return
line 3:   endif
line 4:   call coc#rpc#notify('CocAutocmd', a:000)
calling coc#rpc#notify('CocAutocmd', ['BufUnload', 1])

line 1:   if !coc#rpc#ready()
calling coc#rpc#ready()

line 1:   if empty(s:client) || s:client['running'] == 0
line 2:     return 0
line 3:   endif
line 4:   return 1
coc#rpc#ready returning #1

continuing in coc#rpc#notify

line 2:     return ''
line 3:   endif
line 4:   call s:client['notify'](a:method, a:args)
calling <SNR>49_notify('CocAutocmd', ['BufUnload', 1])

line 1:   let channel = coc#client#get_channel(self)
calling coc#client#get_channel()

line 1:   if s:is_vim
line 2:     return a:client['channel']
coc#client#get_channel returning channel 0 open

continuing in <SNR>49_notify

line 2:   if empty(channel)
line 3:     return ''
line 4:   endif
line 5:   try
line 6:     if s:is_vim
line 7:       call ch_sendraw(channel, json_encode([0, [a:method, a:args]])."\n")
line 8:     else
line 9:       call call('rpcnotify', [channel, a:method] + a:args)
line 10:     endif
line 11:   catch /.*/
line 12:     if v:exception =~# 'E475'
line 13:       if get(g:, 'coc_vim_leaving', 0)
line 14:         return
line 15:       endif
line 16:       echohl Error | echom '['.self.name.'] server connection lost' | echohl None
line 16:  echom '['.self.name.'] server connection lost' | echohl None
line 16:  echohl None
line 17:       let name = self.name
line 18:       call s:on_exit(name, 0)
line 19:       execute 'silent do User ConnectionLost'.toupper(name[0]).name[1:]
line 20:     elseif v:exception =~# 'E12'
line 21:       " neovim's bug, ignore it
line 22:     else
line 23:       echohl Error | echo 'Error on notify ('.a:method.'): '.v:exception | echohl None
line 23:  echo 'Error on notify ('.a:method.'): '.v:exception | echohl None
line 23:  echohl None
line 24:     endif
line 25:   endtry
<SNR>49_notify returning #0

continuing in coc#rpc#notify

line 5:   return ''
coc#rpc#notify returning ''

continuing in <SNR>46_Autocmd

<SNR>46_Autocmd returning #0

continuing in BufUnload Autocommands for "*"

Executing VimLeavePre Autocommands for "*"
autocommand call s:VimLeavePre()

Executing: call s:VimLeavePre()
calling <SNR>46_VimLeavePre()

line 1:   let g:coc_vim_leaving = 1
line 2:   call s:Autocmd('VimLeavePre')
calling <SNR>46_Autocmd('VimLeavePre')

line 1:   if !get(g:, 'coc_workspace_initialized', 0)
line 2:     return
line 3:   endif
line 4:   call coc#rpc#notify('CocAutocmd', a:000)
calling coc#rpc#notify('CocAutocmd', ['VimLeavePre'])

line 1:   if !coc#rpc#ready()
calling coc#rpc#ready()

line 1:   if empty(s:client) || s:client['running'] == 0
line 2:     return 0
line 3:   endif
line 4:   return 1
coc#rpc#ready returning #1

continuing in coc#rpc#notify

line 2:     return ''
line 3:   endif
line 4:   call s:client['notify'](a:method, a:args)
calling <SNR>49_notify('CocAutocmd', ['VimLeavePre'])

line 1:   let channel = coc#client#get_channel(self)
calling coc#client#get_channel()

line 1:   if s:is_vim
line 2:     return a:client['channel']
coc#client#get_channel returning channel 0 open

continuing in <SNR>49_notify

line 2:   if empty(channel)
line 3:     return ''
line 4:   endif
line 5:   try
line 6:     if s:is_vim
line 7:       call ch_sendraw(channel, json_encode([0, [a:method, a:args]])."\n")
line 8:     else
line 9:       call call('rpcnotify', [channel, a:method] + a:args)
line 10:     endif
line 11:   catch /.*/
line 12:     if v:exception =~# 'E475'
line 13:       if get(g:, 'coc_vim_leaving', 0)
line 14:         return
line 15:       endif
line 16:       echohl Error | echom '['.self.name.'] server connection lost' | echohl None
line 16:  echom '['.self.name.'] server connection lost' | echohl None
line 16:  echohl None
line 17:       let name = self.name
line 18:       call s:on_exit(name, 0)
line 19:       execute 'silent do User ConnectionLost'.toupper(name[0]).name[1:]
line 20:     elseif v:exception =~# 'E12'
line 21:       " neovim's bug, ignore it
line 22:     else
line 23:       echohl Error | echo 'Error on notify ('.a:method.'): '.v:exception | echohl None
line 23:  echo 'Error on notify ('.a:method.'): '.v:exception | echohl None
line 23:  echohl None
line 24:     endif
line 25:   endtry
<SNR>49_notify returning #0

continuing in coc#rpc#notify

line 5:   return ''
coc#rpc#notify returning ''

continuing in <SNR>46_Autocmd

<SNR>46_Autocmd returning #0

continuing in <SNR>46_VimLeavePre

line 3:   if s:is_vim && exists('$COC_NVIM_REMOTE_ADDRESS')
line 4:     " Helps to avoid connection error.
line 5:     call coc#rpc#close_connection()
line 6:     return
line 7:   endif
line 8:   if get(g:, 'coc_node_env', '') ==# 'test'
line 9:     return
line 10:   endif
line 11:   if s:is_vim
line 12:     call timer_start(1, { -> coc#client#kill('coc')})
line 13:   endif
<SNR>46_VimLeavePre returning #0

continuing in VimLeavePre Autocommands for "*"

Executing VimLeavePre Autocommands for "*"
autocommand exe s:persist()

Executing: exe s:persist()
calling <SNR>51_persist()

line 1:   if exists('g:SessionLoad')
line 2:     return ''
line 3:   endif
line 4:   let sessionoptions = &sessionoptions
line 5:   if exists('g:this_obsession')
line 6:     let tmp = g:this_obsession . '.' . getpid() . '.obsession~'
line 7:     try
line 8:       set sessionoptions-=blank sessionoptions-=options sessionoptions+=tabpages
line 9:       exe s:doautocmd_user('ObsessionPre')
line 10:       execute 'mksession!' fnameescape(tmp)
line 11:       let v:this_session = g:this_obsession
line 12:       let body = readfile(tmp)
line 13:       call insert(body, 'let g:this_session = v:this_session', -3)
line 14:       call insert(body, 'let g:this_obsession = v:this_session', -3)
line 15:       if type(get(g:, 'obsession_append')) == type([])
line 16:         for line in g:obsession_append
line 17:           call insert(body, line, -3)
line 18:         endfor
line 19:       endif
line 20:       call writefile(body, tmp)
line 21:       call rename(tmp, g:this_obsession)
line 22:       let g:this_session = g:this_obsession
line 23:       exe s:doautocmd_user('Obsession')
line 24:     catch /^Vim(mksession):E11:/
line 25:       return ''
line 26:     catch
line 27:       unlet g:this_obsession
line 28:       let &l:readonly = &l:readonly
line 29:       return 'echoerr '.string(v:exception)
line 30:     finally
line 31:       let &sessionoptions = sessionoptions
line 32:       call delete(tmp)
line 33:     endtry
line 34:   endif
line 35:   return ''
<SNR>51_persist returning ''

continuing in VimLeavePre Autocommands for "*"

Executing: 
Writing viminfo file "/home/Dante/.viminfo"